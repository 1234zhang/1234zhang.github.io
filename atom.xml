<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>brandon</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://1234zhang.github.io/"/>
  <updated>2020-07-14T15:23:26.662Z</updated>
  <id>https://1234zhang.github.io/</id>
  
  <author>
    <name>brandon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程池</title>
    <link href="https://1234zhang.github.io/2020/07/09/J.U.C/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://1234zhang.github.io/2020/07/09/J.U.C/线程池/</id>
    <published>2020-07-09T13:02:09.000Z</published>
    <updated>2020-07-14T15:23:26.662Z</updated>
    
    <content type="html"><![CDATA[<p>在看了AQS和concurrentHashMap之后，咱们继续往J.U.C包去深挖。这边博客是总结关于线程池的相关概念。阅读了部分源码，希望自己这次能够稍微理解一些关于线程池的概念吧。</p><p>线程池是相当重要的概念，在面试的时候也是一个常考的考点，同时理解线程池的设计思想也能帮助我们更好的coding。</p><a id="more"></a><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src="https://brandonxcc.top/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.jpg" alt="1"><br>我们重点关注的是ThreadPoolExecutor这个类，同时这个类也提供了很多的方法，我们涉及到下面这些类。<br><img src="https://brandonxcc.top/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="2"><br>同在并发包中的Executors,我们可以认为这个是一个工具类，类中的基本上是静态方法，提供了创建线程池的常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于线程池支持执行结果，所以，引入了Future接口，RunnableFuture就是继承了这个接口，我们最需要关心的就是他的实现类FutureTask。到这里我们可以明确一个概念，线程池的使用机制就是向线程池提交一个任务。我们提交的每一个任务是实现了一个Runnable接口，其实就是先包装成一个FutureTask，然后再提交到线程池中。FutureTask有一个通俗一点的解释就是：首先它是一个任务（Task），然后具有Future的特性，就是可以在将来得到结果。</p><p>而且线程池中的BlockingQueue也是一个非常重要的概念，如果线程达到了corePoolSize的大小，我们的每个任务就会被提交到等待队列中，等待线程池中的线程来获取任务去执行。</p><blockquote><p>除了上面说的这些类之外，还有一个很重要的类，就是定时器实现类 ScheduledThreadPoolExecutor，它继承自ThreadPoolExecutor，用于定时器执行。</p></blockquote><h1 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executor</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor这个接口非常简单，就一个<code>void executor(Runnable command)</code> 方法，代表提交一个任务。</p><h2 id="线程池的实现思路"><a href="#线程池的实现思路" class="headerlink" title="线程池的实现思路"></a>线程池的实现思路</h2><p>一般情况下，我们会使用下面的方法来启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="comment">// do something;</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>使用了线程池之后，我们就可以通过下面的方法使用多个线程执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = Executors.newFixedThreadPool(num);</span><br><span class="line">executor.execute(<span class="keyword">new</span> RunnableTask1());</span><br><span class="line">executor.execute(<span class="keyword">new</span> RunnableTask2());</span><br></pre></td></tr></table></figure><p>如果我们希望每个任务进来之后，直接启动一个线程来执行这个任务，我们可以这么实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPreTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每个新进来的任务使用一个线程来执行。</span></span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来看如何组合两个Executor来使用，下面这个实现是将所有任务都加到一个queue中，然后从queue中取任务，交给真正的执行者进行执行，这里使用了synchronized进行并发控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    <span class="comment">// 真正的执行器</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="comment">// 当前正在执行的任务</span></span><br><span class="line">    Runnable active;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化的时候，指定执行器</span></span><br><span class="line">    SerialExcutor(Excutor excutor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.excutor = excutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加任务到线程池：将任务添加到任务队列， scheduleNext触发执行器取任务队列中取任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executor</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        tasks.offer(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((active = task.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 具体的执行器</span></span><br><span class="line">            executor.execute(active);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Executor这个接口只有提交任务的功能，那未免太单调了，我们需要实现更多的功能，比如知晓线程执行结果，线程池中还有多少个线程，已经完成了多少个任务等等，来应对更多执行环境。接下来我们要介绍的继承自 <code>Executor</code> 接口的 <code>ExecutorService</code>接口。这个接口提供了比较丰富的功能。也是我们常用到的接口。</p><h1 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h1><p>一般我们定义一个线程池的时候，往往都是使用这个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(arg...);</span><br><span class="line">ExecutorService executor = Executors.newCachedThreadPool(arg...);</span><br></pre></td></tr></table></figure><p>因为这个接口定义的一系列方法大部分都可以满足我们都需要了。</p><p>接下来我们就来看看这些方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExcutorService</span> <span class="keyword">extends</span> <span class="title">Excutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关闭线程池，已经提交的线程继续执行，，不接受继续提交新任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池，尝试停止线程池中的任务，不接受继续提交任务</span></span><br><span class="line">    <span class="comment">// 它和前面的方法相比多了一个now，区别在于尝试停止当前正在运行的任务。</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池是否关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调用了shutdown()或者 shutdownNow()方法后，所有任务都结束了，那么返回true</span></span><br><span class="line">    <span class="comment">// 这个方法必须使用在shutdown()或者shutdownNow() 方法之后才会返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有任务完成，并设置超时时间</span></span><br><span class="line">    <span class="comment">// 我们这么理解，实际应用中是，先调用shutdonw()或者shutdownNow()</span></span><br><span class="line">    <span class="comment">// 然后再调用这个方法等待所有线程都执行结束了，返回值意味着有没有超时</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提交一个Callable任务</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个Runnable任务，第二个参数将会放到Future中，作为返回值，</span></span><br><span class="line">    <span class="comment">// 因为Runnable的run方法本身并不会返回任何东西</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个Runnable任务</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有任务，返回Future 类型的一个list</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedExcption;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也是执行所有任务，但是这个方法设置了执行时间</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks</span><br><span class="line">    , <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其中只要有一个任务完成了，那么就返回，返回执行的那个任务结果</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterrupedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上一个方法，只不过这个方法带了一个超时</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException,</span></span><br><span class="line"><span class="function">        TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单线程池主要就是这些功能，能够提交任务，获取执行结果，关闭线程池。这个也是我们为什么经常使用这个线程池的原因。</p><h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future           Runnable</span><br><span class="line">    \               /</span><br><span class="line">     \             /</span><br><span class="line">      RunnableFuture</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">        FutureTask</span><br><span class="line"></span><br><span class="line">FutureTask 通过 RunnableFuture 间接实现了Future和Runnable两个接口</span><br><span class="line">所以每个Runnable通常都包装成FutureTask</span><br><span class="line">然后调用executor.execute(Runnable command)将其提交给线程池。</span><br></pre></td></tr></table></figure><h1 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h1><p>AbstractExecutorService 抽象类派生自 ExecutorService接口，并实现了几个使用的方法，这些方法提供给子类调用。</p><p>抽象类实现了invokeAny和invokeAll方法，这里有两个newTaskFor方法也比较有用，用于将任务包装成FutureTask。定义于最上层接口中的 <code>void execute(Runnable command)</code> 由于不需要获取结果，不会进行FutureTask的包装。</p><blockquote><p>需要获取结果(FutureTask)， 用submit方法，不需要获取结果的可以使用execute方法。</p></blockquote><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>ThreadPoolExecutor是JDK中的线程池实现。这个类实现了线程池所需要的各个方法，它实现了任务提交、线程管理、监控等方法。</p><p>我们可以基于它来进行业务上的扩展，以实现我们需要的其他功能。</p><p>首先，我们来看看向线程池中提交任务的几个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个概念是，submit方法中的Runnable类型，这里的参数不是用于new Thread(<strong>Runnable</strong>).start()中的，此处的这个参数不是用于启动线程，这里是一个<strong>任务</strong>，用于给线程中的线程进行执行，执行的内容就是run()方法中定义的。</p><p>为了避免和多个Runnable搞混，因为经常把一个Runnable包到另一个Runnable里面，所以这里可以做一个区分。这里可以想象成有个Task接口，这个接口里面有一个run()方法。</p><p><img src="https://www.javadoop.com/blogimages/java-thread-pool/pool-1.png" alt="pool-1"></p><p>在看下面的代码的时候，我们就在内心保留几个疑问，上面的队列是否有界？提交任务的时候队列满了怎么办？提交任务的时候，线程池满了怎么办？空闲线程怎么关闭？</p><p>下面是我们经常使用的一个工具类，用来快速创建线程池，开发者可以不用考虑过多的细节。仅仅只需要提供必要的参数就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThread, nThread,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlokckingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Internet.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个静态的方法都最终会指向下面这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 这几个参数都是必须要有的</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上，上面的构造方法中列出了我们最需要关心的几个属性了，下面逐个介绍构造方法中出现的几个属性：</p><ul><li>corePoolSize</li></ul><blockquote><p>核心线程数</p></blockquote><ul><li>maximumPoolSize</li></ul><blockquote><p>最大线程数，线程池允许创建的最大线程数</p></blockquote><ul><li>workQueue</li></ul><blockquote><p>任务队列，BlockingQueue接口的某个实现（常使用ArrayBlockingQueue和LinkedBlockingQueue）。</p></blockquote><ul><li>keepAliveTime</li></ul><blockquote><p>空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有给它任务做，那么可以关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数量少于等于核心线程数量corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用<code>allowCoreThreadTimeout(true)</code>使核心线程内的线程也可以被回收。</p></blockquote><ul><li>threadFactory</li></ul><blockquote><p>用于生成线程，一般我们可以用默认的就可以。通常，我们可以通过它将我们的线程名字设置得比较可读一些，如Message-Thread-1,Message-Thread-2类似这样。</p></blockquote><ul><li>handle</li></ul><blockquote><p>当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定。有几种方式可供选择，例如抛出异常、直接拒绝然后返回等，也可以自己实现相应的接口实现自己的逻辑。</p></blockquote><p>Doug Lea 采用一个32位的整数来存放线程池的状态和当前线程池中线程的数量，其中高3位用于存放线程的状态，低29位来存放当前线程池中的线程数量。这个数量其实相当大了，大概有五亿多的线程。Java在编码上是统一的，都是采用补码的形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span></span><br><span class="line"><span class="comment">// 很多初学者很喜欢在自己的代码中写很多 29 这种数字，或者某个特殊的字符串，然后分布在各个地方，这是非常糟糕的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 000 11111111111111111111111111111</span></span><br><span class="line"><span class="comment">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911</span></span><br><span class="line"><span class="comment">// 以我们现在计算机的实际情况，这个数量还是够用的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们说了，线程池的状态存放在高 3 位中</span></span><br><span class="line"><span class="comment">// 运算结果为 111跟29个0：111 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 000 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 001 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 010 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 011 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整数 c 的低29位修改位0， 就得到了线程池的状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整数 c 的高三位修改为0， 就得到了线程池中线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;<span class="keyword">return</span> c &amp; CAPACITY;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123;<span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit field accessors that don't require unpacking ctl.</span></span><br><span class="line"><span class="comment"> * These depend on the bit layout and on workerCount being never negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是对一个整数的简单位操作，几个操作方法将会在后面的源码中一直出现，所以最好把名字和功能记住。避免看到后面的时候，来来回回的切换。</p><p>介绍一下线程池中各个状态和状态变化的过程：</p><ul><li>RUNNING: 这个就是最正常的状态，接受新的任务，处理等待队列中的任务</li><li>SHUTDOWN: 不接受新的任务提交，但是会继续处理等待队列中的任务</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>TIDYING：所有的任务都销毁了，workCount为0。线程池的状态转换为TIDYING状态时，会执行钩子方法terminated()</li><li>TERMINATED：terminated() 方法结束之后，线程池的状态就会变成这个。</li></ul><blockquote><p>RUNNING 定义为-1， SHUTDOWN定义为0， 其他的都比0大，所以等于0的时候不能提交任务，大于0的话，连正在执行的任务都会被中断。</p></blockquote><p>有了上面的介绍，我们可以看看相关的状态转换了。</p><ul><li>RUNNING -&gt; SHUTDOWN：当调用了shutdown之后，会发生这个状态转换</li><li>(RUNNING or SHUTDOWN) -&gt; STOP：当调用shutdownNow()之后，会发生这个转换。shutdown和shutdownNow两者之间的区别就可以显示出来了。</li><li>SHUTDOWN -&gt; TIDYING: 当任务队列和线程池都清空了之后，就会发生这个转换</li><li>STOP -&gt;TIDYING: 当任务队列清空之后，就会发生这个转换。</li><li>TIDYING -&gt; TERMINATED: 当调用了terminated这个方法之后。</li></ul><p>上面的状态转换只要记住最核心的就可以了，尤其是第一个和第二个状态转换。</p><p>我们还要看看另外一个内部类Worker。Doug Lea把线程池中的线程包装成了一个Worker，就是线程池中做任务的线程。所以到这里我们可以知道<strong>任务是RUNNABLE（内部变量名叫task 或者command），线程是Worker</strong></p><p>Worker这里又用到了抽象类 AbstractQueueSynchronizer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 真正执行任务的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的Runnable是一个任务。为什么叫firstTask？ 因为在创建线程的时候</span></span><br><span class="line">    <span class="comment">// 如果同时指定了这个线程起来以后需要执行的第一个任务，那么第一个任务就是存放在这里的（当然线程不止执行这一个任务）</span></span><br><span class="line">    <span class="comment">// 这个任务也可以为null， 这样线程起来了，自己到任务队列（BlockingQueue）中取任务（getTask方法）就可以了。</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存放此线程完成的任务数量，注意了，这里用了volatile，保证可见性。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Worker 只有这一个构造方法，传入firstTask，也可以传null</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 调用ThreadFactory来创建一个新的线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里调用了外部类的runWorker方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .... <span class="comment">// 其他的就是AQS的操作了，来获取这个线程的执行权。用了独占锁。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们终于可以康康ThreadPoolExecutor的execute方法了，各种方法都要依赖execute这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 这个就是前面说的表示 “线程池状态” 和 “线程数” 的整数</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 如果当前线程少于核心线程数，那么直接添加一个worker来执行任务</span></span><br><span class="line">    <span class="comment">// 创建一个新的线程，并把当前任务command作为这个线程的第一个任务（firstTask）</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 添加任务成功，那么这个方法就结束了。提交了任务，线程池也接受了这个任务，这个方法就可以返回了。</span></span><br><span class="line">        <span class="comment">// 这个任务的执行结果，会包装到FutureTask中。</span></span><br><span class="line">        <span class="comment">// 如果返回false，代表这个线程池不允许提交任务。</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明，要么线程数量大于核心线程数，要么addWorker失败了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程池处于RUNNING状态，那么就会把这个任务加到workQueue中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 这里说的是当任务进入到workQueue之后，我们是否需要开启新的线程。</span></span><br><span class="line"><span class="comment">        * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span></span><br><span class="line"><span class="comment">        * 如果线程数大于等于了corePoolSize，那么就会进入等待队列中。</span></span><br><span class="line"><span class="comment">        * 然后执行这个if的语句块</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果线程池不在RUNNING状态，那么移除已经入队的这个任务，并且执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池的状态还是RUNNING的，并且线程数为0，那么开启新的线程</span></span><br><span class="line">        <span class="comment">// 这块代码的真正意图是：担心任务提交到队列中了，但是线程池关闭了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果workQueue队列满了，就要进入这个分支</span></span><br><span class="line">    <span class="comment">// 以maxinumPoolSize为界创建新的worker</span></span><br><span class="line">    <span class="comment">// 如果失败了，说明当前线程数已经达到了maxinumPoolSize，就要执行拒绝策略。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对创建线程的错误理解：如果线程数少于corePoolSize，创建一个线程，如果线程数在[corePoolSize, maximumPoolSize] 之间那么可以创建线程或者复用空闲线程，<br>keepAliveTime对这个区间对线程是有效的</p></blockquote><blockquote><p>从上面的几个分支，我们可以看出这段话是错误的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1. 第一个参数是准备提交给这个线程执行的任务，之前说了，这个可以为null</span></span><br><span class="line"><span class="comment">2. 第二个参数为true表示实现线程核心数corePoolSize作为创建线程的边界，</span></span><br><span class="line"><span class="comment">也就是创建这个线程的时候如果线程池中的线程总数已经达到corePoolSize，</span></span><br><span class="line"><span class="comment">那么不能响应这次创建线程的请求</span></span><br><span class="line"><span class="comment">如果是false，代表使用最大线程数maximumPoolSize作为边界。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = ctl.get();;) &#123;</span><br><span class="line">        <span class="comment">// 下面这个if语句</span></span><br><span class="line">        <span class="comment">// 如果线程池已经关闭，并满足以下条件之一，那么不创建新的worker：</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于 SHUTDOWN，其实也就是STOP，TIDYING或者TERMINATED</span></span><br><span class="line">        <span class="comment">// 2. firstTask != null</span></span><br><span class="line">        <span class="comment">// 3. workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">// 简单分析就是：</span></span><br><span class="line">        <span class="comment">// 还是状态控制的问题，当线程池处于SHUTDOWN的时候，不允许提交任务，但是已经有的任务继续执行</span></span><br><span class="line">        <span class="comment">// 当状态大于SHUTDOWN时候，不允许提交新的任务，且中断正在执行的任务</span></span><br><span class="line">        <span class="comment">// 如果线程处于SHUTDOWN的时候，但是firstTask为null，且workQueue非空，那么是允许创建worker的</span></span><br><span class="line">        <span class="comment">// 因为SHUTDOWN的语义：不允许提交新的任务，但是要把已经进入到</span></span><br><span class="line">        <span class="comment">// workQueue的任务执行完，所以在满足条件基础上，是允许创建新的worker的</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="keyword">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c)</span><br><span class="line">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果成功了，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span></span><br><span class="line">            <span class="comment">// 这里失败了，说明有其他线程也在尝试往线程池中创建线程。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 由于有并发，重新再读取以下ctl</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 正常如果是CAS失败的话，进入到下一个里层的for循环就可以了</span></span><br><span class="line">            <span class="comment">// 但是如果因为其他的线程的操作，导致线程池的状态发生了更改，如有其他线程关闭了这个线程池</span></span><br><span class="line">            <span class="comment">// 那么需要回到外层for循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了</span></span><br><span class="line"><span class="comment">    * 因为该校验的都校验完了，至于以后发生什么，那是以后的事情了，至少当前满足条件了。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// worker是否已经启动了。</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 是否已将这个worker添加到workers这个hashSet中了。</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 把fisrtTask 传给worker的构造方法</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 取worker中的线程对象，worker的构造方法会调用ThreadFactory来创建一个新的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这个是整个线程的全局锁，持有这个锁才能让下面的操作顺利进行</span></span><br><span class="line">            <span class="comment">// 因为关闭一个线程池需要这个锁，至少在我持有锁的期间，线程池不会关闭。</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                <span class="comment">// 下面是小于STOP，则有可能是小于SHUTDOWN或者等于SHUTDOWN</span></span><br><span class="line">                <span class="comment">// 如果小于SHUTDOWN，这个是正常执行的情况</span></span><br><span class="line">                <span class="comment">// 如果是等于SHUTDOWN，那么说明是不接受新的任务，但是会继续执行等待队列中的任务。</span></span><br><span class="line">                <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 这个线程可能不是新创建的线程</span></span><br><span class="line">                    <span class="keyword">if</span> (t.getState() != Thread.State.NEW)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 加到workers这个hashset中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// largestPoolSize用于记录workers中的个数的最大值</span></span><br><span class="line">                    <span class="comment">// 因为workers是不断减少的，通过这个值可以知道线程池的大小曾经达到最大值。</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加成功之后，启动这个线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程没有启动，需要做一些清理工作，如前面workCount加了1，将其减掉</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回线程是否启动成功。</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下addWorkFailed的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workers 中删除掉相应的worker</span></span><br><span class="line"><span class="comment">// workerCount 减 1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        &#125;</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回过头来，继续看下面的代码，我们知道，worker中线程start之后，其run方法会调用runWorker方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker类的run()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看 runWorker方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法由worker线程启动后调用，这里用一个while循转来不断地从等待队列中取任务并执行</span></span><br><span class="line"><span class="comment">// worker在初始化的时候，可以指定firstTask，那么第一个任务也就可以不需要从队列中获取</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 该线程的第一个任务（如果有的话）</span></span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 循环调用getTask获取任务</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// 如果线程池状态大于等于STOP，那么意味着该线程也要中断。</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这是一个钩子方法，留给需要的子类实现</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这里是执行任务</span></span><br><span class="line">                        task.run();</span><br><span class="line">                        afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        afterExecute(task, ex);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 置空task， 准备getTask获取下一个任务</span></span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 累加完成的任务数</span></span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    <span class="comment">// 释放掉worker的独占锁</span></span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果到这里，需要执行线程关闭</span></span><br><span class="line">            <span class="comment">// 1. getTask返回null， 也就是说，队列已经没有任务需要执行了，执行关闭</span></span><br><span class="line">            <span class="comment">// 2. 任务执行过程中发生了异常</span></span><br><span class="line">            <span class="comment">// 第一种情况，已经在代码中处理了，将workCount减一，会在getTask进行分析</span></span><br><span class="line">            <span class="comment">// 第二种情况，workCount没有进行处理，所以需要在processWorkerExit中处理</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在看看getTask()是怎么获取任务的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法有三种可能</span></span><br><span class="line"><span class="comment">// 1. 阻塞直到获取到任务返回，我们知道，默认corePoolSize之内的线程是不会被回收的</span></span><br><span class="line"><span class="comment">//      它会一直等待任务</span></span><br><span class="line"><span class="comment">// 2. 超时退出。keepAliveTime起作用的时候，也就是如果这么多时间内没有任务，那么就会关闭</span></span><br><span class="line"><span class="comment">// 3. 如果发生以下条件，此方法必须返回null</span></span><br><span class="line"><span class="comment">//  a. 池中有大于maximumPoolSize个wokers存在（通过调用setMaximumPoolSize进行设置）</span></span><br><span class="line"><span class="comment">//  b. 线程池处于SHUTDOWN，而且workQueue是空的，这个状态不接受新的任务</span></span><br><span class="line"><span class="comment">//  c. 线程池处于STOP，不仅不接受新的线程，连workQueue中的线程也不再执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里两种可能</span></span><br><span class="line">            <span class="comment">// 1. rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()</span></span><br><span class="line">            <span class="comment">// 2. rs &gt;= STOP</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">                &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class="line">                    <span class="comment">// CAS操作，减少工作线程</span></span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取工作线程数量</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">            <span class="comment">// 允许核心线程数内的线程超时回收，或者当前线程数超过核心线程数</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前线程数大于maximumPoolSize或者超时</span></span><br><span class="line">            <span class="comment">// 并且线程数大于1或者workQueue，满足上面两个情况才会返回null（如果cas成功）</span></span><br><span class="line">            <span class="comment">// 返回null，意味着关闭线程。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 为什么线程数大于maximumPoolSize 或者超时，可能会返回null(cas成功)</span></span><br><span class="line">            <span class="comment">// 因为有可能开发者调用了setMaximumPoolSize()将线程池中的</span></span><br><span class="line">            <span class="comment">// maximumPoolSize调小了，那么多余的worker就会被关闭</span></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="comment">// 这里说明如果超时了以及线程数大于maximumPoolSize，但是work</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="comment">// 这里cas失败，说明线程池中的线程数发生了改变。</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// wc &lt;= maximumPoolSize 同时没有超时，或者没有工作线程，同时workQueue不为空。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 到workQueue中获取任务</span></span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                <span class="comment">// 如果此时worker发生了中断，采取的方式是重试</span></span><br><span class="line">                <span class="comment">// 为什么会发生中断</span></span><br><span class="line">                <span class="comment">// 如果开发者将maximumPoolSize调小了，导致其小于当前的worker数量</span></span><br><span class="line">                <span class="comment">// 那么意味着超出的部分线程将要被关闭，重新进入for循环，自然会有部分线程返回null</span></span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面再来看看关于线程池的拒绝策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行拒绝策略</span></span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的handle，我们需要在构造线程的时候就传入这个参数，他是RejectedExecutionHandler的实例</p><p>RejectedExecutionHandler 在 ThreadPoolExecutor 中有四个已经定义好的实现类可供我们直接使用，当然，我们也可以实现自己的策略，不过一般也没有必要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管怎样，直接抛出 RejectedExecutionException 异常</span></span><br><span class="line"><span class="comment">// 这个是默认的策略，如果我们构造线程池的时候不传相应的 handler 的话，那就会指定使用这个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不做任何处理，直接忽略掉这个任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个相对霸道一点，如果线程池没有被关闭的话，</span></span><br><span class="line"><span class="comment">// 把队列队头的任务(也就是等待了最长时间的)直接扔掉，然后提交这个任务到等待队列中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，ThreadPoolExecutor 的源码算是分析结束了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看了AQS和concurrentHashMap之后，咱们继续往J.U.C包去深挖。这边博客是总结关于线程池的相关概念。阅读了部分源码，希望自己这次能够稍微理解一些关于线程池的概念吧。&lt;/p&gt;
&lt;p&gt;线程池是相当重要的概念，在面试的时候也是一个常考的考点，同时理解线程池的设计思想也能帮助我们更好的coding。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于ReentrantReadWriteLock的那些事</title>
    <link href="https://1234zhang.github.io/2020/06/22/%E5%85%B3%E4%BA%8EReentrantReadWriteLock%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://1234zhang.github.io/2020/06/22/关于ReentrantReadWriteLock的那些事/</id>
    <published>2020-06-22T07:13:10.000Z</published>
    <updated>2020-07-07T16:52:54.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于ReentrantReadWriteLock的使用例子"><a href="#关于ReentrantReadWriteLock的使用例子" class="headerlink" title="关于ReentrantReadWriteLock的使用例子"></a>关于ReentrantReadWriteLock的使用例子</h2><p>下面是javadoc中对ReentrantReadWriteLock的使用例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">    <span class="comment">//读写锁实例</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取读锁</span></span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123; <span class="comment">// 如果缓存过期了，或者为null</span></span><br><span class="line">            <span class="comment">// 释放读锁，加写锁（如果没有释放掉读锁就加写锁，会导致死锁的产生）</span></span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheCalid) &#123; <span class="comment">// 这里判断的主要目的是查看是否有其他线程执行过程中，对缓存空间进行了写操作</span></span><br><span class="line">                    data = ...;</span><br><span class="line">                    cacheValue = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  获取读锁（持有写锁的情况下，允许获取读锁，这是是锁降级</span></span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于ReentrantReadWriteLock的使用例子&quot;&gt;&lt;a href=&quot;#关于ReentrantReadWriteLock的使用例子&quot; class=&quot;headerlink&quot; title=&quot;关于ReentrantReadWriteLock的使用例子&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>concurrentHashmap源码解读</title>
    <link href="https://1234zhang.github.io/2020/05/17/J.U.C/concurrentHashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>https://1234zhang.github.io/2020/05/17/J.U.C/concurrentHashmap源码解读/</id>
    <published>2020-05-17T07:58:52.000Z</published>
    <updated>2020-07-07T16:46:07.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程不安全的hashmap"><a href="#线程不安全的hashmap" class="headerlink" title="线程不安全的hashmap"></a>线程不安全的hashmap</h1><p>总所周知，hashmap是一个线程不安全的集合结构。在多线程的情况下，链表会成环。</p><h2 id="多线程的hashmap为什么会成环"><a href="#多线程的hashmap为什么会成环" class="headerlink" title="多线程的hashmap为什么会成环"></a>多线程的hashmap为什么会成环</h2><p>这个在jdk8以下会出现的问题，因为jdk7采用的是头插法，在进行扩容的时候会对原有的元素进行rehash。rehash的结果会出现链表的拆分，原有的链表会被拆成两份。在并发的环境之下，某个节点先保存了next，另外的节点又在next后面添加了e，第一个线程再次执行，先头插了next，再头插了e。由于第二个线程再next后面加上了e节点，继续头插，e又跑到了next前面。就出现了环。这个情况再jdk8以后有所解决，jdk8中采用了尾插法，rehash之后每个元素的相对位置不会发生改，所以jdk8发生环的概率会小很多。但是jdk8还是线程不安全的，在并发的条件下，还是建议使用接下来要介绍的concurrenthashmap。</p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>在jdk7和jdk8中，跟hashMap一样，在实现上有一些差异，下面分别来讲一讲jdk7和jdk8的不同</p><h2 id="ConcurrentHashMap在jdk7的实现"><a href="#ConcurrentHashMap在jdk7的实现" class="headerlink" title="ConcurrentHashMap在jdk7的实现"></a>ConcurrentHashMap在jdk7的实现</h2><p><img src="https://www.javadoop.com/blogimages/map/3.png" alt="jdk7的concurrentHashMap"></p><p><strong>concurrencyLevel</strong> : 并行级别或者segment数量，默认是16个。也就是说ConcurrentHashMap有16和Segment，所以理论上这个时候可以支持16个线程并发写，只要他们的操作分别分布在不同的segment上。这个值可以在初始化的时候设置为其他的值，但是一旦初始化之后，是不可以扩容的。</p><p><strong>initialCapacity</strong> : 初始容量，这个值指的是整个ConcurrentHashMap的初始容量，实际操作的时候需要平均分给每个Segment<br><strong>loadFactor</strong> : 负载因子，因为Segment是不可扩容的，所以这个负载因子是给每个Segment内部使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt;= <span class="number">0</span> || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS) </span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算并行级别sszie，保持并行级别是2的n次方</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里我们先使用默认值 concurrencyLevel 为16，sshift为4</span></span><br><span class="line">    <span class="comment">// 可以计算出segmentShift为28，segmentMask为15</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// initialCapacity是设置整个map初始的大小</span></span><br><span class="line">    <span class="comment">// 根据initialCapacity计算segment数组中每个位置可以分到的大小</span></span><br><span class="line">    <span class="comment">// 如 initialCapacity 为64，那么每个Segment可以分到4个。</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initilaCapacity) ++c;</span><br><span class="line">    <span class="comment">// 默认MIN_SEGMETN_TABLE_CAPACITY是2， 也是有讲究的，因为这样的话，对于具体的segment上</span></span><br><span class="line">    <span class="comment">// 插入一个元素不会扩容，插入两个元素才会扩容</span></span><br><span class="line">    <span class="keyword">int</span> cap = c;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c) &#123;</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建segment数组</span></span><br><span class="line">    <span class="comment">// 并创建数组的第一个元素，segment[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 = <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap*loadFactor),</span><br><span class="line">                                        (HashEntry&lt;K,V&gt;()) <span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[]) <span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    <span class="comment">// 往数组里面写入segment[0]</span></span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segment[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成了， 我们得到一个Segment数组。<br>这里我们可以认为是使用 new ConcurrentHashMap() 无参构造器函数进行初始化的，那么初始化完成之后</p><ul><li>Segment数组长度为16，不可扩容</li><li>Segment[i]的默认长度是2， 负载因子是0.75，得出阈值是1.5。那么在插入一个元素的时候不会扩容，插入两个元素的时候就会扩容。</li><li>这里初始化了segment[0]，其他位置还是null</li><li>当前的segmentShift的值为32 - 4 = 28， segmentMask的值是16 - 1 = 15，姑且把他们当作移位数和掩码。</li></ul><h3 id="put过程分析"><a href="#put过程分析" class="headerlink" title="put过程分析"></a>put过程分析</h3><p>首先从put的主流程开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K, V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 1. 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2. 根据hash值找到Segment数组中的位置j</span></span><br><span class="line">    <span class="comment">//      hash是32位，无符号有移segmentShift(28)位，剩下高4位</span></span><br><span class="line">    <span class="comment">//      然后和segmentMask(15)做一次与操作，也就是j是hash高4位就是segment数组的下标位置</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 刚刚初始化的时候，只初始化了segment[0]，但是其他位置上还是null</span></span><br><span class="line">    <span class="comment">// ensureSegment(j) 对segment[j]进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K, V&gt;) UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 3. 插入新值到槽s中</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一层逻辑很简单，就是根据hash值找到相应的Segment，之后就是Segment内部的put操作</p><p>Segment内部是由数组加链表组成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在往该segment写入之前，需要先获得该segment的独占锁</span></span><br><span class="line">    HashEntry&lt;K, V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是segment内部的数组</span></span><br><span class="line">        HashEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 利用hash值，找到应该放置的数组下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first 是数组该位置出的链表的表头</span></span><br><span class="line">        HashEntry&lt;K, V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="comment">// 下面的循环主要处理该位置没有任何元素，和已经存在一个链表两种情况</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K, V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        <span class="comment">// 覆盖旧值</span></span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 继续顺着链表走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// node 是否为null，要看获取锁的过程(tryLock())</span></span><br><span class="line">                <span class="comment">// 如果不为空，则直接将node设置为表头</span></span><br><span class="line">                <span class="comment">// 如果为空，初始化并设置为表头</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>) node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span> node = <span class="keyword">new</span> HashEntry&lt;K, V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果超过了该segment的阈值，这个segment需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPCITY)</span><br><span class="line">                    rehash(node); <span class="comment">// 扩容操作</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="comment">// 没有达到阈值，将node放到数组tab的index位置</span></span><br><span class="line">                    <span class="comment">// 其实就是将新的节点设置成为原链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于有独占锁的保护，所以segment内部的操作并不复杂。</p><p>接下来介绍put操作中的关键步骤</p><p><strong>初始化segment：ensureSegment</strong><br>ConcurrentHashMap 初始化的时候会初始化第一个槽segment[0]，对于其他的槽来说，在插入第一个值的时候，需要进行初始化。</p><p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽segment[k]，只要有一个成功就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K, V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K, V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    Segment&lt;K, V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K, V&gt;) UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里看到为什么之前要初始化segment[0]了，</span></span><br><span class="line">        <span class="comment">// 使用segment[0]处的数组长度和负载因子来初始化segment[k]</span></span><br><span class="line">        <span class="comment">// 为什么要用“当前”， 因为segment[0]可能早就扩容过了</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactory;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        <span class="comment">// 初始化segment[k]内部数组</span></span><br><span class="line">        HashEntry&lt;K, V&gt; tab = (HashEntry&lt;K, V&gt;[]) <span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K, V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 再次检查是否被其他线程初始化了</span></span><br><span class="line">            Segment&lt;K, V&gt; s = <span class="keyword">new</span> Segment&lt;K, V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 使用while循环，内部用cas，当前线程成功设值或其他线程成功设置后，退出</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K, V&gt;) UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，ensureSegment(int k)比较简单，对于并发操作使用CAS进行控制。上面的while循环是为了cas失败后，将seg赋值返回。</p><p><strong>获取写入锁：scanAndLockForPut</strong><br>在往某个segment中put的时候，首先会调用node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次tryLock()快速获取该segment的独占锁，如果失败，那么进入到scanAndLockForPut这个方法来获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K, V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K, V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K, V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K, V&gt; node =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 进到这里说明该位置的链表是空的，没有任何元素</span></span><br><span class="line">                    <span class="comment">// 当然，进到这里的另外一个原因是tryLock()失败，所以该槽存在并发，不一定是该位置</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试次数如果超过MAX_SCAN_RETRIES(单核1 多核64)，那么不抢了，</span></span><br><span class="line">        <span class="comment">// 进入到阻塞队列等待锁，lock()是阻塞方法，直到获取锁之后返回。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里了，说明有新的元素进入到了链表，成为了新的表头</span></span><br><span class="line">        <span class="comment">// 所以这边的策略是，相当于重新走一遍这个scanAndLockForPut方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f;</span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有两个出口，一个是tryLock()成功了，循环终止，另一个就是重试次数超过了MAX_SCAN_RETRIES，进到lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p><p>这个方法看似复杂，其实就做了一件事请，就是获取该segment的独占锁，如果需要的话，顺便实例化一下node。</p><p><strong>扩容：rehash</strong><br>segment数组不能扩容，扩容是segment数组某个位置内部的数组HashEntry&lt;K, V&gt;[]进行扩容，扩容之后容量为原来的两倍。</p><p>首先我们要回顾一下触发扩容的地方，put的时候，如果判断该值的插入会导致该segment的元素个数超过阈值，那么先进行扩容，再插值。可以这个时候回去看一眼put的过程</p><p>该方法不需要考虑并发，因为到这里的时候，是持有该segment的独占锁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法参数中的node是这次扩容之后，需要添加到新数组的数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K, V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 2倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    HashEntry&lt;K, V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，例如从16扩容到32，那么sizeMask为31，对应二进制'000....0011111'</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历原数组，将原数组位置i处的链表拆分到新数组位置i和i + oldCap两个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity; i++) &#123;</span><br><span class="line">        <span class="comment">// e是链表的第一个元素</span></span><br><span class="line">        HashEntry&lt;K, V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K, V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算应该放置在新数组中的位置</span></span><br><span class="line">            <span class="comment">// 假设原数组长度为16， e在oldTable[3]处，那么idx只可能是3或者是3 + 16 = 19</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// e 是链表的头节点</span></span><br><span class="line">                HashEntry&lt;K, V&gt; lastRun = e;</span><br><span class="line">                <span class="comment">// idx是当前链表头节点e的新位置</span></span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">// 下面这个for循环会找到一个lastRun节点</span></span><br><span class="line">                <span class="comment">// 这个节点之后的所有元素是将要放到一起的</span></span><br><span class="line">                <span class="keyword">for</span>(HashEntry&lt;K,V&gt; last = next; last != <span class="keyword">null</span>; last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将lastrun及其之后的所有节点组成的这个链表放到lastIdx这个位置</span></span><br><span class="line">                newTab[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// 下面的操作是处理lastRun之前的节点</span></span><br><span class="line">                <span class="comment">// 这些节点分配在另一个链表中，也可能分配到上面的那个链表中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K, V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K, V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K, V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新来的node放到新数组中刚刚的两个链表之一的头部</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask;</span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = ndoe;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个for循环挨到一起的，但是我们仔细看了一下，如果没有第一个循环也是可以工作的。但是这个循环下来，如果lastRun的后面还有比较多的节点，那么这次循环就是值得的。因为我们只需要克隆lastRun前面的节点，后面的一串节点跟着lastRun走就行了，不用进行任何操作。但是如果lastRun都是链表最后一个节点的或者很靠后的节点，那么这次遍历就有点浪费了，不过doug lea说了，根据统计，如果使用默认值，大约只有1/6的节点需要克隆。</p><h3 id="get过程分析"><a href="#get过程分析" class="headerlink" title="get过程分析"></a>get过程分析</h3><p>相对于put过程，get过程就简单很多了。</p><ol><li>计算hash值，找到segment数组中具体位置</li><li>segment里面也是一个数组，根据hash找到数组中具体位置</li><li>顺着链表进行查找即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K, V&gt; s;</span><br><span class="line">    HashEntry&lt;K, V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 1. hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 2. 根据hash找到对应的segment</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K, V&gt; UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span>) &amp;&amp; (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 找到segment内部相应的链表，遍历</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K, V&gt; e = (HashEntry&lt;K, V&gt; UNSAFE.getObjectVolatile</span><br><span class="line">        (tab, (<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; hash)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">         e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">             K k;</span><br><span class="line">             <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                 <span class="keyword">return</span> e.value;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h3><p>在get的时候，没有加锁，所以我们就需要考虑并发问题。</p><p>添加节点的操作put和删除节点的操作remove都是加了独占锁的，所以这两个操作之间是不会有影响的。我们要考虑的问题是get的时候同一个segment发生了put或者remove的情况。</p><ol><li><p>put操作的线程安全性</p><ul><li>初始化槽，使用CAS来初始化Segment中的数组</li><li>添加节点到链表的操作是插入到表头的，所以，如果这个时候get操作在链表遍历的过程已经到来中间，是不会影响的。另一个并发问题就是get操作在put之后，需要保证刚刚插入表头的节点被读取，这个依赖于setEntryAt方法中使用的UNSAFE.putOrderedObject.</li><li>扩容。扩容是新创建了数组，然后进行迁移数据，最后将newTable设置给属性table。所以，如果get操作此时也在进行，那么也没有关系，如果get先行，那么就是在旧的table上做查询操作；而put先行，那么put操作的可见性保证就是table使用了volatile关键字。</li></ul></li><li><p>remove操作的线程安全性</p><p> 如果remove操作破坏的节点get操作已经过去了，那么这里不存在任何问题</p><p> 如果remove先破坏了一个节点，分两种情况考虑</p><ol><li>如果此节点是头节点，那么需要将头节点的next设置为数组该位置的元素，table虽然使用了volatile修饰，但是volatile并不能提供数组内部操作的可见性保证，所以源码中使用了UNSAFE来操作数组，关于这部分的源码在setEntryAt</li><li>如果要删除的节点不是头节点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是next属性是volatile的。</li></ol></li></ol><h1 id="JAVA8关于concurrentHashMap的相关源码"><a href="#JAVA8关于concurrentHashMap的相关源码" class="headerlink" title="JAVA8关于concurrentHashMap的相关源码"></a>JAVA8关于concurrentHashMap的相关源码</h1><p>jdk8中的结构如下：<br><img src="https://www.javadoop.com/blogimages/map/4.png" alt="4"></p><p>jdk7中使用分段锁的方式进行并发控制，最大并发量是segment的数量。但是jkd8为了提高并发量，直接使用了一个较大的数组。同时也引入了红黑树这个数据结构，来解决hash冲突。在结构上和jdk8的hashmap结构相同，但是要保证并发性，所以代码会更加复杂一些。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>无参数的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指定初始容量的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">           MAXIMUM_CAPACITY :</span><br><span class="line">           tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过提供容量，计算来sizeCtl的大小，sizeCtl = [(1.5 * initialCapacity) 向上取得最近的2的n次方数]。如果initialCapacity是10，那么sizeCtl就是16，如果是11，那么就是32</p><h2 id="put过程分析-1"><a href="#put过程分析-1" class="headerlink" title="put过程分析"></a>put过程分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 取得hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录链表长度</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="comment">// 如果数组为空，或者长度为0</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 则初始化数组。</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 使用hash值，找到对应下标位置，得到第一个节点f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该位置为空，那么使用cas将元素放入这个位置</span></span><br><span class="line">            <span class="comment">// 如果cas成功，那么这次的put操作完成</span></span><br><span class="line">            <span class="comment">// 如果cas失败，则说明有竞争，那么就要进行下一次循环。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果hash == MOVED，那么就要进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移。</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 如果onlyIfAbsent == true(说明要替换)</span></span><br><span class="line">        <span class="comment">// 而且key == 首节点的key</span></span><br><span class="line">        <span class="comment">// 那么我们就要替换这个value值。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">                 &amp;&amp; fh == hash</span><br><span class="line">                 &amp;&amp; ((fk = f.key) == key || (fk != <span class="keyword">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                 &amp;&amp; (fv = f.val) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 到这里说明f是首节点，而且不为空</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取首节点的监视器锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 判断首节点的hash值&gt;0，则说明是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 用于累加，记录链表长度。</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果遇到相同key的值，判断是否需要替换</span></span><br><span class="line">                            <span class="comment">// 如果要替换，则替换之后，退出</span></span><br><span class="line">                            <span class="comment">// 如果不需要替换，则直接退出。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 遍历到了链表的末端，则将这个值添加到末尾。</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果是树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的方式插入到末尾节点。</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果key为空的话，就会初始化一个ReservationNode进行占为。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断链表长度是否到达或者超过阈值，进行树化操作。和HashMap相同，也是8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和hashMap有一些不同。就是不一定会进行树化</span></span><br><span class="line">                    <span class="comment">// 如果当前数组长度小于64的话，则会进行扩容，而不会进行树化。</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是put的主流程，其中还有几个小流程没有顾及到，分别是数组初始化，树化，扩容和数据迁移等。</p><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 有其他的线程正在进行数据初始化。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 如果没有其他线程进行数组初始化，那么使用cas将sizeCtl设置为-1，然后开始数组初始化。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// DEFAULT_CAPACITY默认值为16。</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">// 初始化数组，设置为默认值16或者指定初始化的长度。</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给table，table是使用volatile修饰的。</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 将sc的值，设置为 n * 0.75</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 将sizeCtl设置为sc的值。</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当数组长度小于MIN_TREEIFY_CAPACITY时候，即是小于64，则会进行扩容，而不会树化。</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// b是头节点，要判断头节点是否为空。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对这个头节点进行加锁。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">// 遍历链表，建立红黑树</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将红黑树放到数组对应对位置上。</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容和数据迁移操作"><a href="#扩容和数据迁移操作" class="headerlink" title="扩容和数据迁移操作"></a>扩容和数据迁移操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在参数传入进来的时候，已经size翻了倍了。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c = size * 1.5 + 1 然后再向上取最接近2的n次方的那个数。</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 下面这个分支和数组初始化相同。</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                    (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的核心在于sizeCtl的操作。首先将其设置为一个负数，然后再调用tranfer方法。整个tryPresize方法中可能会调用多次transfer这个方法。<br>接下来就要去看看这个方法里面到底做了啥</p><h3 id="数据迁移：transfer"><a href="#数据迁移：transfer" class="headerlink" title="数据迁移：transfer"></a>数据迁移：transfer</h3><p>这个方法主要是将原来的tab数组的元素迁移到新的nextTab中。</p><p>虽然之前的tryPresize方法中多次调用transfer这个方法，但是不涉及多线程。其他的地方也在调用这个方法，比如put方法中有一个helpeTransfer方法，这个方法中就涉及到transfer方法的调用。</p><p>这里的并发机制是，愿数组有n那么长，就有n个任务，每个线程执行一个任务是最简单的，每做完一个任务再检测是否还有其他的任务没有做完，帮助迁移就可以了。而Doung lea使用了一个stride，每个线程执行一部分的任务。所以我们需要一个统筹调度者，来规划那个线程执行哪些任务，这个就是transferIndex的作用。</p><p>第一个发起数据迁移任务的线程会将transferIndex指向数组的末端，然后从后往前移动stride个位置，这stride个任务就会被分配给第一个线程。然后transferIndex指向新的位置。下一次分配stride个任务的起点就是transferIndex的新位置，然后再分配给下一个线程（其实也可能是同一个线程，如果这个线程把stride个任务执行完了的话）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// stride在单核的条件下等于n，多核模式下等于 (n &gt;&gt;&gt; 3) / NCPU（NCPU是cpu的核心数）。stride的最小值是16</span></span><br><span class="line">    <span class="comment">// stride可以理解为步长，有n个位置要迁移。</span></span><br><span class="line">    <span class="comment">// 将n个任务分为多个任务包，任务包中有stride个小任务。</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">// 如果nextTab为null，则需要初始化这个数组</span></span><br><span class="line">    <span class="comment">// 外围调用这个方法的时候会保证第一次进行数据迁移的时候nextTab可以为空</span></span><br><span class="line">    <span class="comment">// 之后参与数据迁移的线程调用的时候nextTab不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nextTable是concurrenthashmap中的属性</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// transfer也是concurrenthashmap中的属性，用于控制数据迁移的位置</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// ForwardingNode这个对象的构造方法，会生成一个node，其中key、value和next都为null</span></span><br><span class="line">    <span class="comment">// 但是这个node的hash值是MOVED</span></span><br><span class="line">    <span class="comment">// 在后面的步骤中，我们可以看到当i这个位置的数据完成迁移之后</span></span><br><span class="line">    <span class="comment">// 就会将i这个位置的值设置为这个node，用来提醒其他线程，这个位置数据迁移已经完成了。</span></span><br><span class="line">    <span class="comment">// 所以ForwardingNode这个对象，更多的是像一个标志位。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// advance指的是做完了一个位置的迁移工作，可以做下一个位置的了。</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">// i是位置索引，bound是边界值，注意是从后往前的。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">// 下面这个while循环中</span></span><br><span class="line">        <span class="comment">// advance为true表示可以进行下一个位置的迁移</span></span><br><span class="line">        <span class="comment">// i = transferIndex； bound = transferIndex - stride</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果transfer &lt;= 0，说明原数组的所有位置都有相应的线程进行处理了。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// bound是迁移任务的边界，可以看到nextBound的赋值位置而且是从后往前的。</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 所有迁移操作已经完成</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 将nextTab的值赋给table，完成迁移</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 设置sizeCtl为新数组长度的0.75倍。</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// sizeCtl在进行数据迁移之间会将值设置为(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span></span><br><span class="line">            <span class="comment">// 然后每个参与数据迁移对线程，在调用前都会将sizeCtl进行加一，表示线程领取了这个任务</span></span><br><span class="line">            <span class="comment">// 然后在执行数据迁移之后，会将sizeCtl的值减一，表示完成了这个任务。</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 到这里说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT</span></span><br><span class="line">                <span class="comment">// 这样就会执行上面到if语句块，然后方法执行结束。</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果i位置是空的，那么就会将ForwardingNode这个node放到这个位置，表示迁移完成</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 如果这个位置的hash值是MOVED说明这个位置已经迁移完成了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对该位置的链表头节点加锁，开始数据迁移。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 头节点的hash值大于等于0， 说明是链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 下面的数据迁移和jdk7差不多</span></span><br><span class="line">                        <span class="comment">// 找到原链表中的lastRun，lastRun后面的节点一起进行迁移</span></span><br><span class="line">                        <span class="comment">// lastRun前面的节点进行克隆，然后分到两个链表中。</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 其中一个链表放在位置i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 另外一个链表放在i + n的位置</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 然后将i的位置设置为fwd</span></span><br><span class="line">                        <span class="comment">// 其他线程看到该位置是MOVED，就不会进行数据迁移了。</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// 将advance设置为true，表示数据迁移完成。</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树的迁移。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说起来，transfer这个方法并没有完成所有的迁移任务，每次调用这个方法只实现了transferIndex往前stride个位置的迁移。其他的还是需要外围函数的帮忙。</p><h2 id="put过程分析-2"><a href="#put过程分析-2" class="headerlink" title="put过程分析"></a>put过程分析</h2><ol><li>计算 hash 值</li><li>根据 hash 值找到数组对应位置: (n - 1) &amp; h</li><li>根据该位置处结点性质进行相应查找<ul><li>如果该位置为 null，那么直接返回 null 就可以了</li><li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li><li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li><li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头结点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程不安全的hashmap&quot;&gt;&lt;a href=&quot;#线程不安全的hashmap&quot; class=&quot;headerlink&quot; title=&quot;线程不安全的hashmap&quot;&gt;&lt;/a&gt;线程不安全的hashmap&lt;/h1&gt;&lt;p&gt;总所周知，hashmap是一个线程不安全的集合结构。
      
    
    </summary>
    
      <category term="Java" scheme="https://1234zhang.github.io/categories/Java/"/>
    
      <category term="JUC" scheme="https://1234zhang.github.io/categories/Java/JUC/"/>
    
    
      <category term="java并发" scheme="https://1234zhang.github.io/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码解析三</title>
    <link href="https://1234zhang.github.io/2020/05/13/J.U.C/AQSAQS%E6%BA%90%E7%A0%81%E4%B8%89/"/>
    <id>https://1234zhang.github.io/2020/05/13/J.U.C/AQSAQS源码三/</id>
    <published>2020-05-13T15:11:44.000Z</published>
    <updated>2020-06-24T06:11:10.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前两篇中，分析了ReentrantLock内部的实现，以及Condition的实现使用。这篇将要分析countDownLatch有关的共享模式，和CyclicBarrier、Semaphore的实现，其实在有了前两篇的经验之后，会发现这里面的套路其实有很多相似的地方。</p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch的实现是比较经典的AQS共享模式的体现。</span><br><span class="line">而且这个也是一个高频使用的类</span><br></pre></td></tr></table></figure><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>这个是Doug Lea在Java doc中的例子：</p><p>假设我们有N(N &gt; 0)个任务，那么我们会用N来初始化一个CountDownlatch，然后将这个latch的引用传递到各个线程中，在每个线程完成了任务之后，调用latch.countDown()代表完成了一个任务， 调用<code>latch.await()</code>的方法的线程将会阻塞，直到所有的任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throw InterruptedException</span>&#123;</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        Executor e = Executors.newFixedThreadPool(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建N个任务，交给线程池来完成</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主线程调用await方法，直到所有的任务完成，这个方法才会返回。</span></span><br><span class="line">        doneSignal.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkRunnable</span><span class="params">(CountDownLatch doneSignal, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doWork(i);</span><br><span class="line">            doneSignal.coutDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用CountDownLatch将几个大的任务拆分成几个小的任务，然后开启多线程开始执行，等所有线程都执行完了之后，再往下执行其他操作，这个例子中，只有main线程调用了await方法。<br>下面还有一个很经典的例子，这里使用了两个CountDownLatch。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(startSignal, doneSignal)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里调用其他方法是为了让所有的线程都启动起来。</span></span><br><span class="line">        doSomethingElse();</span><br><span class="line">        <span class="comment">// 因为这里的数量只有一，所以只要调用一次那么所有的await方法都可以通过</span></span><br><span class="line">        startSignal.countDown();</span><br><span class="line">        doSomethingElse();</span><br><span class="line">        <span class="comment">// 等待所有任务结束</span></span><br><span class="line">        doneSignal.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">    Work(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">        <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 为了让所有的线程同时开始任务，所以让所有的线程都再这里阻塞</span></span><br><span class="line">            <span class="comment">// 等所有的线程都准备好了，就可以打开这个栅栏</span></span><br><span class="line">            startSignal.await();</span><br><span class="line">            doWork();</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/5.png" alt="avatar"><br>如果始终只有一个线程调用await方法等待任务完成，那么CountDownLatch就会简单很多。对于多个线程做任务，那么就要构造这么一个场景：有m个线程是做任务的，有n个线程在某个栅栏上等待这m个线程做完任务，直到所有m个任务完成后，n个线程同时通过栅栏。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>构造方法，需要传入一个不小于0的整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟以前一样 内部封装一个Sync类继承AQS</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueueSynchornizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        <span class="comment">// 在这里state == count了</span></span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以根据以前的经验先分析一遍：我们知道AQS内部有一个state，是一个整数值，这边用一个int count参数其实就是初始化了state这个值，所有调用了await方法的等待线程会挂起，然后有其他一些线程会做state = state - 1操作，当state减到0的同时，那个state减为0的线程会负责唤醒所有调用了await方法的线程。</p><p>下面有一个例子来帮助我们阅读代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里使每个线程休息5秒，模拟每个线程工作了5秒</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2  = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(InterruptedException ignore) &#123;</span><br><span class="line">                    <span class="comment">// return </span></span><br><span class="line">                &#125;</span><br><span class="line">                latch.coutDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">"线程t3从await中返回了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程t3被中断了"</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t3"</span>);</span><br><span class="line">        </span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">"线程t4从await中返回了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程t4被中断了"</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t4"</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行上面的程序之后，大概十秒钟之后会出现下面的语句</span></span><br><span class="line"><span class="comment">// 下面的语句顺序不是绝对的。</span></span><br><span class="line">线程t3从await中返回了</span><br><span class="line">线程t4从await中返回了</span><br></pre></td></tr></table></figure><p>根据流程：先await等待，然后被唤醒，await方法返回</p><h3 id="等待过程"><a href="#等待过程" class="headerlink" title="等待过程"></a>等待过程</h3><p>首先，我们可以关注await方法，它代表线程被阻塞，等待state减值到0的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 中断状态的抛出，在上一篇中有提到过</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// t3和t4调用await的时候，state都大于0，此时state为2</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doAcquireSharedInterruptibly这个从名字上可以看出是获取到共享锁，并且这个方法还是可中断的</p><p>中断的时候抛出InterruptedException退出这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 入队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// tryAcquireShared只要state不等于0，那么就返回-1</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在线程t3入队以后我们可以得到下面的情况<br><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/2.png" alt="avatar"></p><p>由于tryAcquireShared这个方法会返回-1，所以if (r &gt;= 0) 这个分支不会进去。到shouldParkAfterFailedAcquire的时候，t3将head的waitStatus值设置为-1</p><p> <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/3.png" alt="avatar"></p><p> 然后进入到parkAndCheckInterrupt的时候，t3挂起。然后再分析t4入队，t4会将前驱节点t3所在的节点的waitStatus设置为-1<br> <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/4.png" alt="avatar"></p><p> 然后t3跟t4就等待被唤醒</p><h3 id="countDown减少到0的过程"><a href="#countDown减少到0的过程" class="headerlink" title="countDown减少到0的过程"></a>countDown减少到0的过程</h3><p>这里将state数量添加到10，是为了更丰富示意图<br><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/1.png" alt="avatar"><br>当state等于0的时候，就会开始唤醒阻塞线程<br>(注意我们其实没有十个线程，只有两个t1和t2两个线程，这里的十个线程只是为了示意图好看，并没有其他的含义)</p><p>接下来开始看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tryReleaseShared只有在state == 0的时候才会返回true</span></span><br><span class="line">    <span class="comment">// 否则只是简单的state -= 1</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒阻塞队列中的元素</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="comment">// 使用自旋的方式对state进行减1操作</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>countDown方法的作用很简单，就是对state进行减1操作，直到state减到0的时候，就对调用了await方法的线程进行唤醒</p><h3 id="state-0的时候，开始唤醒线程"><a href="#state-0的时候，开始唤醒线程" class="headerlink" title="state == 0的时候，开始唤醒线程"></a>state == 0的时候，开始唤醒线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用这个方法的时候，state已经减少到0了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// Node.SIGNAL == -1</span></span><br><span class="line">                <span class="comment">// 将头部的waitState设置为0</span></span><br><span class="line">                <span class="keyword">if</span> (!h.compareAndSetWaitStatus(Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 这里设置成功了，就唤醒head后继的第一个节点，也就是唤醒阻塞队列中的第一个节点</span></span><br><span class="line">                <span class="comment">// 这里是唤醒t3</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !h.compareAndSetWaitStatus(<span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>t3被唤醒之后，我们继续回到await方法中，parkAndCheckInterrupt返回，我们不考虑中断的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 这个时候state = 0，那么tryAcquireShared就会返回1</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); </span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 检查被挂起的时候，是否发生过中断</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当t3被唤醒之后，就会循环，然后进入到setHeadAndPropagate这个方法中，使得t3成为头部，然后唤醒后继节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// 下面说的是，唤醒node的后继节点</span></span><br><span class="line">    <span class="comment">// 即是t3已经醒了，要唤醒t4，依此类推</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 再一次运行这个方法，只不过现在的节点换成了t3</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们回过头来再看看doReleaseShared()这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 此时的头部是t3</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// h == null 说明阻塞队列已经空了，就不必继续唤醒了</span></span><br><span class="line">        <span class="comment">// h == tail 说明头节点是刚刚初始化的头节点</span></span><br><span class="line">        <span class="comment">//           或者是普通线程节点，但该节点已经是头节点了，说明已经被唤醒了，阻塞队列没有其他的节点了</span></span><br><span class="line">        <span class="comment">// 所以这两种情况满足一种了，都不必再进行后继节点的唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// t4将头节点(此时是t3)的waitStatus设置为了Node.SIGNAL(-1)了</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 这里的cas失败，要结合下面一起看</span></span><br><span class="line">                <span class="keyword">if</span> (!h.compareAndSetWaitStatus(Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 这里唤醒head的后继节点，也就是阻塞队列中的第一个节点</span></span><br><span class="line">                <span class="comment">// 这里是唤醒t4</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//  这里CAS失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个ws设置为-1</span></span><br><span class="line">                     !h.compareAndSetWaitStatus(<span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里的时候，刚刚唤醒的线程已经占领了head，那么再循环</span></span><br><span class="line">        <span class="comment">// 如果head没有改变，则退出循环</span></span><br><span class="line">        <span class="comment">// 退出循环不意味着阻塞队列中的其他节点不唤醒，唤醒的线程之后还是会调用这个方法唤醒后继节点。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里来分析最后一个if语句，然后才能知道第一个CAS失败的原因</p><ul><li>head == h：说明头节点还没有被刚刚用unparkSuccessor唤醒的线程占用，此时break退出循环</li><li>head != h：头节点被刚刚唤醒的线程占用，那么这里重新进入下一轮的循环，唤醒下一个节点。我们知道等到t4被唤醒之后，会主动去唤醒后继节点的，这里为什么要进入下一轮循环来唤醒后继节点t5呢？这里应该是对吞吐量的考虑。</li></ul><p>在满足了上面2的场景之后，我们能知道为什么第一个CAS会失败。<br>因为当前进行for循环的线程到了这里之后，可能刚刚唤醒的t4线程也刚刚到这里，两个只能成功一个，就有可能触发失败</p><p>for循环第一轮的时候会唤醒t4，t4醒了之后会将自己设置为头节点。如果t4设置为头节点之后，for循环才跑到if (h == head)，那么此时就会返回一个false，for循环就会进入下一轮。t4唤醒之后也会进入这个方法，那么for循环的第二轮(此时的head是t4)和t4就有可能在这个CAS相遇，那么就只会成功一个。</p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>CyclicBarrier字面意思就是”可重复使用的栅栏”或”周期性栅栏”，总之不是用了一次就不能用的，CyclicBarrier相比CountDownLatch来说，要简单很多，没有什么高深的地方，他是ReentrantLock和Condition的组合使用。</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/cyclicbarrier-2.png" alt="avatar"></p><p>CyclicBarrier的源码实现大相径庭，CountDownLatch基于AQS，而CyclicBarrier基于Condition来实现。</p><p>用下面这张图来描述CyclicBarrier里面的一些概念，和一些基本使用流程<br><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-3/cyclicbarrier-3.png" alt="avatar"></p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 是可以重复使用的，每次从开始使用到穿过栅栏当作一代，或者一个周期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 是基于Condition的</span></span><br><span class="line">    <span class="comment">// Condition 是条件的意思，CyclicBarrier的等待线程通过barrier的条件是大家都到达了栅栏上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参与的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> parties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了这个，代表越过栅栏之前，要执行相应的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommond;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前所处的代</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还没有到栅栏的线程数，这个值初始值是parties，然后递减</span></span><br><span class="line">    <span class="comment">// 还没有到栅栏的线程数 = parties - 已经到了栅栏的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllergalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么开启新的一代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先唤醒所有在栅栏上的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 初始化还没有到栅栏处的线程数</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 重新生成一代</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何打破一个栅栏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置broken状态为 true</span></span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 重置count为初始值</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有已经在等待的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始分析通知在栅栏处等待的await方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doawait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带超时机制，如果超时抛出TimeoutException异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析dowait方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dowait</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 首先要获取锁</span></span><br><span class="line">        <span class="comment">// 在condition中，被await的时候，会释放锁，然后在signal()被唤醒的时候重新获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">            <span class="comment">// 如果栅栏被打破，抛出BrokenBarrierException异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">            <span class="comment">// 检查中断状态，如果中断了，要抛出InterruptedException异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">// 要打破栅栏，避免其他线程一直等待</span></span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// index是dowait方法的返回值</span></span><br><span class="line">            <span class="comment">// index是count递减的值</span></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line">            <span class="comment">// 这里判断是否还有没到达栅栏处的线程</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 在初始化的时候，指定了通过栅栏前需要操作的操作，在这里会得到执行</span></span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    <span class="comment">// 如果ranAction为true，说明在执行command.run()的时候没有报错</span></span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 唤醒等待线程，并开启新一代。</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    <span class="comment">// 到这里说明执行command的时候发生了异常，会打破栅栏</span></span><br><span class="line">                    <span class="comment">// 打破意味着唤醒所有在栅栏处等待的线程。</span></span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="comment">// 如果是最后一个线程调用await，那么上面就直接返回了</span></span><br><span class="line">            <span class="comment">// 下面是非最后一个线程调用await的执行过程。</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果有超时机制，调用超时的Condition的await方法等待，直到最后一个线程调用await</span></span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="comment">// 如果到这个代码块中，则说明等待的线程在条件队列中被中断了</span></span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        <span class="comment">// 打破栅栏</span></span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="comment">// 打破栅栏之后，将InterruptException抛出给外层处理</span></span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 到这里说明g != generation 说明新的一代已经产生，即最后一个线程await执行完成</span></span><br><span class="line">                        <span class="comment">// 此时没有必要再抛出InterruptedException异常，记录下这个中断信息即可</span></span><br><span class="line">                        <span class="comment">// 或者栅栏已经被打破了，也不会抛出InterruptedException异常，</span></span><br><span class="line">                        <span class="comment">// 而是之后抛出BrokenBarrierException异常</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒之后，检查栅栏是否是破的</span></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">                <span class="comment">// 这个for循环除了异常，就是要从这里退出了</span></span><br><span class="line">                <span class="comment">// 最后一个线程在执行完指定任务(如果有)，就会开启一个新的周期</span></span><br><span class="line">                <span class="comment">// 然后释放锁，其他线程从Condition的await方法中得到锁并返回，然后到这里的时候，就会满足g != generation</span></span><br><span class="line">                <span class="comment">// 那么什么时候会不满足</span></span><br><span class="line">                <span class="comment">// barrierCommand执行过程中抛出了异常，那么会执行打破栅栏的操作</span></span><br><span class="line">                <span class="comment">// 设置broken为true，然后唤醒这些线程，这些线程会从上面的if (g.broken)这个分支抛出BrokenBarrierException异常返回</span></span><br><span class="line">                <span class="comment">// 还有最后一个可能，就是await超时了，这种情况不会抛出异常，而是执行后面的代码</span></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                <span class="comment">// 如果醒来了发现超时了，那么就要打破栅栏，并抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如何知道还有多少线程到了栅栏上，处于等待状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parties - count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个栅栏是否被打破了，直接查看broken状态即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generation.broken;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么时候栅栏会被打破</p><ol><li>中断：如果某个线程发生了中断，那么会打破栅栏，同时抛出InterruptedException异常</li><li>超时：打破栅栏，同时抛出TimeoutException异常</li><li>指定执行的操作抛出了异常<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1>Semaphore类似一个资源池，每个线程需要调用acquire()方法获取资源，然后才能执行，执行完之后要release资源，让其他线程使用</li></ol><p>semaphore其实就是AQS的共享锁的使用，所有线程共用一个资源池</p><p>创建Semaphore的时候，需要一个参数permits，这个基本上可以确定是设置给AQS的state的，然后每个线程调用acquire的时候，执行state = state - 1，release的时候执行state = state + 1, acquire 的时候state = 0说明没有资源，需要等待其他线程release</p><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比Semaphore公平策略和非公平策略，对比tryAcquireShared方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平策略：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平策略：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再回到acquireShared方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于tryAcquireShared(arg)返回小于0的时候，说明state已经小于0了(没资源了)，此时acquire不能立马拿到资源，需要进入到阻塞队列等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务介绍，释放一个资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="comment">// 溢出，当然，我们一般也不会用这么大的数</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryReleaseShared 方法总是会返回 true，然后是 doReleaseShared，这个也是我们熟悉的方法了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://brandonxcc.top/20200516.jpg" alt="a"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在前两篇中，分析了ReentrantLock内部的实现，以及Condition的实现使用。这篇将要分析countDownLatch有关的共享
      
    
    </summary>
    
      <category term="Java" scheme="https://1234zhang.github.io/categories/Java/"/>
    
      <category term="JUC" scheme="https://1234zhang.github.io/categories/Java/JUC/"/>
    
    
      <category term="java并发" scheme="https://1234zhang.github.io/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码解析(二)</title>
    <link href="https://1234zhang.github.io/2020/04/28/J.U.C/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C/"/>
    <id>https://1234zhang.github.io/2020/04/28/J.U.C/AQS源码解析-二/</id>
    <published>2020-04-28T15:05:11.000Z</published>
    <updated>2020-06-24T06:11:10.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看了上篇的描述之后，我觉得我应该已经对AQS的大概运行过程有了一个初步的了解，当然这远远不够。快扶我起来，我还能继续学！<br>这篇将继续写有关AQS的相关知识，有关于公平与非公平锁，带条件的锁。还有关于中断的一些知识。废话不多说。咱们走着。</p><h1 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h1><p>首先咱们来谈谈关于Java的公平锁与非公平锁。公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体的吞吐效率相对非公平锁要低，等待队列中除了第一个以外的所有线程都要阻塞，cpu唤醒阻塞线程的开销比较大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到的时候才会到队尾等待。但如果此时锁正好可以用了，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁先获取到资源的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率比较高。缺点是有些处于等待队列的线程可能被饿死，获取等待很久才获取到锁。</p><p>下图是公平锁</p><p><img src="https://brandonxcc.top/Java%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="avatar"></p><p>下图是非公平锁</p><p><img src="https://brandonxcc.top/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="avatar"></p><h2 id="关于源码"><a href="#关于源码" class="headerlink" title="关于源码"></a>关于源码</h2><p>在ReentrantLock中，内部将两种锁都实现了。其中默认的是非公平锁，如果要使用公平锁，只需要在创建的时候带上true参数就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们再看看线程来的时候，公平锁与非公平锁是如何争夺资源的:</p><p>公平锁的lock方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里有一个判断阻塞队列中是否有元素</span></span><br><span class="line">            <span class="comment">// 如果有元素，则老老实实的去排队</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是非公平锁的lock方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>非公平锁与公平锁的区别：</p><ul><li>非公平锁在调用lock后，就会使用CAS进行一次枪锁，如果这个时候恰巧没有被占用，那么就直接获取锁然后返回了</li><li>公平锁在CAS失败之后，和公平锁一样会调用tryAcquire方法，在tryAcquire方法中，如果发现这个锁被释放了，那么再进行一次CAS枪锁，如果失败就要在阻塞队列的队尾进行等待。公平锁会判断等待队列是否有线程处于等待状态，如果有则不去获取锁，直接到队尾进行等待。</li></ul><p>公平锁与非公平锁就这两点区别，如果两次CAS都不成功，都要到队尾进行等待被唤醒。</p><h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><p>Condition的使用场景，Condition经常使用在生产者消费者的场景中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 依赖于lock来产生</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">                notFull.await();  <span class="comment">// 队列已经满了，直到not full 才能继续生产。</span></span><br><span class="line">            &#125;</span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();  <span class="comment">// 生产成功， 队列已经not Empty了。</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[getptr];</span><br><span class="line">            <span class="keyword">if</span> (++getptr == items.length) getptr = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal(); <span class="comment">// 被消费了一个，已经not full了，可以开始生产。</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看到，在使用condition时候，必须先持有相应的锁。这个和Object类中的方法有相似的语义，需要先持有某个对象的监视器锁才可以执行wait()、notify()或者notifyAll()方法。</p><p>condition是依赖于ReentrantLock的，不管是调用await进入等待还是signal唤醒，都必须获取到锁才能进行操作。</p><p>每个ReentrantLock实例可以通过多次调用newCondition产生多个ConditionObject的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化一个ConditionObject</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要熟悉Condition，我们首先要关注一下Condition实现类AbstractQueueSynchronizer类中的ConditionObject。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">111111111111</span>;</span><br><span class="line">    <span class="comment">// 条件队列中的第一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// 条件队列中最后一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在学习reentrantLock的时候，我们知道了阻塞队列，在学习condition的时候，我们要引入一个条件队列</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-2/aqs2-2.png" alt="条件队列"></p><p>首先解释上面这张图</p><ol><li>条件队列和阻塞队列都是Node的实例，条件队列中的Node要转移到阻塞队列中去</li><li>ReentrantLock实例可以通过调用newCondition()来实现多个Condition实列，这里对应的是Condition1和Condition2表示生成的多个实例。ConditionObject只有两个属性firstWaiter和lastWaiter</li><li>每个condition都有一个关联的条件队列，比如线程1调用Condition1.await()方法，就会将线程1包装进Node实例中，然后加入到condition1这个条件队列中，并阻塞在这里，不再继续往下执行，条件队列是一个单向队列</li><li>调用condition1.signal()触发一次唤醒，此时唤醒的是队头，会将condition1对应条件队列的firstWaiter(队头)加入到阻塞队列队尾中，等待获取锁，获取锁之后，await方法才会返回，继续往下执行(这里要结合消费者和生产者的模型来看)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里就要简单回顾一下Node的属性了</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus; <span class="comment">// 可取值0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱节点</span></span><br><span class="line"><span class="keyword">volatile</span> Node next; <span class="comment">// 后继节点</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread; <span class="comment">// 当前线程</span></span><br><span class="line">Node nextWaiter; <span class="comment">// 后继等待的节点</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prev和next实现双向链表，nextWaiter实现条件队列的单向链表</span><br></pre></td></tr></table></figure><h2 id="await方法分析"><a href="#await方法分析" class="headerlink" title="await方法分析"></a>await方法分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法是可以被中断的，不可被中断的是另外一个方法awaitUninterruptibly()</span></span><br><span class="line"><span class="comment">// 这个方法会被阻塞，直到调用signal或者被中断。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 方法要响应中断，就要在最开始判断中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 添加到Condition的条件队列中。</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放锁，释放的值是之前state的值</span></span><br><span class="line">    <span class="comment">// 要调用await方法，首先线程要获得锁，既然获得了锁，等待的之前肯定要释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里跳出循环的两种方式</span></span><br><span class="line">    <span class="comment">// 1. isOnSyncQueue(node)，返回true，说明已经转移到阻塞队列中了</span></span><br><span class="line">    <span class="comment">// 2. checkInterruptWhileWaiting(node) != 0会break，然后跳出循环，表示线程被中断。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被唤醒之后，进入阻塞队列，等待获取锁。</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将节点加入到条件队列"><a href="#将节点加入到条件队列" class="headerlink" title="将节点加入到条件队列"></a>将节点加入到条件队列</h2><p>addConditionWatier()是将当前节点加入到条件队列，这种条件队列内操作是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前线程对应的节点入队，插入队尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="comment">// 如果条件队列的队尾节点取消了排队，就把这个节点清除</span></span><br><span class="line">    <span class="comment">// 如果waitstatus 不为node.CONDITION,则说明取消了在条件队列中排队。</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 下面的方法会遍历这个队列，将取消等待的节点清除</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在节点初始化时，要将waitStatus设置为node.CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Node.CONDITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t 此时时lastWaiter队尾</span></span><br><span class="line">    <span class="comment">// 如果队列为空的话</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在addWaiter方法中，有一个unlinkCancelledWaiters()方法，该方法用于清除已经取消排队的节点。</p><p>如果在调用await方法的时候发生了取消操作，或者在节点入队的时候，发现最后一个节点是被取消的，会调用这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待队列是一个单向链表，遍历链表将已经取消的节点清除</span></span><br><span class="line"><span class="comment">// 这个方法在本来注释中有一句"Called only while holding lock."</span></span><br><span class="line"><span class="comment">// 说明只有在拥有锁的时候才能调用这个方法，则说明是线程安全的。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全释放独占锁"><a href="#完全释放独占锁" class="headerlink" title="完全释放独占锁"></a>完全释放独占锁</h2><p>回到wait方法，节点入队以后，会调用<code>int savedState = fullyRelease(node);</code>方法来释放锁，这里是完全释放独占锁(fully release),因为ReentrantLock是可重入的。</p><p>如果在执行condition1.await()之前，先执行了两次lock()操作，那么state为2，可以理解为该线程上了两把锁，这里await()方法必须将state设置为0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有两把锁，才能继续下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，要观察到返回值saveState代表release之前的state值</span></span><br><span class="line"><span class="comment">// 对于简单的操作：先lock.lock(),然后condition1.await().</span></span><br><span class="line"><span class="comment">// 那么state经过这个方法由1变成0，锁释放，此方法返回1</span></span><br><span class="line"><span class="comment">// 相应的，如果lock重入了n次，savedState == n</span></span><br><span class="line"><span class="comment">// 如果这个方法失败，会将节点设置为"取消"状态，并抛出异常IllegalMonitorStateException</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 使用当前的state作为操作，将锁完全释放掉。</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState))</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        node.waitStatus = Node.CANCELLED;</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个线程在不持有lock的基础上，就去调用condition1.await()方法，它能进入条件队列，但在上面的方法中，使用release方法会返回false。就会抛出IllegalMonitorStateException错误，然后进入catch代码块。将waitState状态设置为取消，那么在下一个节点入队的时候，就会把这个取消的节点清除。</p><h2 id="等待进入阻塞队列"><a href="#等待进入阻塞队列" class="headerlink" title="等待进入阻塞队列"></a>等待进入阻塞队列</h2><p>await方法中，在释放了锁之后会进入下面的代码块中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果节点不在阻塞队列中</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 那么这个节点将会被挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列中了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在节点入条件队列的时候，初始化时设置了waitStatus = Node.CONDITION</span></span><br><span class="line"><span class="comment">// 调用signal的时候，需要将节点从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="comment">// 这个方法用于判断node节点是否已经在阻塞队列中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在从条件队列移动到阻塞队列的时候，waitStatus会置0</span></span><br><span class="line">    <span class="comment">// 如果这个时候node.waitStatus还是-2的话，说明并没有转移到阻塞队列中</span></span><br><span class="line">    <span class="comment">// 如果node的前驱prev指向还是null，说明肯定没有在阻塞队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果node有了后置节点，说明一定在阻塞队列中了。</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 下面这个方法从阻塞队列的队尾开始从后往前遍历，如果找到相等的，说明在阻塞队列中，否则就不在</span></span><br><span class="line">    <span class="comment">// 不能通过判断node.prev != null 来推断出node在阻塞队列中</span></span><br><span class="line">    <span class="comment">// 在入阻塞队列的时候，是先将node.prev 指向tail</span></span><br><span class="line">    <span class="comment">// 然后是CAS将自己设置为新的tail，这次的CAS是可能失败的。</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>isOnSyncQueue(node)如果返回false，那么就会进入到LockSupport(this)，将当前线程挂起。</p><h2 id="signal-唤醒线程，转移到阻塞队列"><a href="#signal-唤醒线程，转移到阻塞队列" class="headerlink" title="signal 唤醒线程，转移到阻塞队列"></a>signal 唤醒线程，转移到阻塞队列</h2><p>唤醒操作通常由另外一个线程来操作，就像在消费者和生产者模型中，如果线程因为等待消费而被挂起，那么当生产者生产了一个东西之后，就会调用signal来唤醒消费线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒了等待最久的线程</span></span><br><span class="line"><span class="comment">// 这里的唤醒其实就是将条件队列中对应的node转移到阻塞队列中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用signal的线程必须持有独占锁。</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从条件队列从头往后遍历，找出第一个需要转移的node</span></span><br><span class="line"><span class="comment">// 因为线程有可能会取消排队，但可能还会在队列中。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// firstWaiter指向first节点的下一个节点，因为firstWaiter将要离开了</span></span><br><span class="line">        <span class="comment">// 如果将first移除之后，没有节点在等待了。那么就要将lastWaiter置为null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// first节点马上要去阻塞队列了，那么就要把条件队列的连接关系断了</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">            (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// while循环，如果first转移不成功，那么就找下一个节点，以此类推</span></span><br><span class="line">    <span class="comment">// 直到找到能够转移的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点从条件队列转移到阻塞队列中</span></span><br><span class="line"><span class="comment">// true表示成功</span></span><br><span class="line"><span class="comment">// false表示在signal之前，已经取消了排队。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里如果cas失败了，说明此node的waitStatus已经不是Node.CONDITION,已经取消了排队</span></span><br><span class="line">    <span class="comment">// 在条件队列里已经取消了排队，则也就不需要转移了。返回false，移向后一个节点</span></span><br><span class="line">    <span class="comment">// 如果cas成功，则将ws设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// enq(node):自旋进入阻塞队列的队尾</span></span><br><span class="line">    <span class="comment">// 这里的返回值p是node在阻塞队列的前驱节点。</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// ws &gt; 0 说明node在阻塞队列中的前驱节点取消了等待锁，直接唤醒node对应的线程</span></span><br><span class="line">    <span class="comment">// 如果ws &lt;= 0 那么compareAndSetWaitStatus将会被调用</span></span><br><span class="line">    <span class="comment">// 在上篇中说过当节点入队之后需要将前驱节点设置为Node.SIGNAL(-1)</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果前驱节点取消或者设置失败，就会唤醒node对应线程。</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说<code>ws &gt; 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL)</code>中，ws &lt;= 0,而且!p.compareAndSetWaitStatus(ws, Node.SIGNAL) 会返回true，所以一般也不会进入if语句块中唤醒node对应的线程。然后这个方法返回true，也就意味着signal这个方法结束了，节点进入阻塞队列。</p><p>假设发生了阻塞队列中的前驱节点取消等待，或者CAS失败，只要唤醒线程，让他进入到下一步即可。</p><h2 id="唤醒后检查中断状态"><a href="#唤醒后检查中断状态" class="headerlink" title="唤醒后检查中断状态"></a>唤醒后检查中断状态</h2><p>在signal之后，线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到了锁以后，继续往下执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interruptMode 可以取值为REINTERRUPT(1), THROW_IS(-1), 0</p><ul><li>REINTERRUPT: 代表await返回的时候，需要重新设置中断状态</li><li>THROW_IE: 代表await返回的时候，需要抛出InterruptException异常</li><li>0: 说明await期间，没有发生中断</li></ul><p>有三种情况会让LockSupport.park(this)这句话返回继续往下执行：</p><ul><li>常规路径：signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁(unpark)</li><li>线程中断。在park的时候，另外一个线程对这个线程进行了中断</li><li>signal的时候，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li><li>假唤醒。 和Object.wait()类似，都存在的问题。</li></ul><p>线程唤醒之后第一步是调用checkInterruptWhileWaiting(node)这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生中断，是signal调用之前中断的，还是signal之后发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如果是在signal之前已经中断，返回THROW_IE</span></span><br><span class="line"><span class="comment">// 2. 如果是signal之后中断，返回REINTERRUPT</span></span><br><span class="line"><span class="comment">// 3. 没有发生中断则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Thread.interrupted() 方法返回true，则说明已经被中断，需要重新设置中断设置</p><p>如何判断中断发生在signal之前还是之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有线程处于中断状态，才会调用此方法</span></span><br><span class="line"><span class="comment">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列中</span></span><br><span class="line"><span class="comment">// 如果该线程在signal之前中断，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用cas将节点设置为0</span></span><br><span class="line">    <span class="comment">// 如果这步成功了，说明节点是在signal被中断的</span></span><br><span class="line">    <span class="comment">// 因为如果在signal之后发生的话，signal方法中会将waitStatus设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 到这里说明cas成功，则将节点放入阻塞队列中</span></span><br><span class="line">        <span class="comment">// 运行这步说明即便是中断了，节点还是会被转移到阻塞队列中</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明cas失败了，因为signal方法将waitStatus设置为了0</span></span><br><span class="line">    <span class="comment">// signal方法会将节点转移到阻塞队列中，但是可能还没完成，这边自旋等待其完成</span></span><br><span class="line">    <span class="comment">// 发生signal调用之后，没完成转移之前发生了中断。这种情况还是比较少的。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里描绘了一个场景，本来有个线程在条件队列排队，但是因为被中断了，那么他会被唤醒。然后突然发现自己不是被signal(唤醒)的那个，但是他会自己主动加入到阻塞队列。</p><h2 id="获取独占锁"><a href="#获取独占锁" class="headerlink" title="获取独占锁"></a>获取独占锁</h2><p>while循环出来以后，是下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// await中的代码</span></span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != Throw_IE) &#123;</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从while循环出来之后，我们已经确定节点在阻塞队列中，准备获取锁</p><p>这里的acquireQueued(node, savedState)的第一个参数node之前经过enq(node)进入队列，参数savedState是之前释放锁前的state，则个方法返回的时候，代表线程已经获取了锁，而且state == savedState</p><p>注意，在前面说过不管是否发生中断，都会进入阻塞队列中，而acquireQueued(node, savedState)的返回值就是代表线程是否被中断。如果返回true，说明被中断了，而且interruptMode != THROW_IE，说明在signal之前就发生中断了，这里将interruptMode设置为REINTERRUPT，用于待会重新中断。</p><p>继续执行的话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure><p>这里的<code>node.nextWaiter != null</code> 是怎么满足的。在进行signal的时候，会将节点转移到阻塞队列中。有一步是node.nextWaiter = null，将断开节点和条件队列的联系</p><p>可是，在<code>判断中断发生的时机中，会判断是signal执行前还是执行后</code>，如果signal之前就发生中断了，虽然节点会转移到阻塞队列中，但是并不会切断条件队列中的连接。也就是没有将node.nextWaiter设置为null。</p><p>还有如果节点取消，也会调用unlinkCancelledWaiter这个方法。</p><h2 id="处理中断状态"><a href="#处理中断状态" class="headerlink" title="处理中断状态"></a>处理中断状态</h2><p>现在可以说说interruptMode是干啥用的了</p><ul><li>0：啥也不做，没有被中断过</li><li>THROW_IE: await方法抛出InterruptedException异常，因为他代表了在await期间发生过中断</li><li>REINTERRUPT: 重新中断当前线程，因为它代表了虽然await期间没有被中断过，但是在signal以后发生了中断。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AbstractQueuedSynchronizer独占锁的取消排队"><a href="#AbstractQueuedSynchronizer独占锁的取消排队" class="headerlink" title="AbstractQueuedSynchronizer独占锁的取消排队"></a>AbstractQueuedSynchronizer独占锁的取消排队</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这个方法的时候，节点一定是入队成功的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某个线程调用lock()一直不返回，我们需要中断它。一旦对其中断，此线程会从<code>LockSupport.park(this)</code>中被唤醒，然后Thread.interrupt()返回true。</p><p>即便是中断唤醒了这个线程，也就只是设置了<code>interrupted = true</code>然后继续下一次循环。而且，由于<code>Thread.interrupted();</code>会清除中断状态，第二次进parkAndCheckInterrupt的时候，返回会是false。</p><p>所以，在这个方法中，interrupt只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情。</p><p>外层方法处理acquireQueued返回false的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，可以知道lock()处理中断的方式是，中断归中断，锁还是要照样抢的，几乎没有关系(<code>interrupt = true 但是没有返回true状态，继续循环</code>)，只是在抢到锁之后，设置线程的中断状态而已，也不抛出任何异常。调用者获取锁之后，可以去检查是否发生了中断，也可以不理会(好流氓….)。</p><p>现在来看看ReentrantLock的另外一个lock方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法多了一个 <code>throws InterruptedException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span></span><br><span class="line">                <span class="comment">// 这里不再只是标记这个方法的返回值代表中断状态</span></span><br><span class="line">                <span class="comment">// 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 找一个合适的前驱。其实就是将它前面的队列中已经取消的节点都”请出去“</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java线程中断和InterruptedException异常"><a href="#Java线程中断和InterruptedException异常" class="headerlink" title="Java线程中断和InterruptedException异常"></a>Java线程中断和InterruptedException异常</h1><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>这里的中断不是类似于linux中的命令kill -9 pid，不是说我们要中断某个线程，这个线程就停止运行了。中断代表线程状态，每个线程都关联了一个中断状态，是一个true或者false的boolean值，初始值为false。与操作系统中的中断不同，这里更像一个状态。</p><p>关于中断状态，需要重点关注Thread类中的一下几个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 类中的实例方法，持有线程实例引用即可检测线程中的状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread中的静态方法， 检测调用这个方法是否已经被中断</span></span><br><span class="line"><span class="comment">// 注意：这个方法返回中断状态的同时，会将线程的中断状态重置为false</span></span><br><span class="line"><span class="comment">// 所以，如果我们调用两次这个方法的话，第二次的返回值就是false了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread类中的实例方法，用于设置一个线程的中断状态为true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们常说的中断一个线程，其实就是将这个线程的中断状态设置为true。如何使用这个状态则视情况而定。</p><p>如果线程处于下面三种情况，那么线程被中断的时候，就能自动被感知到：</p><ol><li><p>来自Object类的wait()、wait(long)、wait(long, int)，来自Thread类的join()、jon(long)、jon(long, int)</p><p> 这几个方法的相似之处就是，方法上都有：throws interruptedException<br> 如果线程阻塞在这些方法上，这个时候如果其他线程对这个线程进行了中断，那么这个线程就会从这些方法中立即返回，抛出InterruptedException异常，同时重置中断状态为true</p></li><li><p>实现了InterruptibleChannel接口的类中的一些I/O阻塞操作，入DatagramChannel中的connect方法和receive方法</p><p> 如果线程阻塞在这里，中断线程会导致这些方法抛出CloseByInterruptException并重置中断状态</p></li><li><p>Selector中的select方法，一旦中断，方法立即返回</p></li></ol><p>对于上面三种是特殊的，因为他们能自动感知到中断，并且在做出相应操作之后都会重置中断状态为false。</p><p>但是不只是上面三种状态能自动感知到中断，如果线程阻塞在LockSupport.park(Object obj)方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒之后不会重置中断状态，所以唤醒之后去检测中断状态将是true。</p><h2 id="InterruptedException概述"><a href="#InterruptedException概述" class="headerlink" title="InterruptedException概述"></a>InterruptedException概述</h2><p>这是一个特殊的异常，不是jvm对其有特殊的处理，而是使用场景比较特殊。通常，可以看到，像Object中的wait()方法，ReentrantLock中的lockInterruptibly()方法，thread中的sleep()方法等等，这些方法都带有<code>throws InterruptedException</code>，我们通常称这些方法为阻塞方法(blocking methos)</p><p>阻塞方法有一个明显的特征就是，他们需要花费特别长的时间(非绝对，而是占用时间是不可预知的)，还有他们的方法结束返回往往依赖于外部条件，如wait方法依赖于其他线程notify，lock方法依赖于其他线程的unlock等等。</p><p>当我们看到方法上带有<code>throws InterruptedException</code>时，我们大概就能知道，这个方法应该是阻塞方法，如果我们希望它能提前返回的话，可以通过中断来实现</p><p>除了几个特殊的类（Object、Thread等）之外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做出相应的操作。我们也要知道，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能感知到线程中断了。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2" target="_blank" rel="noopener">一行一行源码分析清楚AQS</a></p><p><img src="https://brandonxcc.top/20200510.jpg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看了上篇的描述之后，我觉得我应该已经对AQS的大概运行过程有了一个初步的了解，当然这远远不够。快扶我起来，我还能继续学！&lt;br&gt;这篇将继续写
      
    
    </summary>
    
      <category term="Java" scheme="https://1234zhang.github.io/categories/Java/"/>
    
      <category term="JUC" scheme="https://1234zhang.github.io/categories/Java/JUC/"/>
    
    
      <category term="java并发" scheme="https://1234zhang.github.io/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码解析(一)</title>
    <link href="https://1234zhang.github.io/2020/04/19/J.U.C/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80/"/>
    <id>https://1234zhang.github.io/2020/04/19/J.U.C/AQS源码解析-一/</id>
    <published>2020-04-19T08:26:56.000Z</published>
    <updated>2020-06-24T06:11:10.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开始拜读Doug Lea大神的并发源码了，作为一个小菜鸡，可能理解不了太多这里面的一些编程思想，只希望能了解一个大概过程，在平时使用或者解决问题的时候有一个清晰的思路去分析问题的原因然后去解决这个问题。</p><p>AbstractQueueSynchronizer(简称AQS)这个抽象类，是实现ReentrantLock、CountDownlatch、Semaphore、FutureTask等类的基础。</p><p>站在使用者的角度，AQS的功能主要分为两大类：独占锁和共享锁。在他的所有子类中，要么实现并使用了它独占锁的API，要么使用了共享锁的API，而不会同时使用两种API。即便是ReentrantReadWriteLock，也是通过两个内部类，读锁和写锁，分别实现了两套API来实现这两个功能。</p><h1 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h1><p>AQS的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点，当前持有锁的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞尾节点，每个新的节点进来，都插入到最后，就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前锁的状态，0表示没有被占用，大于0代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于1，因为锁可以重入，每次重入都要加上1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，使用例子(因为锁是可以重入的)</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有的锁</span></span><br><span class="line"><span class="comment">// if(currentThreed == getExclusiveOwnerThread()) &#123;state++;&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">// 继承自AbstractOwnableSynchronizer</span></span><br><span class="line"><span class="comment">// 同时这个变量没有被volatile关键字修饰，因为这个变量只要自己能看到就可以了。</span></span><br></pre></td></tr></table></figure><h2 id="Node结构-双向链表"><a href="#Node结构-双向链表" class="headerlink" title="Node结构(双向链表)"></a>Node结构(双向链表)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="comment">// 表示当前节点是在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 表示当前节点是在独占模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下的常量是给waitState使用状态</span></span><br><span class="line">    <span class="comment">// 表示线程取消了等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示下一个节点是通过park阻塞的，需要通过unpark唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示线程在等待条件变量(先获取锁，加入到条件等待队列，然后释放锁，等待条件变量满足条件；只有重新获得锁之后才能返回)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示后续节点会传播唤醒操作，共享模式下起作用。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态，对于condition节点，初始化为CONDITION；其他默认为0，通过cas设置</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有了node结构的概念之后，我们再回头看看AQS的等待队列示意图<br><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-3.png" alt="aqs"></p><h2 id="AQS的模板方法以及介绍"><a href="#AQS的模板方法以及介绍" class="headerlink" title="AQS的模板方法以及介绍"></a>AQS的模板方法以及介绍</h2><ol><li>isHeldExclusively(): 判断该线程是否正在独占线程。只有用到condition才需要去实现他</li><li>tryAcquire(int): 独占的方式。尝试获取资源，成功则返回true，失败则放回false</li><li>tryRelease(int): 独占方式。尝试释放资源，成功返回true，失败返回false</li><li>tryAcquireShared(int): 共享方式。尝试获取资源，负数表示失败。0 表示成功，但是没有资源可以被申请；正数表示成功，而且有资源能够被获取。</li><li>tryReleaseShared(int): 共享的方式。尝试释放资源，成功返回true，失败返回false。</li></ol><p>以上就是AQS给子类提供的模板方法，给子类实现自定义的同步器。</p><h2 id="争锁操作"><a href="#争锁操作" class="headerlink" title="争锁操作"></a>争锁操作</h2><p>通过ReentrantLock来看看AQS是如何实现的。ReentrantLock内部使用了一个内部类Sync来管理锁，所以真正的获取锁和释放锁是由Sync来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 同时还有两个继承类，用来分别实现了公平锁与非公平锁、</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ReentrantLock</span>(<span class="title">boolean</span> <span class="title">fair</span>) </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; <span class="comment">// 争锁</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面是父类AQS中的Acquire实现</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果tryAcquire(arg) 返回true，则获取资源成功，便使用锁资源进行下一步操作</span></span><br><span class="line"><span class="comment">            如果返回false，acquireQueue方法将线程压到队列中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// 此时的arg == 1</span></span><br><span class="line">             <span class="comment">// 首先使用tryAcquire(1)，可能直接成功，就不需要进入阻塞队列</span></span><br><span class="line">             </span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果获取失败，就会将当前线程挂起，然后进入阻塞队列。</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@ReservedStackAccess</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">// 获取当前资源锁的状态，如果为0 此时此刻没有线程持有该锁</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">// 如果没有上锁，则尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 此时该锁是可以用的，但是公平锁就是讲究一个公平，他要查看阻塞队列中没有老哥一直等着的，如果有，他也会老老实实去排队</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    <span class="comment">// 如果没有人排队，就使用cas试一下，如果能成功</span></span><br><span class="line">                    <span class="comment">// 就直接获取该锁资源</span></span><br><span class="line">                    <span class="comment">// 如果不成功，说明有锁在跟我同时在获取这个资源。</span></span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    <span class="comment">// 获取到锁资源之后，要进行标记，告诉大家我获得这个锁了</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断已经加锁的线程是本线程，则重入锁。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到这里，说明没有获取到锁，则要进入到阻塞队列中排队。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>加入到阻塞队列中addWaiter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发现jdk9与jdk8有一些改变，但思想是没变的。</span></span><br><span class="line"><span class="comment">// jdk9改成使用VarHandle来新建节点，以及修改tail节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取老的尾节点</span></span><br><span class="line">            Node oldTail = tail;</span><br><span class="line">            <span class="comment">// 如果tail不是空的话，新建node节点的前驱指针指向oldTail，反之初始化阻塞队列</span></span><br><span class="line">            <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置 新建节点的前驱指针指向tail</span></span><br><span class="line">                node.setPrevRelaxed(oldTail);</span><br><span class="line">                <span class="comment">// 使用cas把自己设置为队尾，如果成功，tail == node，这个新建节点成为新尾巴</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                    <span class="comment">// 上面已经有了node.setPrevRelaxed(oldTail);，</span></span><br><span class="line">                    <span class="comment">// 加上下面这句，就实现了和之前的尾节点的挂钩的双向连接了。</span></span><br><span class="line">                    oldTail.next = node;</span><br><span class="line">                    <span class="comment">// 新建节点入队列，然后返回这个节点。</span></span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果原来队列没有元素，就要初始化这个队列。</span></span><br><span class="line">                initializeSyncQueue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面进入初始化队列</span></span><br><span class="line">    <span class="comment">// 只有队列为空的时候，才会运行这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node h;</span><br><span class="line">        <span class="keyword">if</span> (HEAD.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</span><br><span class="line">            tail = h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在再来回顾一下，当线程没有抢到锁资源的时候发生了什么<br>    // if (!tryAcquire(arg)<br>    //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>    //     selfInterrupt();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接下来就要接着谈谈acqireQueue 这个方法</span></span><br><span class="line"><span class="comment">// 下面这个方法很重要，在经过addWaiter(Node.EXCLUSIVE)，此时线程已经进入阻塞队列中</span></span><br><span class="line"><span class="comment">// 如果acquireQueued返回true的话，意味着将要执行selfInterrupt()这个方法。</span></span><br><span class="line"><span class="comment">// 所以acquireQueued这个方法很重要，线程的挂起以及被唤醒之后去获取锁，都在这个方法中。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                p == head 说明当前节点虽然进到了阻塞队列中，但是是阻塞队列中的第一个，因为他的前驱节点是head。</span></span><br><span class="line"><span class="comment">                注意， 阻塞队列不包含head节点，head一般是指的占有锁的进程，head后面的才是阻塞队列</span></span><br><span class="line"><span class="comment">                首先 head是队列头，其次head有可能是刚刚初始化的node。</span></span><br><span class="line"><span class="comment">                head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class="line"><span class="comment">                也就是说，当前的head可能不属于任何线程，所以作为阻塞队列的队头，可以尝试去获取锁资源</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果到这里，说明if分支没有成功，有两个原因</span></span><br><span class="line">            <span class="comment">// 1. 可能node本来就不是队头</span></span><br><span class="line">            <span class="comment">// 2. tryAcquire没有抢赢别人。</span></span><br><span class="line">            <span class="comment">// 下面两个判断如果都为true了，该线程就要被挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 在tryAcquire抛出异常的时候，这个线程就会放弃争夺锁资源。</span></span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正如前文，会运行这个方法。</span></span><br><span class="line"><span class="comment">// 该方法表达的是"当前线程没有抢到锁，是否要挂起当前线程"</span></span><br><span class="line"><span class="comment">// 第一个参数是前驱节点，第二个参数才是当前节点。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">// 获取前驱节点的等待状态</span></span><br><span class="line">    <span class="comment">// 如果前驱节点是-1，则说明节点正常，可以挂起当前线程，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 前驱节点waitStatus大于0，说明前驱节点取消了排队</span></span><br><span class="line">    <span class="comment">// 在这里要注意的是，进入阻塞队列的线程都会被挂起，只能依靠前驱节点唤醒。</span></span><br><span class="line">    <span class="comment">// 所以下面的循环就是将当前节点的prev指向一个waitStatus&lt;=0的节点</span></span><br><span class="line">    <span class="comment">// 这里要找到前面的waitStatus&lt;=0的节点。才能保证能够唤醒当前节点。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 走到这里说明前驱节点不为-1和1，只能是0或者-2，-3</span></span><br><span class="line"><span class="comment">         * 一路走来都没有看到设置waitStatus的地方。</span></span><br><span class="line"><span class="comment">         * 原本的tail的waitStatus是0，突然新来了一个节点之后，还没改变</span></span><br><span class="line"><span class="comment">         * 自己的waitStatus。在下面使用cas将prev的waitStatus设置为-1</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个方法返回false，就会再走一遍上面的for循环，</span></span><br><span class="line">    <span class="comment">// 再进来该方法，然后返回true。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node);</p><p>这个方法的返回值进行分析：<br>如果这个方法返回的是true，那么就说明当前线程会被挂起，等待前驱节点获取到锁之后来唤醒你。</p><p>再来看看调用方法的这个地方<code>if(shouldParkAfterAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interupted = true;</code></p><ol><li>如果shouldParkAfterAcquire返回了true，那么就会进入下一个方法parkAndCheckInterrupt()，这个方法会挂起线程。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里使用了LockSupport.park(this);</span></span><br><span class="line">    <span class="comment">// 用来挂起线程，等待被唤醒。</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>如果返回了false，会进行一次for循环。其实在第一次进入shouldParkAfterAcquire这个方法的时候，一定会返回false，具体原因如上。这里还有提供了一个获取锁的机会，万一第二次循环的时候获取到锁了，那么就不用被挂起了。直接进行下一步的处理。</li></ol><h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>正常情况下，如果线程没有获取到锁，就会被<code>LockSupport.park(this);</code>挂起，等待被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前线程开始请求释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否可以释放锁了</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// head是当前持有锁的节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果head为空了，说明队列里面没有阻塞节点，也不用去唤醒了。</span></span><br><span class="line">        <span class="comment">// waitState == 0，根据加锁的代码可以知道，这个是后续节点设置的。</span></span><br><span class="line">        <span class="comment">// 如果waitSate == 0，则后面也没有需要唤醒的节点。</span></span><br><span class="line">        <span class="comment">// 如果都不满足，说明队列中还有节点需要被唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后续节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="comment">// 锁释放成功。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 判断当前线程是否是锁的拥有线程</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 是否完全释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 这里其实是一个重入锁的概念，判断还有没有嵌套锁，如果没有了，就释放完全了</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒后续节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 记住，这里的node 是head</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 首先设置head的waitState为0</span></span><br><span class="line">        node.compareAndSetWaitStatus(ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 然后找到head的后继节点 B</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果B节点为空，或者取消了等待</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 下面就要从该队列的尾巴部分，开始往前面找，</span></span><br><span class="line">        <span class="comment">// 直到找到最前面的符合条件的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">            <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 在循环里面没有break，说明循环要一直执行下去。</span></span><br><span class="line">                s = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒这个节点，开始争夺锁</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么要从尾部往前面找符合条件的节点,要关注一下下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//1. 维护 node 前驱节点</span></span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="comment">//2. 使用 CAS 将节点设置为队列尾节点</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               <span class="comment">//3. 维护 pred 的后继节点</span></span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如上面代码所说的，首先设置了前驱节点<code>node.pre = pred</code>,然后使用CAS入队，注意这里可能还没有入队，则就没有办法执行<code>pred.next = node</code>，这个时候如果是前面往后面开始找的话，就有可能发生找不到节点的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒线程之后，被唤醒的线程将从下面的代码继续往前走</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 刚刚线程被挂起在这里了</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在并发的条件下，需要以下三个部件的协调</p><ol><li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li><li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li><li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS采用了CLH锁的变体来实现。</li></ol><p><img src="https://brandonxcc.top/20200422.jpg" alt="avatar"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/pfnie/article/details/53191892" target="_blank" rel="noopener">AQS功能分析</a></p><p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">ReentrantLock公平锁的角度去分析AQS</a></p><p><a href="https://www.jianshu.com/p/c244abd588a8" target="_blank" rel="noopener">AQS源码分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;开始拜读Doug Lea大神的并发源码了，作为一个小菜鸡，可能理解不了太多这里面的一些编程思想，只希望能了解一个大概过程，在平时使用或者解决
      
    
    </summary>
    
      <category term="Java" scheme="https://1234zhang.github.io/categories/Java/"/>
    
      <category term="JUC" scheme="https://1234zhang.github.io/categories/Java/JUC/"/>
    
    
      <category term="java并发" scheme="https://1234zhang.github.io/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>集合源码之HashMap</title>
    <link href="https://1234zhang.github.io/2020/04/18/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E4%B9%8BHashMap/"/>
    <id>https://1234zhang.github.io/2020/04/18/集合框架源码/集合源码之HashMap/</id>
    <published>2020-04-18T07:21:10.000Z</published>
    <updated>2020-06-06T10:25:07.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>同样作为Java集合框架中使用频率最多的数据结构之一，hashmap的地位可谓是相当的高。在面试中出现的频率也是相当的高，所以这篇重在讨论hashmap相关的源码。同时对比jdk7与jdk8的实现有什么异同。</p><h1 id="jdk7的实现"><a href="#jdk7的实现" class="headerlink" title="jdk7的实现"></a>jdk7的实现</h1><p>jdk7中的结构如下图：<br><img src="https://brandonxcc.top/jdk7%E7%9A%84hashmap.png" alt="avatar"><br>大方向上，hashmap里面是一个数组，然后数组中的元素是一个单向链表，用于解决hash冲突。</p><p>链表元素是一个实体类Entry，这个类主要包含四个属性(K值，Value值，指向下一个节点的位置，hash值)</p><p>capacity: 当前数组的容量，始终保持2^n，可以扩容，扩容后的大小是现数组容量的两倍</p><p>loadFacto: 负载因子，默认为0.75</p><p>threshold：阈值，等于loadFactor * capacity；</p><h2 id="put过程"><a href="#put过程" class="headerlink" title="put过程"></a>put过程</h2><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果数组为空，首先初始化数组</span></span><br><span class="line">    <span class="keyword">if</span>(table == EMPTY_TABLE)&#123;</span><br><span class="line">        inflateTable(threshold)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果key为null， 则调用putForNullKey()这个方法，将entry放到table[0]中。</span></span><br><span class="line">    <span class="keyword">if</span>(key == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2.找到对应的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 3. 遍历一下对应下标处的链表，查看是否有重复的key值，如果有则直接覆盖，put方法返回旧值</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K, V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next)&#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))&#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 4. 不存在重复的key值，将此entry加入到对应数组下标的链表中</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><p>在第一个元素插入HashMap的时候做一次数组的初始化，就是先确定初始数组的大小，并计算数组扩容的阈值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是2的n次方</span></span><br><span class="line">    <span class="comment">// 比如new HashMap(20),那么这个数组的大小则是32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值： capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">// 初始化hash种子，如果在需要的情况下。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里有一个疑问：为什么hashmap要将数组大小保证为2的N次方</strong><br>在计算Entry数组下标的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的h是 <code>int hash = hash(key.hashCode())</code>，也就是根据key的hashCode再进行一次hash计算出来的，length是Entry数组的长度。</p><p>一般我们利用hash计算一个数组的索引的时候，常用的方式是<code>h % length</code>，也就是求余数的方式，但是效率并不高。SUN的大师们经过实验发现，当容量在2的次方的时候，<code>h&amp;(length - 1) == h % length</code>按位运算特别快。</p><h3 id="计算数组的具体位置"><a href="#计算数组的具体位置" class="headerlink" title="计算数组的具体位置"></a>计算数组的具体位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> hash &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取hash值的低n位，作为数组下标的位置。</p><h3 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h3><p>找到数组下标之后，会先进行key判重，如果没有重复，就准备将新值放入到链表的表头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前的HashMap大小已经达到了阈值，并且新值要插入的数组位置已经有了元素，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span>((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex]))&#123;</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 扩容之后重新计算hash值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重新计算扩容后的下标值</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新的值放到链表的头部，然后size++</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加节点的主要逻辑是：先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据加入到扩容后的数组的相应位置处的链表的表头</p><h3 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h3><p>在插入新值的时候，如果当前的size已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容之后，数组大小为原来的2倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span>(oldCapacity == MAXIMUM_CAPACITY)&#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将原来数组中的值迁移到新的更大的数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容就是用一个新的大的数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。<br>由于是双倍扩容，迁移过程中，会将原来table[i]中的链表的所有节点，分拆到新数组的newTable[i]和newTable[i + oldLength]位置上。</p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>相对于put过程，get的过程更加简单</p><ul><li>根据key计算hash值</li><li>找到相应的数组下标：hash &amp; (length - 1)</li><li>遍历该数组位置处的链表，直到找到相等的key<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果key为null的话，就会被放到table[0]中，所以只要遍历table[0]处的链表就可以</span></span><br><span class="line">    <span class="keyword">if</span>(key == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K, V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e.next)&#123;</span><br><span class="line">        Object K;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || (key !+ <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="jdk8的实现"><a href="#jdk8的实现" class="headerlink" title="jdk8的实现"></a>jdk8的实现</h1><p>jdk8对HashMap进行了一些修改，最大的不同就是引入了红黑树，所以其由<code>数组+链表+红黑树</code>组成</p><p>下面是jdk8的hashmap的结构：<br><img src="https://brandonxcc.top/jdk8%E7%9A%84hashmap.png" alt="avatar"></p><h1 id="jdk8-hashmap的一些简介"><a href="#jdk8-hashmap的一些简介" class="headerlink" title="jdk8 hashmap的一些简介"></a>jdk8 hashmap的一些简介</h1><p>hashmap通常是采用桶装的hashtable即是使用数组加链表的方式，当链表中的元素过多的时候，就会将链表转换为红黑树。红黑树能够提供更快的查找方式，将时间复杂度从O(n) 降低到O(logn)。</p><p>hashmap中两个重要的参数Capacity和loadFactor。初始的桶大小和负载因子。负载因子是hash table允许扩容的大小(阈值, 一般是2的n次幂)。当数组中的元素个数大于了阈值之后，就会进行扩容，并rehash。<br><strong>为什么负载因子是0.75</strong><br>0.75很好的维持了时间与空间的平衡。太小了浪费空间，会造成频繁的resize()扩容操作，但是太大了hash冲突增加导致性能下降。</p><p><strong>为什么链表的长度大于等于8的时候链表会转换为红黑树</strong><br>根据泊松分布方程式： (exp(-0.5) * pow(0.5, k)/factorial(k))。在阈值为0.75的情况下，泊松分布概率函数中的参数λ=0.5。泊松分布用来估算在一段特定时间或者特定空间内发生成功事件的概率，即是长度为length的数组中放入hash地放入0.75*length数量的数据，数组中某一个下标放入k个数据的概率。</p><p>虽然引入TreeNode能够有效的提高hashmap的增删改查的性能，但是节点大小是链表节点的两倍。根据泊松分布考虑，每个节点大小为8的概率为0.00000006，千万分支一还小，这样的开销是值得的。</p><p><strong>当一棵红黑树的节点数小于等于6的时候会从红黑树转换为链表</strong><br>避免在一个节点为8的位置上频繁删除然后增加情况下，频繁的树转换和链表相互转换。</p><p><strong>最小树化容量</strong><br>如果entry的数组大小大于等于64的时候，就会被树化。64的原因是避免在扩容与树化之间产生冲突。</p><h1 id="put的过程"><a href="#put的过程" class="headerlink" title="put的过程"></a>put的过程</h1><h2 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h2><p>所有的put方法都会调用这个私有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> key key值</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> value put的值</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> onlyIfAbsent if true 只有在key不存在的时候才能进行put操作</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> evict if false 这个数组处于建造模式(the table is in creation mode) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 首次put的时候，会初始化数组的长度</span></span><br><span class="line">    <span class="comment">// 但是在jdk8中，首次扩容与后续扩容有些不一样，因为这次是数组从null初始化到默认的16或者自定义的初始值。</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 找到具体的数组下标，如果这个位置没有值，那么直接初始化一下，Node并放置在这个位置。</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这个位置有值</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 判断这个位置的key和要存入的key值是不是相等，如果是则取出这个值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">            <span class="comment">// 如果该节点是红黑树的节点，调用红黑树的插入方法。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里说明是链表的节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// jdk8中使用尾插法 </span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果新插入的值是链表的第八个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的方法，也就是将链表转为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果该链表找到了相等的key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">//此时break，那么e为链表中[与要插入的新值的key相等]的node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e != null 说明新插入的key在原来链表中已经存在</span></span><br><span class="line">        <span class="comment">// 下面就是进行值覆盖，然后返回旧的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录这个操作。</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果这个插入操作之后，超过了阈值，则要进行扩容操作。</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk7与jdk8的不一样的地方就是，Java7是先扩容再插入，Java8是先插入再扩容。</p><h2 id="数组扩容-1"><a href="#数组扩容-1" class="headerlink" title="数组扩容"></a>数组扩容</h2><p>resize() 方法用于初始化数组或者数组扩容，每次扩容之后，容量就要变成原来的两倍，并进行数据迁移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 原数组已经被初始化过</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果原来数组的长度大于最大容量，则将阈值扩大到最大</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将长度扩大到原来的两倍，而且小于极限长度，而且原来长度大于最小长度</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                     <span class="comment">// 将阈值扩大到原来的两倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对应使用new HashMap(int initialCapacity)初始化之后。</span></span><br><span class="line">        <span class="comment">// 使用这个构造方法，只会初始化阈值，不会初始化长度</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 对应使用 new HashMap()之后，第一次put</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        <span class="comment">// 用新数组大小初始化新数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">            <span class="comment">// 如果是第一次put，即是没有老数组，则这里就直接返回了，不会进行数据的迁移</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">// 下面开始老数组的数据迁移</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 如果该位置上只有一个链表只有一个元素，那么直接计算hash位置，然后复制就可以。</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                        <span class="comment">// 如果该位置上是一颗红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 下面要进行链表的拆分</span></span><br><span class="line">                    <span class="comment">// 拆分成两个链表，放到新数组中，并且要保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// lo前缀的对应一条链表，hi前缀的对应另外一条链表</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 如果扩容之后还在原来位置，则添加到第一条链表的尾部</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; </span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果扩容之后不在原来位置，而是移动了2次幂的位置，则添加到第二条链表的尾部</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>); <span class="comment">// 遍历这条链表</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 原索引放到bucket</span></span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 原索引+oldCap放到bucket处</span></span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>元素在重新计算了hash之后，因为n变成了2倍，那么n - 1的mask范围在高位多1bit，因此index位置就会发生变化。</p><h2 id="get过程分析"><a href="#get过程分析" class="headerlink" title="get过程分析"></a>get过程分析</h2><ol><li>计算key的hash值，根据hash值找到对应数组的下标</li><li>判断数组位置处的元素是否是我们要找的元素，如果不是继续</li><li>判断该元素的类型是否是TreeNode，如果是，用红黑树的方式获取数据</li><li>如果不是红黑树，遍历链表找到相等的key<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树与AVL树的区别"><a href="#红黑树与AVL树的区别" class="headerlink" title="红黑树与AVL树的区别"></a>红黑树与AVL树的区别</h2>AVL树比红黑树保持更加严格的平衡，AVL树从树根到最深的的路径最多为1.44lg(n + 2)，而在红黑树中最多为2lg(n + 1), 越深说明花费的时间越多。从这里可以看出AVL树的查找效率更高。但是这是以更多的旋转导致的更慢的插入和删除操作为代价的。因此如果希望查找更多，则使用AVL树<br>而红黑树更加通用，在添加、删除和查找方面有更好的表现。AVL树查找更快，代价是删除和添加速度较慢。</li></ol><h2 id="参考文章连接"><a href="#参考文章连接" class="headerlink" title="参考文章连接"></a>参考文章连接</h2><ol><li><a href="https://blog.csdn.net/qq_27093465/article/details/52270519" target="_blank" rel="noopener">resize之后的rehash</a></li><li><a href="https://www.javadoop.com/post/hashmap" target="_blank" rel="noopener">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a></li><li><a href="https://blog.csdn.net/reliveIT/article/details/82960063" target="_blank" rel="noopener">为什么负载因子是0.75，以及为什么链表转红黑树的阈值是8</a></li><li><a href="https://blog.csdn.net/sybnfkn040601/article/details/73194613" target="_blank" rel="noopener">为什么初始化长度是2的n次方</a></li><li><a href="https://blog.csdn.net/21aspnet/article/details/88939297" target="_blank" rel="noopener">为什么使用红黑树而不使用AVL树</a></li></ol><p><img src="https://brandonxcc.top/20200418.jpg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;同样作为Java集合框架中使用频率最多的数据结构之一，hashmap的地位可谓是相当的高。在面试中出现的频率也是相当的高，所以这篇重在讨论h
      
    
    </summary>
    
      <category term="Java" scheme="https://1234zhang.github.io/categories/Java/"/>
    
      <category term="集合框架" scheme="https://1234zhang.github.io/categories/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
      <category term="HashMap" scheme="https://1234zhang.github.io/categories/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/HashMap/"/>
    
    
      <category term="Java集合" scheme="https://1234zhang.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>AOP原理</title>
    <link href="https://1234zhang.github.io/2020/04/12/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/AOP%E5%8E%9F%E7%90%86/"/>
    <id>https://1234zhang.github.io/2020/04/12/spring源码解读/AOP原理/</id>
    <published>2020-04-12T05:59:25.000Z</published>
    <updated>2020-06-06T10:25:07.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AOP的目的"><a href="#AOP的目的" class="headerlink" title="AOP的目的"></a>AOP的目的</h1><p>AOP能够将那些与业务无关，却为业务逻辑共同调用的逻辑或者责任(例如：事务处理，日志管理，权限管理等等)封装起来，便于减少系统的重复代码，降低系统模块的耦合度，并且有利于未来的可拓展性和可维护性。</p><h1 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h1><ol><li><p>导入aop包</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aspects&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义一个业务逻辑实现类；在业务逻辑进行运行的时候，将日志进行打印</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义的一个业务逻辑，计算两数之和。</span></span><br><span class="line">    <span class="keyword">package</span> com.brandon.aop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathMulity</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i + j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个日志切面类，在运行求和运算的时候，在必要的时候进行日志的打印</p></li><li><p>给切面方法加上注解(@Aspect)表示这是一个切面方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.brandon.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspects</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(value = <span class="string">"execution(public int com.brandon.aop.MathMulity.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>) <span class="comment">// 目标方法之前运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算开始"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointCut()"</span>) <span class="comment">// 目标方法之后运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)<span class="comment">// 目标方法正常返回之后运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"returning : &#123;&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pointCut()"</span>)<span class="comment">//目标方法出现异常之后运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exception</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算异常。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/* 环绕通知方法可以包含上面四种通知方法，环绕通知的功能最全面。</span></span><br><span class="line"><span class="comment">     环绕通知需要携带 ProceedingJoinPoint 类型的参数，且环绕通知必须有返回值, 返回值即为目标方法的返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*@Around("pointCut()")</span></span><br><span class="line"><span class="comment">    public Object around(ProceedingJoinPoint pjp)&#123;</span></span><br><span class="line"><span class="comment">        System.out.println("around 方法运行");</span></span><br><span class="line"><span class="comment">        return new Object();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将所有的组件注册到容器中，并且给配置类加上@EnableAspectJAutoProxy 使得aop开启</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAOP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathMulity <span class="title">mulity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathMulity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LogAspects <span class="title">logAspects</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogAspects();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="AOP的原理"><a href="#AOP的原理" class="headerlink" title="AOP的原理"></a>AOP的原理</h1><h2 id="EnableAspectJAutoProxy注解"><a href="#EnableAspectJAutoProxy注解" class="headerlink" title="@EnableAspectJAutoProxy注解"></a>@EnableAspectJAutoProxy注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 注解的实现</span></span><br><span class="line">    <span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Import</span>(&#123;AspectJAutoProxyRegistrar<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAspectJAutoProxy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用@Import(),给容器导入了AspectJAutoProxyRegistrar这个类。</span></span><br><span class="line"><span class="comment">并使用AspectJAutoProxyRegistrar自定义的向容器注册bean</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="使用AspectJAutoProxyRegistar给容器中注册一个什么bean"><a href="#使用AspectJAutoProxyRegistar给容器中注册一个什么bean" class="headerlink" title="使用AspectJAutoProxyRegistar给容器中注册一个什么bean?"></a>使用AspectJAutoProxyRegistar给容器中注册一个什么bean?</h3><p>看到这里我心中有一个疑问，要给容器中注册一个什么bean呢?, 为了解答这个疑问，debug走起！</p><ol><li><p>打断点</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我把断点打到下面的位置，</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 断点打到这里，这里是注册的地方</span></span><br><span class="line">    AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry); </span><br><span class="line">    AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行</p><p> 接下来的步骤主要是来创建一个AnnotationAwareAspectJAutoProxyCreator(注解模式下的AspectJ自动代理创建器)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, (Object)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator<span class="class">.<span class="keyword">class</span>, <span class="title">registry</span>, <span class="title">source</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面进入registerOrEscalateApcAsRequired方法，然后判断registry中是否有AnnotationAwareAspectJAutoProxyCreator，</span></span><br><span class="line"><span class="comment">// 如果没有就进行创建</span></span><br><span class="line"><span class="keyword">if</span> (registry.containsBeanDefinition(<span class="string">"org.springframework.aop.config.internalAutoProxyCreator"</span>))&#123;...&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">        beanDefinition.setSource(source);</span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, -<span class="number">2147483648</span>);</span><br><span class="line">        beanDefinition.setRole(<span class="number">2</span>);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">"org.springframework.aop.config.internalAutoProxyCreator"</span>, beanDefinition);</span><br><span class="line">        <span class="comment">//创建完成之后，返回这个bean定义。</span></span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AnnotationAwareAspectJAutoProxyCreator-有什么用"><a href="#AnnotationAwareAspectJAutoProxyCreator-有什么用" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator 有什么用?"></a>AnnotationAwareAspectJAutoProxyCreator 有什么用?</h3><p>上一步我们知道了要创建一个什么bean，那么现在问题又来了，这个bean有什么用呢。在aop中又扮演着一个什么样的角色呢。<br>下面是AnnotationAwareAspectJAutoProxyCreator的继承关系图<br><img src="https://brandonxcc.top/AnnotationAwareAspectJAutoProxyCreator%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="avatar"><br>根据继承关系图我们可以看出，AnnotationAwareAspectJAutoProxyCreator继承了一些后置处理器，以及自动装配了beanFactory。下面我们debug分析这个的功能。</p></li><li><p>我们debug的断点应该打在哪里</p><p> 在继承关系中，AnnotationAwareAspectJAutoProxyCreator继承了一个AbstractAutoProxyCreator类，这个类还实现了SmartInstantiationAwareBeanPostProcessor。说明这是一个后置处理器。我们先从这个类看，将后置处理器相关的方法(postProcessAfterInitialization、postProcessBeforeInitialization)打上断点，看在初始化前后会发生什么事情。而且这个类还实现了BeanFactoryAware，说明有setBeanFactory()这个是实现BeanFactoryAware接口的。</p><p> 接着进入AbstractAdvisorAutoProxyCreator类中，发现这个类重写了setBeanFactory()方法，并且在方法内部调用了initBeanFactory()方法。所以在这个方法上打上断点</p><p> 接着再进入AnnotationAwareAspectJAutoProxyCreator类。可以看到这个类又重写了initBeanFactory()这个方法。所以我们也在这里打上断点。</p></li><li><p>AnnotationAwareAspectJAutoProxyCreator注册<br>这里本质就是bean的创建 // TODO bean创建的博客总结预计完成在4月18日<br>这里特殊的就是AnnotationAwareAspectJAutoProxyCreator的beanName是 org.springframework.aop.config.internalAutoProxyCreator</p></li><li><p>AnnotationAwareAspectJAutoProxyCreator的执行过程<br>容器中会被注册一个AnnotationAwareAspectJAutoProxyCreator组件，这个组件由于后置处理器不同，会在每个bean创建的时候进行下面一个后置处理器</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以把断点打在这里，可以观察到AnnotationAwareAspectJAutoProxyCreator的作用。</span></span><br><span class="line"><span class="comment">// 用来创建代理和切面。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">        Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p> 每一个bean创建之前，调用postProcessBeforeInstantiation()；</p><ul><li>关心MathCalculator和LogAspect的创建<ul><li>1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）</li><li>2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，或者是否是切面（@Aspect）</li><li>3）、是否需要跳过<ul><li>1）、获取候选的增强器（切面里面的通知方法）【List<Advisor> candidateAdvisors】每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true</li><li>2）、永远返回false</li></ul></li></ul></li></ul></li><li><p>创建AOP代理</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postProcessAfterInitialization；</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<span class="comment">//如果需要包装的情况下</span></span><br></pre></td></tr></table></figure><ol><li>获取当前bean的所有增强器（通知方法）  Object[]  specificInterceptors<ol><li>找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）</li><li>获取到能在bean使用的增强器。</li><li>给增强器排序</li></ol></li><li>保存当前bean在advisedBeans中</li><li>如果当前bean需要增强，创建当前bean的代理对象；<ol><li>获取所有增强器（通知方法）</li><li>保存到proxyFactory</li><li>创建代理对象：Spring自动决定<ul><li>JdkDynamicAopProxy(config);jdk动态代理；</li><li>ObjenesisCglibAopProxy(config);cglib的动态代理；</li></ul></li></ol></li><li>给容器中返回当前组件使用cglib增强了的代理对象</li><li>以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；</li></ol></li></ol><p>到此aop创建的流程大体上走完了，可能会比较乱，打算在有空的时候，再来好好整理一下。下一次复习的时候，会补上一个流程图。<br><img src="https://brandonxcc.top/20200412.jpg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AOP的目的&quot;&gt;&lt;a href=&quot;#AOP的目的&quot; class=&quot;headerlink&quot; title=&quot;AOP的目的&quot;&gt;&lt;/a&gt;AOP的目的&lt;/h1&gt;&lt;p&gt;AOP能够将那些与业务无关，却为业务逻辑共同调用的逻辑或者责任(例如：事务处理，日志管理，权限管理等等)封装
      
    
    </summary>
    
      <category term="spring 源码" scheme="https://1234zhang.github.io/categories/spring-%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="spring" scheme="https://1234zhang.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>bean生命周期</title>
    <link href="https://1234zhang.github.io/2020/04/11/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://1234zhang.github.io/2020/04/11/spring源码解读/bean生命周期/</id>
    <published>2020-04-11T06:49:06.000Z</published>
    <updated>2020-06-06T10:25:07.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>bean是一个被实例化，组装并通过spring IOC容器管理的对象。这些bean都是由用容器提供的配置元数据构成的。</p><p>下列是每个bean定义的属性，也即是配置元信息</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">class</td><td align="center">这个属性是强制的，并且指定用来创建bean</td></tr><tr><td align="center">name</td><td align="center">这个属性指定唯一的bean标识符。在ioc容器中，可以通过该标识符找到对应的类</td></tr><tr><td align="center">scope</td><td align="center">这个属性指定由bean定义创建的对象的作用域。</td></tr><tr><td align="center">lazy-initialization mode</td><td align="center">延迟初始化，在第一次被请求时才创建对象，而不是在容器启动时就被创建</td></tr><tr><td align="center">initialization</td><td align="center">在bean的所有属性都被赋值之后，ioc容器调用这个初始化方法。</td></tr><tr><td align="center">destroy</td><td align="center">在ioc被销毁时候，调用每个bean的销毁方法</td></tr></tbody></table><h1 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h1><p>在spring boot中可以使用@Scope注解为每一个bean自定义作用域。其中总共有六种作用域提供给使用者，来定义每个bean的作用域</p><table><thead><tr><th align="center">Scope</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">singleton</td><td align="center">spring ioc中只存在一个bean实例。而且是在容器创建时，就把这个bean创建在容器中。</td></tr><tr><td align="center">prototype</td><td align="center">即是多例，这个和单例正好相反，在容器创建时，并不会创建bean，而是在这个bean第一次使用的时候进行创建。而且容器也不会管理这个bean。即在容器被销毁时，也不会调用bean的destroy方法</td></tr><tr><td align="center">request</td><td align="center">容器会为每一个http请求创建一个request的bean。任何一个实例的任何状态更改对其他的实例都是不可见的。一旦请求完成，这个实例就会被销毁</td></tr><tr><td align="center">session</td><td align="center">容器会为每一个http会话创建一个新的实例，即是如果有二十个会话，就会创建二十个实例。在单个会话中，每个请求都可以访问该会话范围内相同的单个bean</td></tr><tr><td align="center">application</td><td align="center">容器为每个web应用程序运行时创建一个实例，几乎是单例范围。但有两个不同的地方：1. 应用程序作用域bean是每个ServletContext的单例对象。2. 应用程序作用域bean作为ServletContext属性可见</td></tr><tr><td align="center">webSocket</td><td align="center">协议支持客户端和远程主机之间的双向通信，远程主机选择与客户端通信。WebSocket协议为两个方向的通信提供了一个单独的TCP连接。这对于具有同步编辑和多用户游戏的多用户应用程序特别有用。在这种类型的Web应用程序中，HTTP仅用于初始握手。如果服务器同意，服务器可以以HTTP状态101（交换协议）进行响应。如果握手成功，则TCP套接字保持打开状态，客户端和服务器都可以使用该套接字向彼此发送消息。</td></tr></tbody></table><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>接下来就是紧张刺激的重头戏——<code>bean生命周期</code>。bean的生命周期：bean创建-&gt;初始化-&gt;销毁。</p><p>构造一个bean</p><ul><li>单实例：在容器启动时，创建对象</li><li>多实例：每次获取时，创建一个对象</li></ul><h2 id="自定义bean的初始化和销毁方法"><a href="#自定义bean的初始化和销毁方法" class="headerlink" title="自定义bean的初始化和销毁方法"></a>自定义bean的初始化和销毁方法</h2><h3 id="通过-Bean的方式指定初始化方法和销毁方法"><a href="#通过-Bean的方式指定初始化方法和销毁方法" class="headerlink" title="通过@Bean的方式指定初始化方法和销毁方法"></a>通过@Bean的方式指定初始化方法和销毁方法</h3><p>在对象创建完成，并完成相关属性赋值之后，就进行初始化。容器关闭时进行销毁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 定义一个对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"car constructor ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"car init ...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"car destroy........."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建一个bean</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"destroy"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现接口InitializingBean-定义初始化-和DisposableBean-定义销毁"><a href="#实现接口InitializingBean-定义初始化-和DisposableBean-定义销毁" class="headerlink" title="实现接口InitializingBean(定义初始化)和DisposableBean(定义销毁)"></a>实现接口InitializingBean(定义初始化)和DisposableBean(定义销毁)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"car constructor ......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"car init ...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这个是实现InitializingBean接口中的方法。。。来进行bean的初始化。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这个是实现DisposableBean接口中的方法。。。来进行bean的销毁。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>bean的后置处理器，在bean的初始化前后完成一些处理工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 这是一个接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 在初始化之前进行一些调用工作</span></span><br><span class="line">        <span class="keyword">return</span> bean;<span class="comment">// 可以直接返回bean，也可以返回包装好的bean</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 在任何初始化方法调用之后，进行处理</span></span><br><span class="line">        <span class="keyword">return</span> bean;<span class="comment">// 可以直接返回bean，也可以返回包装好的bean</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spring-中BeanPostProcessor工作原理"><a href="#spring-中BeanPostProcessor工作原理" class="headerlink" title="spring 中BeanPostProcessor工作原理"></a>spring 中BeanPostProcessor工作原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.brandon.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用postProcessorAfterInitialization方法 ： "</span> + beanName + <span class="string">" =&gt;"</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 在下面一句中打上断点</span></span><br><span class="line">        System.out.println(<span class="string">"调用postProcessionBeforeInitialization 。。。。 "</span> + beanName + <span class="string">"= &gt; "</span> + bean); </span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...经过调用栈之后可以到下面一步</span></span><br><span class="line"><span class="comment">// 为bean中所有属性赋值，mdb就是定义的bean属性 scope等等。。</span></span><br><span class="line"><span class="keyword">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 赋值完成之后调用初始化方法。</span></span><br><span class="line">exposedObject = <span class="keyword">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inittializeBean方法内部，只截取了关键部分。。。</span></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">            <span class="comment">// 在初始化方法之前调用BeanPostProcessorsBeforeInitialization，将所有的beanPostProcessorBeforeInitialization执行一遍</span></span><br><span class="line">            wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsBeforeInitialization(bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用bean的初始化方法</span></span><br><span class="line">            <span class="keyword">this</span>.invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>, beanName, <span class="string">"Invocation of init method failed"</span>, var6);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">            <span class="comment">// 在初始化完成之后，调用BeanPostProcessorsAfterInitialization， 将所有BeanPostProcessorsAfterInitialization执行一遍。</span></span><br><span class="line">            wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Object result = existingBean;</span><br><span class="line"></span><br><span class="line">    Object current;</span><br><span class="line">    <span class="keyword">for</span>(Iterator var4 = <span class="keyword">this</span>.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) &#123;</span><br><span class="line">        BeanPostProcessor processor = (BeanPostProcessor)var4.next();</span><br><span class="line">        <span class="comment">// 挨个执行所有的postProcessBeforeInitialization</span></span><br><span class="line">        <span class="comment">// 如果有null，则直接返回   </span></span><br><span class="line">        current = processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://brandonxcc.top/20200411.jpg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;bean是一个被实例化，组装并通过spring IOC容器管理的对象。这些bean都是由用容器提供的配置元数据构成的。&lt;/p&gt;
&lt;p&gt;下列是
      
    
    </summary>
    
      <category term="spring 源码" scheme="https://1234zhang.github.io/categories/spring-%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="spring" scheme="https://1234zhang.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>redis相关学习</title>
    <link href="https://1234zhang.github.io/2020/03/28/redis%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/"/>
    <id>https://1234zhang.github.io/2020/03/28/redis相关学习/</id>
    <published>2020-03-28T06:18:01.000Z</published>
    <updated>2020-06-06T10:25:07.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>redis作为一个开源的，高级键值存储和一个适用的解决方案，已经越来越在构建<code>高性能</code>，<code>高扩展</code>的WEB应用上发挥着举足轻重的作用。</p><p>当如今互联网技术架构中Redis已经成为应用最为广泛的中间件之一，他也是中高级后端工程技术面试中面试官最喜欢问的工程技能之一，不仅仅要求我们对基本的使用进行掌握，更要求深层次地理解Redis内部实现的细节原理。</p><h1 id="Redis基础篇"><a href="#Redis基础篇" class="headerlink" title="Redis基础篇"></a>Redis基础篇</h1><h2 id="redis的基本概念"><a href="#redis的基本概念" class="headerlink" title="redis的基本概念"></a>redis的基本概念</h2><p>Redis是一个使用c语言编写的，开源的高性能非关系型(NoSQL -&gt; not only sql)的键值对数据库。</p><h2 id="Redis简单的数据结构"><a href="#Redis简单的数据结构" class="headerlink" title="Redis简单的数据结构"></a>Redis简单的数据结构</h2><p>Redis可以存储<code>键</code>和<code>不同类型数据结构值</code>之间的映射关系。键只能是字符串类型，而值除了支持<code>最基本的五种数据类型</code>之外，还支持一些<code>高级数据类型</code>：<br><img src="https://brandonxcc.top/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="avatar"></p><h2 id="Redis小结"><a href="#Redis小结" class="headerlink" title="Redis小结"></a>Redis小结</h2><p>与传统数据库不同的是Redis的数据是<code>存在内存中</code>的，所以<code>读写速度</code>非常<code>快</code>,因此Redis被广泛用于缓存方向，每秒可以处理超过10万次读写操作，是已知的性能最快的Key-Value数据库。Redis还经常用来用作分布式锁。</p><h2 id="Redis优缺点"><a href="#Redis优缺点" class="headerlink" title="Redis优缺点"></a>Redis优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>读写性能优秀：Redis读的速度是11000次/s，写的速度是8100次/s。</li><li>支持数据持久化：支持AOF和RDB两种持久化方式</li><li>支持事务：Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li><li>数据结构丰富：除了支持string类型的value外，还支持hash、set、zset、list等数据结构</li><li>支持主从复制：主机会自动将数据同步到从机，可以进行读写分离。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>数据库容量收到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上</li><li>Redis不具备自动容错和恢复功能。主从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li><li>主机宕机，宕机前还有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为了避免这个问题，运维人员在系统上线时候，必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h2 id="为什么要用缓存-为什么使用Redis"><a href="#为什么要用缓存-为什么使用Redis" class="headerlink" title="为什么要用缓存? 为什么使用Redis"></a>为什么要用缓存? 为什么使用Redis</h2><ul><li><p>现在WEB应用的现状：<br>在日常的Web应用对数据的访问中，<code>读操作的次数远超写操作</code>,比例大概在1:9到3:7,所以需要读的可能性是比写的可能大得多。当我们使用SQL语句去数据库进行读写操作时，数据库就会<code>去磁盘把对应的数据索引取回来</code>，这是一个相对较慢的过程。</p></li><li><p>使用Redis OR 使用缓存带来的优势<br>如果我们把数据放在Redis中，也就是直接放在内存中，让服务端直接去内存读取内存中的数据，那么这样速度明显就会快上不少(<code>高性能</code>), 并且会极大减小数据库的压力(<code>特别面对高并发情况下</code>)</p></li><li><p>使用缓存的考虑<br>使用内存进行数据存储开销也是比较打的，限于成本的原因，一般我们只是使用Redis存储一些常用和主要的数据，比如用户登录的信息等。一般而言在使用Redis进行存储的时候，我们需要从一下几个方面来考虑：</p><ul><li>业务数据常用吗？命中率如何？如果命中率很低，就没必要写入缓存</li><li>改业务数据是读操作多还是写操作多。如果写操作多，频繁写入数据库，也没必要使用缓存</li><li>业务数据大小如何，如果要存储几百兆的文件，会给缓存带来很大的压力，这样也没有必要。</li></ul></li></ul><h2 id="使用缓存会出现什么问题"><a href="#使用缓存会出现什么问题" class="headerlink" title="使用缓存会出现什么问题"></a>使用缓存会出现什么问题</h2><p>一般来说会有如下几个问题：</p><ul><li>缓存雪崩问题</li><li>缓存穿透问题</li><li>缓存和数据库数据写双一致问题<br>参考<a href="https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A" target="_blank" rel="noopener">链接</a></li></ul><h3 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h3><p><img src="https://brandonxcc.top/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98.png" alt="avatar"><br>对于Redis挂掉了，请求全部走数据库 这样的情况，我们还可以有如下思路：</p><ul><li>事发前：实现Redis的高可用性(主从架构 + Redis Cluster),尽量避免Redis挂掉这样的情况发生。</li><li>事发中：万一Redis真的挂掉了，我们可以设置本地缓存(ehcache) + 限流(hystrix),尽量避免我们的数据库被干掉(起码能够保证我们的服务还是能正常工作的)</li><li>事发后：Redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</li></ul><h3 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h3><p><img src="https://brandonxcc.top/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98.png" alt="avatar"></p><h3 id="缓存与数据库双写一致性问题"><a href="#缓存与数据库双写一致性问题" class="headerlink" title="缓存与数据库双写一致性问题"></a>缓存与数据库双写一致性问题</h3><p><img src="https://brandonxcc.top/%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.png" alt="avatar"></p><h2 id="为什么Redis早期版本选择单线程"><a href="#为什么Redis早期版本选择单线程" class="headerlink" title="为什么Redis早期版本选择单线程"></a>为什么Redis早期版本选择单线程</h2><h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><p>因为Redis是基于内存的操作，CPU不是Redis的性能瓶颈，Redis的瓶颈最有可能是<code>机器内存大小</code>或者<code>网络带宽</code>。既然CPU不会成为瓶颈，而且单线程容易实现，就使用单线程实现就成为了顺理成章的事情了。</p><p>(阅读链接<a href="https://draveness.me/whys-the-design-redis-single-thread" target="_blank" rel="noopener">Redis为什么这么设计</a>)</p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><ol><li>使用单线程模型能够带来更好的可维护性，方便开发和调试</li><li>使用单线程模型也能并发的处理客户端的请求(I/O多路复用机制)</li><li>Redis服务中运行的绝大多数操作的性能瓶颈并不是CPU。</li></ol><h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><ol><li>纯内存操作：读取不需要进行磁盘I/O，所以比传统数据库要快上不少；</li><li>单线程，无锁竞争：这保证了没有线程上下文切换，不会因为多线程的一些操作而降低性能；</li><li>多路I/O复用模型，非阻塞I/O：采用多路I/O复用技术可以让单个线程高效的处理多个网络连接请求</li><li>高效的数据结构，加上底层做了大量优化：Redis对于数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyPerLogLog的密集型存储结构等</li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="常用的数据结构以及实现"><a href="#常用的数据结构以及实现" class="headerlink" title="常用的数据结构以及实现"></a>常用的数据结构以及实现</h2><p>首先Redis内部会使用一个RedisObject对象来表示所有的key和value：<br><img src="https://brandonxcc.top/RedisObject.png" alt="avatar"></p><p>其次Redis为了平衡空间和时间效率，针对value的具体类型在底层会采用不同的数据结构来实现，下图展示了他们之间的映射关系<br><img src="https://brandonxcc.top/%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F.png" alt="avatar"></p><h2 id="Redis的SDS和C中的字符串相比有什么优势"><a href="#Redis的SDS和C中的字符串相比有什么优势" class="headerlink" title="Redis的SDS和C中的字符串相比有什么优势"></a>Redis的SDS和C中的字符串相比有什么优势</h2><h3 id="简单总结-1"><a href="#简单总结-1" class="headerlink" title="简单总结"></a>简单总结</h3><p>c语言使用了一个长度为N+1的字符串来表示长度为N的字符串，并且字符数组最后一个元素总是\0，这种简单的字符串表达方式不符合Redis对字符串在安全性、效率</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;redis作为一个开源的，高级键值存储和一个适用的解决方案，已经越来越在构建&lt;code&gt;高性能&lt;/code&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Schema与数据优化</title>
    <link href="https://1234zhang.github.io/2020/01/11/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/Shchema%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96/"/>
    <id>https://1234zhang.github.io/2020/01/11/高性能MySQL/Shchema与数据优化/</id>
    <published>2020-01-11T02:28:32.000Z</published>
    <updated>2020-06-06T10:25:07.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>本篇主要是《高性能MySQL》，一书的读书笔记。良好的逻辑设计和物理设计是高性能的基石，这往往需要权衡各个方面的各种因素。</p><h1 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h1><p>选择正确的数据类型对获得更高效的性能至关重要，在进行数据类型选择的时候，主要遵从如下几个原则:</p><ul><li><p>更小的通常更好</p><p>  一般情况下，应该尽量选择可以正确存储数据的最小数据类型。更小的数据类型通常更快，占用的内存空间更小。在进行查询操作的时候，有更少的I/O操作。</p></li><li><p>简单更好</p><p>  简单数据类型操作通常需要更少的CPU内存。例如：整型比字符操作代价更低，因为字符集和校对规则使字符比整型更复杂。在进行设计的时候，我们应该优先选择使用MySQL内建类型(datetime, timestamp)来代替字符串来存储时间，使用整型来存储IP地址</p></li><li><p>尽量避免NULL</p><p>  如果使用null的列，对MySQL更难优化，因为可为null的列使得索引和索引统计值都更加复杂。可为null的列会使用更多的存储空间</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>分为两种类型的数，整数分为两种，分别是有符号数和无符号数。有符号数和无符号数有相同的存储空间，并具有相同的性能，因此可以根据实际情况选择合适的类型。</p></li></ul><p>MySQL对整数类型指定宽度(例如int(11))，这个对大多数应用是没有意义的，这个的主要目的是为了方便可视化界面的显示，但并不影响数据的存储。所以int(1)和int(11)对于存储和计算来说，是相同的。</p><h2 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h2><p>MySQL既支持精确类型又支持非精确类型。FLOAT和DOUBLE类型支持标准的浮点运算进行近似计算。</p><p>DECIMAL类型用于存储精确的小数，支持精确计算。因为CPU不支持DECIMAL的直接计算，是MySQL自身实现了DECIMAL的高精度计算。所以在计算性能方面，浮点数运算明显更快。所以我们可以得出的是DECIMAL只是一种存储格式，在计算的时候DECIMAL会转换成DOUBLE类型。</p><p>因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用DECIMAL。但在数据量比较大的时候，可以考虑使用BIGINT代替DECIMAL，这样可以同时避免浮点存储计算不精确和DECIMAL精确计算代价高的缺点。</p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>从MySQL4.1开始每个字符串列可以定义自己的字符集和排序规则(校对规则)。</p><ul><li><p>VARCHAR</p><p>  VARCHAR类型用于存储可变长字符串，最常见的字符串数据类型。比定长类型更加节省空间。他只使用必要的空间(越短的字符串使用越少的空间)。<br>  VARCHAR需要使用1或2个字节记录字符串的长度：如果列的<code>最大长度小于或等于255字节</code>，则只使用1个字节表示，否则使用2个字节表表示。<br>  VARCHAR节省了存储空间，所以对性能也有帮助。但是由于行是变长的，在UPDATE可能使得行变得比原来更长，这就需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的存储空间可以存储。不同的存储引擎对这个解决方法不同，MyISAM会将行拆分成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。</p></li><li><p>CHAR</p><p>  当存储CHAR值的时候，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。以下是对该行为的测试(所用mysql8.0.11)<br>  <img src="https://brandonxcc.top/char%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5.png"><br>  <img src="https://brandonxcc.top/char%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5.png"><br>  但是使用varchar就会保存末尾的空格<br>  <img src="https://brandonxcc.top/varchar%E6%9F%A5%E8%AF%A2.png"><br>  CHAR适合存储一些很短的字符串，或者所有字符串都接近一个长度。对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR很少产生一些碎片。对于存储一些非常短的列，char也比varchar更加有优势，比如使用char(1) 来存储只有Y和N的值，如果单个字符集只需要一个字节，但是varchar(1)则需要两个字节，因为还有一个额外记录长度的字节。</p></li><li><p>更大的空间并不是明智的</p><p>使用varchar(5)与使用varchar(200)来存储’hello’所用的空间是一致的。但是更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时会特别糟糕。</p></li></ul><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>MySQL可以使用很多类型来保存时间和时间值。MySQL能存储的最小时间粒度为秒。但是MySQL也可以使用微秒级的粒度进行临时运算。</p><ul><li><p>DATETIME</p><p>  这个类型能保存大范围的值，从1001年到9999年，精度为秒。把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。</p></li><li><p>TIMESTAMP </p><p>  与unix时间戳相同。TIMESTAMP只使用4个字节的存储空间，表示的范围比DATETIME要小得多。</p></li></ul><h2 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h2><p>使用紧凑的位存储数据。所有位数据，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。</p><ul><li><p>BIT</p><p>使用BIT列在一列中存储一个或者多个true/false值，BIT(1)定义一个包含单个位的字段，BIT(2)存储2个位，依次类推。BIT列列的最大长度是64个位。</p><p>MySQL把BIT当作字符串类型，而不是数据类型。当检索BIT(1)的值的时候，结果是一个包含二进制0或者1的值的字符串。而不是ASCII码的”0”或者”1”。在数字上下文检索的时候，结果是将位字符串转换成数字。</p></li><li><p>SET</p><p>如果需要保存很多的true/false的值，可以考虑合并这些列到一个SET数据类型中，他在MySQL内部是以一系列打包的位的集合来表示的。使用FIND_IN_SET()和FIELD()这样的函数，方便在查询中使用。他的主要的缺点是改变列的定义的代价比较高：需要ALTER TABLE。</p><h2 id="选择标识符"><a href="#选择标识符" class="headerlink" title="选择标识符"></a>选择标识符</h2><p>一般来说更有可能用标识列与其他值进行比较，或者通过标识列寻找其他列。标识列也可能在另外的表中作为外键使用，所以为标识列选择数据类型时，应该选择跟关联表中对应列一样的类型</p></li></ul><p>选择标识列的时候，不仅仅需要考虑存储类型，还需要考虑MySQL对这种类型怎么执行计算和比较。一旦选择了一种类型，要确保在所有关联表中都使用同样的类型，而且类型之间需要精确匹配，包括unsigned这种类型。</p><p>在满足值的范围需求，并且预留未来增长的空间的前提之下，应该选择最小的数据类型。有时候可以省下几个字节，就是这几个字节可以导致较大的性能差异。下面是一些使用技巧。</p><ul><li><p>整数类型：整数类型是标识列最好的选择，因为他们很快并且可以使用auto_increment</p></li><li><p>ENUM和SET</p><p> 对于标识符来说，ENUM和SET是一个糟糕的选择，尽管对某些只包含固定状态或者类型的静态“定义表”来说可能是没有问题的。使用枚举类型作为标识列是可行的，但是大部分情况下都要避免这么做。</p></li><li><p>字符串类型</p><p>  如果可能，应该避免使用字符串类型作为标识列，因为他们很消耗空间，并且通常比数字类型慢。</p></li></ul><h1 id="MySQL-schema设计中的陷阱"><a href="#MySQL-schema设计中的陷阱" class="headerlink" title="MySQL schema设计中的陷阱"></a>MySQL schema设计中的陷阱</h1><ul><li><p>太多的列</p><p>  MySQL的存储引擎API工作时候需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。如果计划使用数千个字段，必须意识到服务器的性能运行特征会有一些不同。</p></li><li><p>太多的关联</p><p>  所谓“实体 - 属性 - 值”设计模式是一个常见的糟糕的设计模式，尤其是在MySQL下不能靠谱的工作。MySQL限制了每个关联操作最多只能有61个表，但EAV数据库需要许多自关联。如果希望查询执行得快并且并发性好，单个查询最好在12个表以内做关联。</p></li><li><p>全能的枚举</p><p>  防止过度使用枚举(ENUM)。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ... (country enum(<span class="string">''</span>, <span class="string">'1'</span>,<span class="string">'2'</span>));</span><br></pre></td></tr></table></figure><p>  这样的模式是非常糟糕的。而且在添加枚举值的时候，需要使用alter table来修改整个表的值，在MySQL5.0之前，alter是一个阻塞操作。即便是在MySQL5.0之后如果不是在列表的末尾添加值，也会一样需要alter table</p></li><li><p>变相的枚举</p><p>  枚举列允许在列中存储一组定义值中的单个值，集合(SET)列则允许在列中存储一组定义值的一个或者多个。有时候可能容易导致混乱</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ... (is_default <span class="keyword">set</span>(<span class="string">'y'</span>,<span class="string">'n'</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">'n'</span>)</span><br></pre></td></tr></table></figure><p>  👆 如果是真和假两种情况不会同时出现，那么毫不疑问应该使用枚举列代表集合列</p></li><li><p>非此发明的null</p><p>  之前提及避免使用null，并且应该尽可能的考虑替代方案。即使需要存储一个事实上的“空值”到表中的时候，也不一定使用null，可以使用0、某个特殊值、空字符串来代替。</p><p>  但是遵循这个原则也不要走极端。当确实需要表示未知值的时候，也不要抗拒使用null。在一些场景中，使用null可能会比某个神奇常数更好。从特定类型的值域中选择一个不可能的值，例如使用一个-1表示未知的整数，可能导致代码复杂更多，并且容易引入bug。</p><p>  <img src="https://brandonxcc.top/%E6%A8%B1%E5%90%B9%E9%9B%AA.jpg"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;本篇主要是《高性能MySQL》，一书的读书笔记。良好的逻辑设计和物理设计是高性能的基石，这往往需要权衡各个方
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://1234zhang.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>集合框架源码之list(一)</title>
    <link href="https://1234zhang.github.io/2020/01/09/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E4%B9%8Blist/"/>
    <id>https://1234zhang.github.io/2020/01/09/集合框架源码/集合框架源码之list/</id>
    <published>2020-01-09T06:43:31.000Z</published>
    <updated>2020-06-06T10:25:07.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>众所周知，在面试的时候，集合框架是一定会考察的知识点。这个也是Java基础中很重要的一部分，在特定的场景之下选择合适的数据结构，能够提高代码的效率。比如这篇博客将要总结的ArrayList和LinkedList。这个是很鲜明的对比，由于内部实现的不同，在查找频繁的场景之下使用ArrayList,在插入频繁的情况之下使用LinkedList。所以了解其内部实现，能够有利于我们选择合适的工具，去高效完成我们的需求。</p><p>接下来我将分别介绍ArrayList和LinkedList内部源码的实现</p><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList实现了list接口,可调节数组大小实现，具有全部可选择列表操作。并允许所有元素包括(null)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.ArrayList内部使用Object[]数组来存储ArrayList元素。</span></span><br><span class="line"><span class="comment">从这个可以得出该集合类不能存储基本数据类型。</span></span><br><span class="line"><span class="comment">这里涉及Java的泛型。</span></span><br><span class="line"><span class="comment">2. 初始化时， 首先将该数组设置为空数组，</span></span><br><span class="line"><span class="comment">在插入第一个元素的时候，再设置为默认长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>主要内部提供一下三种类型的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享数组实例，用于空实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//在初始化时，提供初始长度，这个可以使用于事先知道存储大小，可以避免频繁扩容所导致的性能损失</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化不提供初始长度，则初始化为一个长度为0的数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 将一个集合类转换为列表，使用Arrays.copyOf。如果提供的集合类长度为0，则初始化为一个长度为0的数组。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用c.toArray可能不会返回一个正确的数组，所以我们使用Arrays.copyOf</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>在ArrayList中的属性中，关于容量的默认值分别如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里设置将容量的长度设置为Integer最大值减8的原因是：</span></span><br><span class="line"><span class="comment">这里是要分配的数组最大大小，由于一些虚拟机中在数组会保存一些数据头。</span></span><br><span class="line"><span class="comment">当扩容之后的容量大于MAX_ARRAY_SIZE，比较最小容量是否还是大于MAX_ARRAY_SIEZE，如果是则分配Integer.MAX_VALUE，否则分配MAX_ARRAY_SIZE长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h3 id="自定义list容器的容量"><a href="#自定义list容器的容量" class="headerlink" title="自定义list容器的容量"></a>自定义list容器的容量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    自定义容量的大小，参数minCapactity要满足</span></span><br><span class="line"><span class="comment">    1. 大于elementData本身长度</span></span><br><span class="line"><span class="comment">    2. elementData不是一个空数组</span></span><br><span class="line"><span class="comment">    3. minCapacity要大于默认值(10)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; elementData.length</span><br><span class="line">            &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">                 &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h3><p>将elementData容量扩展为至少可以容纳的最小容量指定的元素数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容算法"><a href="#扩容算法" class="headerlink" title="扩容算法"></a>扩容算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 将原来容量扩展为原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新的长度小于指定的最小长度。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断ElementData是否是一个空数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="comment">// 如果minCapacity是小于零的，抛出OOM异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="comment">// 返回最小长度</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如果新的长度大于指定的最小长度，再判断newCapacity是否大于该数组允许的最大长度</span></span><br><span class="line"><span class="comment">    如果小于则扩容为新的长度</span></span><br><span class="line"><span class="comment">    如果大于则扩容为指定的长度。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看自定义的值是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><h3 id="每次插入单个元素"><a href="#每次插入单个元素" class="headerlink" title="每次插入单个元素"></a>每次插入单个元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在指定的位置插入元素</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 判断index的值是否合法。</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 该属性与iterator和list iterator有关</span></span><br><span class="line">    <span class="comment">// 非预期修改情况下，会触发快速失败</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">// 对原来数组进行复制操作，空出index的位置。并插入element，size - index后的数据统一后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在数组尾部插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="每次插入一个集合的元素"><a href="#每次插入一个集合的元素" class="headerlink" title="每次插入一个集合的元素"></a>每次插入一个集合的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    将一个集合的元素插入到该elementData中，</span></span><br><span class="line"><span class="comment">    按照插入集合的顺序返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将插入的集合转换为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);</span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在指定的位置插入某个集合的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="keyword">this</span>.elementData).length - (s = size))</span><br><span class="line">        elementData = grow(s + numNew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = s - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index,</span><br><span class="line">                         elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size = s + numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index是否合法</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) </span><br><span class="line">    E oldValue = (E) es[index];</span><br><span class="line">    fastRemove(es, index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除在列表中第一次出现的指定元素。如果列表不含有指定元素，则不变。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// break:标号 -&gt; 表示：终止结束到标签</span></span><br><span class="line">    found: &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fastRemove(es, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 专用的删除方法，跳过边界检查并且不返回删除的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">        <span class="comment">// 删除指定位置之后，将后续元素向前移动</span></span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除所有元素"><a href="#删除所有元素" class="headerlink" title="删除所有元素"></a>删除所有元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = size = <span class="number">0</span>; i &lt; to; i++)</span><br><span class="line">            es[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="删除某个指定范围内的元素"><a href="#删除某个指定范围内的元素" class="headerlink" title="删除某个指定范围内的元素"></a>删除某个指定范围内的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    删除指定范围内的元素，将删除后的元素向左移动(减少其索引)</span></span><br><span class="line"><span class="comment">    通过使用(fromIndex - toIndex)元素来缩短列表。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt; toIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(</span><br><span class="line">                outOfBoundsMsg(fromIndex, toIndex));</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    shiftTailOverGap(elementData, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过向左移动，来减少从lo到li的距离</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftTailOverGap</span><span class="params">(Object[] es, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(es, hi, es, lo, size - hi);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> to = size, i = (size -= hi - lo); i &lt; to; i++)</span><br><span class="line">        es[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除某个包含在某个集合中的所有元素"><a href="#删除某个包含在某个集合中的所有元素" class="headerlink" title="删除某个包含在某个集合中的所有元素"></a>删除某个包含在某个集合中的所有元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合c就是要在elementData数组中要删除的元素</span></span><br><span class="line"><span class="comment">// 该集合不能为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该方法表示删除不在集合c中的元素</span></span><br><span class="line"><span class="comment">// 同样该集合c不能允许空元素</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确定修改元素的索引是否合法</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看元素是否在列表中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回元素第一次出现的索引，如果不包含则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOfRange(o, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在数组中查找元素，返回第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfRange</span><span class="params">(Object o, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Object[] es = elementData;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回最后元素最后一次出现的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastIndexOfRange(o, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfRange</span><span class="params">(Object o, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Object[] es = elementData;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 写出元素计数以及任何隐藏的内容</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">//执行默认的反序列化/序列化过程。将当前类的非静态和非瞬态字段写入此流</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出大小作为与clone()行为兼容的容量</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照正确的顺序写出元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入大小以及隐藏元素</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入容量</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[]<span class="class">.<span class="keyword">class</span>, <span class="title">size</span>)</span>;</span><br><span class="line">        Object[] elements = <span class="keyword">new</span> Object[size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照顺序读入所有元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            elements[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elementData = elements;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Invalid size: "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于列表的序列化中，没有使用默认的序列化，而是自己实现了序列化方法是因为，动态数组在操作的时候可能会造成大量的空元素，如果所有空元素都序列化了，会造成一定的资源浪费。</p><h2 id="为什么说ArrayList不适合频繁插入和删除操作"><a href="#为什么说ArrayList不适合频繁插入和删除操作" class="headerlink" title="为什么说ArrayList不适合频繁插入和删除操作"></a>为什么说ArrayList不适合频繁插入和删除操作</h2><p>在增加删除ArrayList中经常会调用System.arraycopy这个效率很低的操作来复制数组，所以导致ArrayList在插入和删除操作中效率不高</p><h2 id="关于快速失败和安全失败"><a href="#关于快速失败和安全失败" class="headerlink" title="关于快速失败和安全失败"></a>关于快速失败和安全失败</h2><ol><li><p>快速失败</p><p> 在使用迭代器遍历一个集合对象的时候，如果遍历过程中对集合对象进行了修改(增、删、改)，则会抛出Concurrent Modification Exception。的错误</p><p> 原理:在集合中，维护了这么一个变量(modCount)</p></li><li><p>安全失败</p></li></ol><p>(小小说一句：这个是2020年第一篇博客。许个小小的愿望，希望自己2020年能坚持写博客，希望能拿到一个大厂的正式offer，稳定的搬砖。。。)<br><img src="https://brandonxcc.top/%E6%97%A5%E5%87%BA.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;众所周知，在面试的时候，集合框架是一定会考察的知识点。这个也是Java基础中很重要的一部分，在特定的场景之下
      
    
    </summary>
    
      <category term="Java" scheme="https://1234zhang.github.io/categories/Java/"/>
    
      <category term="集合框架" scheme="https://1234zhang.github.io/categories/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ArrayList" scheme="https://1234zhang.github.io/categories/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList/"/>
    
    
      <category term="Java集合" scheme="https://1234zhang.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Spring Ioc的启动过程</title>
    <link href="https://1234zhang.github.io/2019/11/25/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Spring-Ioc%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://1234zhang.github.io/2019/11/25/spring源码解读/Spring-Ioc的启动过程/</id>
    <published>2019-11-25T09:11:27.000Z</published>
    <updated>2020-06-06T10:25:07.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Ioc的基本概念"><a href="#Spring-Ioc的基本概念" class="headerlink" title="Spring Ioc的基本概念"></a>Spring Ioc的基本概念</h2><p>Ioc(inversion of Control), 被通常翻译为控制反转，或者是DI(dependency Injuction)依赖注入。</p><p>如果我们需要某个对象的功能，不需要人为手动的去创建对象的实例；只需要向框架说明我需要这个对象，框架就会自动的提供这个对象的实例。也就是原来我们需要什么东西需要自己去拿，但是现在框架就会为我们送过来。</p><p>依赖注入的实现主要有三种方式：</p><ul><li>构造方法注入：被注入对象可以通过在其构造方法中声名依赖对象的参数列表，让外部对象（通常是IoC容器）知道它需要哪些依赖对象。IoC Service Provider会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。</li><li>setter 方法注入：当前对象只要为其所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。</li><li>接口注入</li></ul><h2 id="Spring-Ioc初始化的过程"><a href="#Spring-Ioc初始化的过程" class="headerlink" title="Spring Ioc初始化的过程"></a>Spring Ioc初始化的过程</h2><p>spring Ioc的最基本启动过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationfile.xml"</span>);</span><br><span class="line">&#125; </span><br><span class="line">可以认为是在classPath中找到xml文件，根据xml文件配置applicationContext</span><br></pre></td></tr></table></figure><h2 id="Ioc源码分析"><a href="#Ioc源码分析" class="headerlink" title="Ioc源码分析"></a>Ioc源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 对这个实例进行加锁处理，</span></span><br><span class="line">    <span class="comment">//避免在applicationContext还未创建完成，</span></span><br><span class="line">    <span class="comment">//就出现另一个线程对这个实例的创建或者销毁操作。</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            <span class="comment">//记下启动时间，并且将状态改为正在运行。</span></span><br><span class="line">            <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">            <span class="comment">// 根据配置信息，解析成一个个的bean定义，并注册到beanFactory中。</span></span><br><span class="line">            <span class="comment">// 创建一个beanName -&gt; beanDefinition的map，只是建立映射，并未初始化。</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">            <span class="comment">// bean的加载器，并加载几个特殊的bean</span></span><br><span class="line">            <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果bean继承了BeanFactoryPostProcess这个接口</span></span><br><span class="line">                <span class="comment">// 在初始化的时候，spring会调用postProcessBeanFactory方法。</span></span><br><span class="line">                <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">                <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">                <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">                <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">                <span class="keyword">this</span>.onRefresh();</span><br><span class="line">                <span class="keyword">this</span>.registerListeners();</span><br><span class="line">                <span class="comment">// 初始化所有的singleton bean</span></span><br><span class="line">                <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                <span class="comment">// 广播bean的初始化完成。</span></span><br><span class="line">                <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">                <span class="keyword">this</span>.cancelRefresh(var9);</span><br><span class="line">                <span class="keyword">throw</span> var9;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里可以明白一个事情，虽然Application继承自beanFactory，但是不应该将ApplicationContext看作beanFactory的实现类；而是应当看作是内部持有一个beanFactory的实例，所有的BeanFacotory操作是委托给context去做的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-Ioc的基本概念&quot;&gt;&lt;a href=&quot;#Spring-Ioc的基本概念&quot; class=&quot;headerlink&quot; title=&quot;Spring Ioc的基本概念&quot;&gt;&lt;/a&gt;Spring Ioc的基本概念&lt;/h2&gt;&lt;p&gt;Ioc(inversion of C
      
    
    </summary>
    
      <category term="spring 源码" scheme="https://1234zhang.github.io/categories/spring-%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="spring" scheme="https://1234zhang.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-127 word ladder</title>
    <link href="https://1234zhang.github.io/2019/11/19/%E7%AE%97%E6%B3%95/leetcode-127-word-ladder/"/>
    <id>https://1234zhang.github.io/2019/11/19/算法/leetcode-127-word-ladder/</id>
    <published>2019-11-19T15:29:46.000Z</published>
    <updated>2020-06-06T10:25:07.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p>说明:</p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li></ul><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：startWord &#x3D; hit</span><br><span class="line">      endWord &#x3D; cog</span><br><span class="line">      wordList &#x3D; [hot, dot, dog, lot, log, cog]</span><br><span class="line">输出：5</span><br><span class="line">eg. hit -&gt; hot -&gt; dot -&gt; dog -&gt; cog</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：startWord &#x3D; hit</span><br><span class="line">    endWord &#x3D; cog</span><br><span class="line">    wordList &#x3D; [hot, dot, dog, lot, log]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的
      
    
    </summary>
    
      <category term="Java" scheme="https://1234zhang.github.io/categories/Java/"/>
    
      <category term="算法" scheme="https://1234zhang.github.io/categories/Java/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://1234zhang.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Java类的一生</title>
    <link href="https://1234zhang.github.io/2019/11/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E7%B1%BB%E7%9A%84%E4%B8%80%E7%94%9F/"/>
    <id>https://1234zhang.github.io/2019/11/17/Java虚拟机/Java类的一生/</id>
    <published>2019-11-17T13:55:13.000Z</published>
    <updated>2020-06-06T10:25:07.196Z</updated>
    
    <content type="html"><![CDATA[<p>一直在想，Java类的一生是不是跟人的一生一样，要经过生老病死。所以我想用类比的方式总结一下JVM中，Java类加载到GC垃圾收集</p><h2 id="生"><a href="#生" class="headerlink" title="生"></a>生</h2><p>Java代码编译和执行的整个过程包含了如下三个重要机制：</p><ul><li>Java源码的编译机制</li><li>类加载机制</li><li>类执行机制<h3 id="从源代码到字节码"><a href="#从源代码到字节码" class="headerlink" title="从源代码到字节码"></a>从源代码到字节码</h3>Java的编译过程如下：</li></ul><p><img src="https://brandonxcc.top/Java%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.gif" alt="avatar"><br>Java源码编译经过下面三个过程组成：</p><ul><li>分析和输入到字符表</li><li>注解处理</li><li>语义分析和生成class文件</li></ul><p>最后生成的class字节码文件包括内容：</p><ul><li>结构信息，包括class文件格式和版本号以及各个部分的数量和大小</li><li>元数据。对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息。域与方法声明信息和常量池 (ps:  <a href="https://www.jianshu.com/p/c7f47de2ee80" target="_blank" rel="noopener">常量池的相关简介与理解</a>)</li><li>方法信息。 对应 Java 源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息</li></ul><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>虚拟机把描述类的数据从Class文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p><p><strong>加载</strong></p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时的数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><p><strong>验证</strong></p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机所处理。</li><li>元数据的验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。</li><li>字节码验证：通过数据流和控制流的分析，确定程序语义是合法的、符合逻辑的</li></ul><p><strong>准备</strong></p><ul><li>为static修饰的变量在方法区分配内存并设置初始值，这里的初始值是该数据类型下的零值</li></ul><p><strong>解析</strong></p><ul><li>虚拟机将常量池中的符号引用替换为直接引用的过程。</li></ul><p><strong>初始化</strong></p><p>对类进行初始化的五个情况</p><ul><li>使用new关键字实例化对象的时候，读取或者设置一个类的静态字段(被fina修饰、已在编译器把结果放在常量池的静态字段除外)的时候，调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候。</li><li>初始化一个类，但他的父类还没有初始化， 则会先触发其父类的初始化</li><li>当虚拟机启动的时候，会先初始化用户指定的要执行的主类(包含main方法的哪个类)</li><li>使用jdk1.7动态语言支持的时候，实例化最后解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化过，则需要先触发其初始化。</li></ul><p><strong>类加载器</strong></p><p>对于任何一个类，都需要由加载他的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。可以这样说，就算来源同一个Class文件，由不同的类加载器加载，那么这就是两个类。</p><ul><li>双亲委派模型<ul><li>概念：双亲委派模型要求除了最顶层的启动类加载器除外，其余的类加载器都应该有自己的父类加载器。类加载器中的父子关系一般不会以继承的关系来实现。</li><li>工作过程：如果一个类收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，只有当父类加载器无法完成加载任务时，子类加载器才会尝试加载。</li></ul></li></ul><h3 id="Java对象的内存分配"><a href="#Java对象的内存分配" class="headerlink" title="Java对象的内存分配"></a>Java对象的内存分配</h3><p>在一个对象出生之后，肯定需要一个内存去存放这个对象，在Java虚拟机中，对内存的分配有如下几种方式</p><p><strong>对象优先在eden区分配</strong></p><p>大多数情况下，对象在Eden区中分配。当eden区没有足够空间进行分配时，虚拟机将发起一起minor gc。</p><p><strong>大对象直接进入老年代</strong></p><p>需要大量连续存储空间的Java对象(例如:长的字符串以及大数组),在分配时就直接被分配到老年代，避免在eden和Survivor区中发生大量的内存复制。</p><p><strong>长期存活的对象将进入老年代</strong></p><p>对象在Survivor区中每熬过一次Minor GC 对象的年龄就增长一岁，到达阈值时(默认是15，可自定义阈值), 就会晋升到老年代。</p><p><strong>动态对象年龄判定</strong></p><p>并不是严格规定只有岁数超过阈值才能晋升老年代，如果Surivivor区中，相同年龄总和的大小大于Survivor空间的一半，年龄大于或者等于该年龄的对象可以直接晋升老年代。</p><p><strong>空间分配担保</strong></p><p>新生代使用复制算法，为了内存利用率，只使用一个Survivor空间作为轮换空间，如果一次minor GC之后，Survivor内存无法容纳存活对象，需要老年代进行分配担保，一些对象直接晋升老年代。担保都是需要风险的，老年代原先是由存活对象所占有，老年代无法预先知道在垃圾回收机制之后，会有多少对象存活下来。所以取每一次晋升老年代的对象的平均值大小作为经验值，来与老年代剩余对象做对比。但是这个平均值也是一个概率事件，如果存活对象的内存大小突增，那么还是会进行一次Full GC.</p><h2 id="死"><a href="#死" class="headerlink" title="死"></a>死</h2><h3 id="对象死亡的判断"><a href="#对象死亡的判断" class="headerlink" title="对象死亡的判断"></a>对象死亡的判断</h3><p><strong>引用计数法</strong></p><p>判断一个对象是否存活，给对象中添加一个对象引用计数器，每当有一个地方引用它时，计数器值就加一个，引用失效的时候，计数值就减一，当计数器值到达0的时候，这个对象就会被回收。但是两个互相引用的对象，在没有其他引用的时候，这两个对象相互引用着对方，引用计数器都不会为0，那么就不会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> Byte[<span class="number">2</span> * _1MB];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line"></span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        <span class="comment">// 进行手动gc操作。</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">可以发现上面的对象被回收了，</span><br><span class="line">所以在实际的虚拟机中，</span><br><span class="line">不是使用这个方法进行回收判断。</span><br></pre></td></tr></table></figure><p><strong>可达性分析算法</strong></p><p>通过一系列的称为”GC root”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链(ReFerence Chain), 当一个对象到GC Root没有任何引用链相连接时，则说明这个对象是不可用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以作为GC Root的对象：</span><br><span class="line">虚拟机栈(栈帧中的本地变量表)中引用的对象</span><br><span class="line">方法区中类静态属性引用的对象。</span><br><span class="line">方法区中常量引用的对象</span><br><span class="line">本地方法栈中JNI(一般说的native方法)引用的对象。</span><br></pre></td></tr></table></figure><p><strong>引用分析</strong></p><ul><li>强引用。 类似<code>Object obj = new Object();</code>这类引用。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象.</li><li>软引用。用来描述一些还有用，但是非必须的对象。对于这类对象，在虚拟机发生内存溢出异常之前，将会把这些对象进行二次回收。</li><li>弱引用。 比软引用跟弱的引用，也是用来描述一些非必须对象。当发生垃圾回收时，无论当前内存是否足够，都会被回收。</li><li>虚引用。被称为幽灵引用或者幻影引用，他是最弱的引用关系。他存在的目的就是在这个对象被回收的时候会收到一个系统通知。</li></ul><p><strong>被标记死亡对象的最后挣扎</strong></p><p>要将对象最终判死刑，要经过两此标记。第一次是可达性分析中，没有在引用链上的对象将被标记。这个时候会对这些对象进行一个判断，如果该对象<code>没有覆盖finalize()方法</code>或者<code>finalize()方法已经被调用过</code>了，这两种情况都会被最终认定为”没有必要执行”,就会被垃圾回收机制所清除。反之，虚拟机执行finalize()方法，将对象放置在一个F-Queue队列中，如果在该队列中的对象，重新与引用链建立引用，那么这个对象就成功复活。<br>下列是一个对象的自我救赎过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FInalizeExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeExample example = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed"</span>);</span><br><span class="line">        FinalizeExample.example = <span class="keyword">this</span>;<span class="comment">// 这里重新建立连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回收方法区</strong></p><p>由于永久代的回收效率低，很多人都认为方法区没有垃圾回收机制，但是不是这样的。方法区的垃圾回收主要集中在两个部分：废弃常量和无用的类。回收常量和Java堆中对象的回收特别相似。但是无用的类的判断就比较严苛了。<br>无用类的判断要同时满足下列三个条件:</p><ul><li>该类的所有实例都被回收，Java堆中不存在该类的实例对象。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该方法，</li></ul><h3 id="GC回收算法"><a href="#GC回收算法" class="headerlink" title="GC回收算法"></a>GC回收算法</h3><p><strong>标记-清理算法</strong></p><p>过程：</p><ul><li>首先标记需要回收的对象</li><li>统一回收标记了的对象</li></ul><p>缺点：</p><ul><li>效率低，标记和清理的过程效率都低</li><li>清理了之后，会产生一些不连续的内存碎片</li></ul><p><strong>复制算法</strong></p><p>过程：</p><ul><li>将内存分为两个部分</li><li>在一个部分中用于对新对象的分配，另一个部分用于复制存活的对象。</li><li>清除用于对新对象分配内存的半区</li></ul><p>对内存分配的比例问题<br>hotpot默认分区为，eden: Survivor = 8 : 1,也就是可以为新生对象分配内存的区域占整个新生代的90%(80% + 10%)。当Survivor区内存不够为存活对象分配内存时，会依赖其他内存(老年代),进行担保分配。</p><p><strong>标记 - 整理</strong></p><p>老年代的对象有可能是100%存活的，这种情况下使用复制算法效率就会降低。所以老年代采用标记-整理算法。<br>过程</p><ul><li>标记需要回收的对象</li><li>将存活对象全部向一端移动。然后另外一端进行空间清理。</li></ul><p><strong>分代清理</strong></p><h3 id="GC收集器"><a href="#GC收集器" class="headerlink" title="GC收集器"></a>GC收集器</h3><p><img src="https://brandonxcc.top/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="avatar"></p><p><strong>Serial收集器</strong></p><p>这个收集器是一个单线程收集器，”单线程”并不是仅仅指它只会使用一个CPU或者一个收集线程去完成垃圾收集工作，更重要的是，他会停止其他的工作线程，在他工作期间。这就是传说中的”stop the world”。</p><p>尽管现在的垃圾收集器越来越先进，可以将stw的时间大幅度的缩短，缩短到用户感受不到的程度，但是也是无法避免的一个过程。</p><p>Serial垃圾收集器也不是一无是处的，到目前为止，它依然是虚拟机运行在Client模式下的默认新生代收集器，在单个cpu环境下来说，Serial由于没有线程间的交互产生，专心做垃圾回收，自然也是单线程收集效率最高的垃圾收集器。</p><p><strong>ParNew收集器</strong></p><p>Serial的多线程版本，除了使用多线程进行垃圾收集器之外，其余特征都和Serial相同。虽然与Serial相差不大，但是ParNew是许多运行在Server模式下的虚拟机中首选的垃圾收集器。而且只有它能够跟CMS配合工作。</p><p>ParNew收集器在单CPU环境中绝对不会比Serial收集器有更好的收集效果，甚至还有线程交互的开销。但是随着CPU的核心数增加，它默认开启的收集线程数量和CPU的数量相同。</p><p><strong>Parallel Scavenge收集器</strong></p><p>Parallel Scavenge收集器是一个使用复制算法的新生代收集器，也是并行的多线程收集器。Parallel Scavenge收集器目标是达到一个可控制的吞吐量。(吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)),高吞吐量可以高效率地利用CPU时间，尽快完成程序运算任务。</p><p>Parallel Scavenge提供一个自适应调节策略，将内存管理的调优任务交给虚拟机去完成将是一个不错的选择。将调优参数交给虚拟机，为虚拟机设定一个优化目标，具体细节参数的调节工作就交给虚拟机自己完成。自适应调节策略也是Paralle Scavenge收集器与ParNew收集器的一个重要区别。</p><p><strong>Serial Old收集器</strong></p><p>Serial Old是Serial收集器的老年代的版本，它也是一个单线程的收集器，使用标记 - 整理算法，这个收集器主要意义也是给Client模式下的虚拟机使用。</p><p>如果Serial Old 用于Server模式下的虚拟机，主要有两个用处</p><ul><li>在jdk1.5以及之前的虚拟机中与Parallel Scavenge收集器搭配使用</li><li>作为CMS收集器的后备方案。</li></ul><p><strong>Parallel Old收集器</strong></p><p>是Parallel Scavenge老年代版本的收集器，由于Serial Old单线程收集器，无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这个组合还没有ParNew 加 CMS 的组合效率高。</p><p><strong>CMS 收集器</strong></p><p>CMS是一个以获取最短回收停顿时间为目标的收集器。CMS是基于标记 - 清除算法实现的，它运作过程相对更加复杂一些。其具体过程如下</p><ul><li>初始标记：标记GC root能直接关联到的对象</li><li>并发标记：进行GC root tracing的过程</li><li>重新标记：修正在并发标记的时候因用户程序的运行而使标记产生变动的标记</li><li>并发清除</li></ul><p>整个过程中，并发标记和并发清除都可以和用户线程一起进行。</p><p>但是这个收集器也不是完美的，有如下几个缺点：</p><ul><li>CMS收集器队CPU资源非常敏感。它虽然不会导致用户线程停顿，但是会因为占用一部分的线程而导致应用程序变慢，总吞吐量降低。</li><li>CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failue”失败，而导致Full gc的产生。由于在垃圾清除过程中，用户程序也在运行，这个时候就难免的会产生新的垃圾，只能等到下一次GC时再清除。CMS会预留一部分空间提供并发收集过程中程序运行使用，如果预留内存无法满足程序需要，就会出现”Concurrent Mode Failure”失败，就会启动后备预案：启动Serial Old收集器来进行老年代的收集。</li><li>由于CMS使用的是标记-清除算法，会导致大量的空间碎片。</li></ul><p><strong>G1收集器</strong></p><p>G1收集器是一款面向服务端应用的垃圾收集器。与其他的垃圾收集器相比，具有一下的特点：</p><ul><li>并行与并发：通过多个核心使得Stop the World时间变短，G1收集器可以通过并发的方式让在其他收集器原本需要停顿的Java线程继续执行。</li><li>分代收集：虽然G1收集器可以不需要其他收集器配合就能独立管理整个GC堆，但是他能够采用不同的方式去处理新创建的对象和已经存活了一段时间的、熬过多次GC的旧对象以获得更好的收集效果</li><li>空间整合：G1从整体上来看是使用标记 - 整理算法进行垃圾收集，但在局部上是基于复制算法实现。所以G1在运行时间不会产生空间碎片。</li><li>可预测停顿：G1收集器建立可预测的停顿时间模型，能够让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直在想，Java类的一生是不是跟人的一生一样，要经过生老病死。所以我想用类比的方式总结一下JVM中，Java类加载到GC垃圾收集&lt;/p&gt;
&lt;h2 id=&quot;生&quot;&gt;&lt;a href=&quot;#生&quot; class=&quot;headerlink&quot; title=&quot;生&quot;&gt;&lt;/a&gt;生&lt;/h2&gt;&lt;p&gt;J
      
    
    </summary>
    
      <category term="JVM" scheme="https://1234zhang.github.io/categories/JVM/"/>
    
    
      <category term="Java类" scheme="https://1234zhang.github.io/tags/Java%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>sql+geohash 与mongodb对比</title>
    <link href="https://1234zhang.github.io/2019/11/15/sql-geohash-%E4%B8%8Emongodb%E5%AF%B9%E6%AF%94/"/>
    <id>https://1234zhang.github.io/2019/11/15/sql-geohash-与mongodb对比/</id>
    <published>2019-11-15T12:54:18.000Z</published>
    <updated>2020-06-06T10:25:07.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mongodb地理索引"><a href="#mongodb地理索引" class="headerlink" title="mongodb地理索引"></a>mongodb地理索引</h2><p>mongodb 是老牌的空间索引支持着，作为一个文档性的数据库，存储日志和静态数据结构效果较佳，它主要提供两个类型的空间索引：</p><ul><li>2d 索引支持平台普通坐标的索引，使用于2.4版本之前，在大范围上存储和计算时，效率较低，</li><li>2dsphere 索引支持查询在一个类地球的球面上进行计算，使用geoJson对象或者普通坐标对的方式进行存储数据。<br>索引都是使用geohash算法以及b+树来实现。<br>mongodb的空间索引比较灵活，GeoJson对象有点，线，多边形，多条线段，多点，多个多边形。支持包含、相交、临近的查询，也支持多条件查询<br>缺点：<ul><li>在数据比较大的时候，查询效率就会比较低，特别是多个条件符合时，查询效率更加低</li><li>对模糊查询的支持不是太友好，如果是按照地名或者地点名字查询时就需要MySQL</li></ul></li></ul><h2 id="sql-geohash-地理索引"><a href="#sql-geohash-地理索引" class="headerlink" title="sql + geohash 地理索引"></a>sql + geohash 地理索引</h2><p>在存储每个地点位置信息的时候，将经纬度使用geohash算法，将二维坐标转换成一个字符串。并将这个hash字符串设置为索引，从而在获取附近停车场的时候，可以提高查询效率。<br>使用MySQL存储geohash的好处是</p><ul><li>多条件支持，分词，模糊查询。可以解决mongodb无法实现的模糊查询，</li><li>索引的查询效率也不低，同样使用b+树实现。<br>为了逻辑的简单，而且解决更多的问题，在效率相差不大的情况下，所以选择MySQL搭档geohash的方式来实现地图的查找。</li></ul><h2 id="geohash-简单描述"><a href="#geohash-简单描述" class="headerlink" title="geohash 简单描述"></a>geohash 简单描述</h2><p><img src="https://brandonxcc.top/geohash.jpg" alt="avatar"><br>将经纬度的二进制数进行组合，以奇数为纬度，偶数为经度组合，过程如上图。</p><p>然户将获取到的经纬度二进制数以每5个数为一组，将每一组都进行转换成十进制数字。</p><p>然后采用Base32对应编码进行转换可得到编码 wx4g0e这样的可比较的字符串，比如我们的经纬度都分了10次，那么最后生成的字符串的长度就是4，范围是20km，如果我们经纬度都分20次，那么最后生成的字符串的长度就是8，范围可以精确到19m。<br>在此对Base32编码进行一番简单介绍: Base32，是将数字 0~9 ，加上26个字母(去除a,i,l,o 四个)进行组合而成的32个字符编码形式。</p><p>Geohash其实就是将整个地图或者某个分割所得的区域进行一次划分，由于采用的是base32编码方式，即Geohash中的每一个字母或者数字（如wx4g0e中的w）都是由5bits组成（2^5 = 32，base32），这5bits可以有32中不同的组合（0~31），这样我们可以将整个地图区域分为32个区域，通过00000 ~ 11111来标识这32个区域。第一次对地图划分后的情况如下图所示（每个区域中的编号对应于该区域所对应的编码）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mongodb地理索引&quot;&gt;&lt;a href=&quot;#mongodb地理索引&quot; class=&quot;headerlink&quot; title=&quot;mongodb地理索引&quot;&gt;&lt;/a&gt;mongodb地理索引&lt;/h2&gt;&lt;p&gt;mongodb 是老牌的空间索引支持着，作为一个文档性的数据库，存储
      
    
    </summary>
    
    
      <category term="mongodb" scheme="https://1234zhang.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>mongodb 相关配置</title>
    <link href="https://1234zhang.github.io/2019/11/15/mongodb-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <id>https://1234zhang.github.io/2019/11/15/mongodb-相关配置/</id>
    <published>2019-11-15T05:19:28.000Z</published>
    <updated>2020-06-06T10:25:07.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mongodb社区版本-ubuntu安装-ubuntu-18-04-mongodb-4-0-13"><a href="#mongodb社区版本-ubuntu安装-ubuntu-18-04-mongodb-4-0-13" class="headerlink" title="mongodb社区版本 ubuntu安装(ubuntu 18.04, mongodb 4.0.13)"></a>mongodb社区版本 ubuntu安装(ubuntu 18.04, mongodb 4.0.13)</h3><p><code>mongodbDB.inc</code>维护的包是<code>mongodb-org</code>，而不是<code>mongodb</code>，我们要确保系统没有安装mongodb，否则会发生包冲突。</p><p><strong>导入公钥</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver hkp:&#x2F;&#x2F;keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4</span><br></pre></td></tr></table></figure><p><strong>源列表添加新的仓库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb [ arch&#x3D;amd64 ] https:&#x2F;&#x2F;repo.mongodb.org&#x2F;apt&#x2F;ubuntu $(lsb_release -cs)&#x2F;mongodb-org&#x2F;4.0 multiverse&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;mongodb-org-4.0.list</span><br></pre></td></tr></table></figure><p><strong>更新源</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p><strong>安装最新版mongodb</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y mongodb-org</span><br></pre></td></tr></table></figure><h3 id="启动mongodb"><a href="#启动mongodb" class="headerlink" title="启动mongodb"></a>启动mongodb</h3><p><strong>运行mongodb</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongod start</span><br></pre></td></tr></table></figure><p><strong>验证mongodb是否启动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat &#x2F;var&#x2F;log&#x2F;mongodb&#x2F;mongod.log</span><br></pre></td></tr></table></figure><p><img src="https://brandonxcc.top/mongodb.png" alt="avatar"></p><p>如果出现[initandlisten] waiting for connections on port 27017，说明正在运行</p><p><strong>重启mongodb</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongod stop</span><br><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure><p><strong>打开mongo shell</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><h3 id="修改mongodb相关配置"><a href="#修改mongodb相关配置" class="headerlink" title="修改mongodb相关配置"></a>修改mongodb相关配置</h3><p><strong>添加用户</strong><br>首先进入mongodb shell操作界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><p>然后切换到admin数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br></pre></td></tr></table></figure><p>输入下面的指令创建一个root用户， 而且密码为root, 可以按照自己的需求更改用户密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.craeteUser(</span><br><span class="line">    &#123;</span><br><span class="line">        user: &quot;root&quot;,</span><br><span class="line">        pwd: &quot;root&quot;,</span><br><span class="line">        roles: [&#123;role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot;&#125;, &quot;readWriteAnyDatabase&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>密码可以使用密码生成器生成的随机密码，提高安全性。<br>其中的userAdminAnyDatabase角色赋予了root账户在该mongodb实例中，管理数据库的权限。</p><p><strong>开启数据库的权限验证</strong><br>更改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;mongod.conf</span><br></pre></td></tr></table></figure><p>在配置文件中，加上如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">security:</span><br><span class="line">    authorization: enabled</span><br></pre></td></tr></table></figure><p>然后重启mongodb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongod stop</span><br><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure><p><strong>添加单个数据库的用户权限</strong></p><p>首先切换到admin数据库，使用root验证权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.auth(&quot;root&quot;, &quot;root&quot;)</span><br></pre></td></tr></table></figure><p>创建一个数据库， 并添加一个拥有者test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use testDb</span><br><span class="line">db.createUser(&#123;</span><br><span class="line">    user: &quot;test&quot;,</span><br><span class="line">    pwd: &quot;test&quot;,</span><br><span class="line">    roles: [&#123;role: &quot;dbOwner&quot;, db: &quot;test&quot;&#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们为test，赋予了dbOwner权限，保证test，用户有操作所有collection读和写的权限</p><p><strong>连接mongodb</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongodb:&#x2F;&#x2F;test:test@localhost&#x2F;testDb</span><br><span class="line"></span><br><span class="line">用户名：test</span><br><span class="line">密码：test</span><br><span class="line">数据库：testDb</span><br></pre></td></tr></table></figure><p><strong>远程连接mongodb</strong><br>修改配置将默认端口127.0.0.1，修改为0.0.0.0，此种情况下，允许所有机器访问mongodb</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mongodb社区版本-ubuntu安装-ubuntu-18-04-mongodb-4-0-13&quot;&gt;&lt;a href=&quot;#mongodb社区版本-ubuntu安装-ubuntu-18-04-mongodb-4-0-13&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="中间件" scheme="https://1234zhang.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="mongodb" scheme="https://1234zhang.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>java NIO的组件</title>
    <link href="https://1234zhang.github.io/2019/10/17/java-NIO/"/>
    <id>https://1234zhang.github.io/2019/10/17/java-NIO/</id>
    <published>2019-10-17T08:39:55.000Z</published>
    <updated>2020-06-06T10:25:07.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NIO三大组件Buffer、Channel、Selector"><a href="#NIO三大组件Buffer、Channel、Selector" class="headerlink" title="NIO三大组件Buffer、Channel、Selector"></a>NIO三大组件Buffer、Channel、Selector</h1><h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h2><p>一个buffer实质上是内存中的一块，我们可以将数据写入这块内存之中，然后从这个内存中读取数据。下面是java.nio包中定义的几个buffer<br><img src="https://brandonxcc.top/buffer.png"><br>前面是byteBuffer的修饰，我们主要使用的还是byteBuffer。下面是有关buffer的相关操作，以及关于buffer的重要属性和方法。</p><h3 id="position、limit、capacity"><a href="#position、limit、capacity" class="headerlink" title="position、limit、capacity"></a>position、limit、capacity</h3><p><img src="https://brandonxcc.top/position.png"></p><p><strong>capacity</strong>：表示这个缓存区的容量，一旦设定就不能更改。一旦缓存区所含数据大小达到容量大小，就不能再存放数据，必须清空缓存区才能继续添加数据。<br><strong>position</strong>：初始值是0，每添加一个数据，position就+1。读操作类似。<br><img src="https://brandonxcc.top/buffe%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C.png"></p><h3 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a><strong>flip()方法</strong></h3><p>flip方法将buffer从写模式转换为读模式，而且只能这么干。调用flip()方法会使得position值变为0，并将limit设置为原来position的值。也就是position开始用于表示读的位置，limit表示总共有多少个数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position; <span class="comment">// 将 limit 设置为实际写入的数据数量</span></span><br><span class="line">    position = <span class="number">0</span>; <span class="comment">// 重置 position 为 0</span></span><br><span class="line">**limit**：写操作模式下，limit代表的是最大能写入的数据，这个时候limit与capacity相同。当读操作模式下，limit的值与position值相同，表示buffer所含有的数据实际大小。</span><br><span class="line">    mark = -<span class="number">1</span>; <span class="comment">// mark 之后再说</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化buffer"><a href="#初始化buffer" class="headerlink" title="初始化buffer"></a><strong>初始化buffer</strong></h3><p>每个buffer都提供了一个allocate(int capacity)静态方法，用于初始化buffer(eg: ByteBuffer byteBuffer = ByteBuffer.allocate(1024))</p><h3 id="填充buffer"><a href="#填充buffer" class="headerlink" title="填充buffer"></a><strong>填充buffer</strong></h3><p>每个buffer类都提供了put方法将数据填充进buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充一个byte进buffer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 在一个指定的位置加入byte</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">//将一个数组填充进去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span></span>&#123;....&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>最常用的应该是从channel中读取数据，填充到buffer中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = channel.read(bytebuffer);</span><br><span class="line">将会返回buffer读取数据的数值。</span><br></pre></td></tr></table></figure><h3 id="读取buffer"><a href="#读取buffer" class="headerlink" title="读取buffer"></a><strong>读取buffer</strong></h3><p>如果要读取buffer中的值，需要将buffer从写入操作转换为读出操作。使用flip方法可以达到操作的目的。我们通常说的从channel中读取数据，其实是将数据写入buffer中。<br>buffer也提供了相应的get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 position 来获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取指定位置的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 将 Buffer 中的数据写入到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span></span></span><br></pre></td></tr></table></figure><p>除了从buffer中取出数据来用，我们更加常用的方法是将buffer中的数据读取出来写入channel中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = channel.write(buffer);</span><br></pre></td></tr></table></figure><h3 id="mark"><a href="#mark" class="headerlink" title="mark()"></a><strong>mark()</strong></h3><p>mark()用于临时保存position的值，每次调用mark()方法都会将mark设值为当前position，便于后续需要时候调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mark()方法可以配合着reset()方法一起使用，如果我们在读取到position为5时候，调用mark()方法，然后继续往下面读，如果我们又想返回到position为5的位置上时，就可以调用reset方法，使得position为5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### **rewind()&amp;clear()&amp;&amp;compact()**</span><br><span class="line">**rewind()**: 会将position的值设置为<span class="number">0</span>，通常用于从头读写buffer</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>clear()</strong>：可以理解为重置buffer，调用这个方法之后，我们就可以往buffer中重新填充数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>compact()</strong>： 和clear有点相似的是，都是在准备往buffer中重新填充数据之前调用。<br>前面说的 clear() 方法会重置几个属性，但是我们要看到，clear() 方法并不会将 Buffer 中的数据清空，只不过后续的写入会覆盖掉原来的数据，也就相当于清空了数据了。</p><p>而 compact() 方法有点不一样，调用这个方法以后，会先处理还没有读取的数据，也就是 position 到 limit 之间的数据（还没有读过的数据），先将这些数据移到左边，然后在这个基础上再开始写入。很明显，此时 limit 还是等于 capacity，position 指向原来数据的右边。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>nio所有数据始于通道，通道是数据的来源或者写入的目的地。我们主要关注java.nio包中如下几个channel<br><img src="https://brandonxcc.top/channel.png"></p><ol><li>fileChannel: 文件通道，用于文件的读和写</li><li>DatagramChannel: 用于UDP的链接和接收</li><li>SocketChannel: 可以理解为TCP的客户端</li><li>ServerSocketChannel: 用于监听TCP某个端口的请求。</li></ol><p>channel经常和buffer打交道，读操作的时候将Channel中的数据填充到buffer中。<br><img src="https://brandonxcc.top/bufferReader.png"><br><img src="https://brandonxcc.top/bufferWrite.png"></p><h3 id="socketChannel"><a href="#socketChannel" class="headerlink" title="socketChannel"></a>socketChannel</h3><p>可以将socketChannel看作是tcp的客户端，socketChannel一般是配合着serverSocketChannel使用。<br>打开一个tcp链接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> inetSocketAddress(<span class="string">"http://localhost"</span>, <span class="number">80</span>))</span><br></pre></td></tr></table></figure><p>上面的代码也等价于下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一个通道</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://localhost"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure><h3 id="serverSocketChannel"><a href="#serverSocketChannel" class="headerlink" title="serverSocketChannel"></a>serverSocketChannel</h3><p>上面所说的socketChannel对应着TCP的客户端，那么serverSocketChannel就对应着TCP的服务端。<br>serverSocketChannel用于监听端口，管理从这个端口来的TCP连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 监听 8080 端口</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一旦有一个 TCP 连接进来，就对应创建一个 SocketChannel 进行处理</span></span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面展示了socketChannel第二种实例化的方法。<br>所以我们单纯将socketChannel看作是TCP客户端的理解有点狭隘，它不仅仅代表着tcp客户端，也是一个网络通道，可读可写。<br>ServerSocketChannel不与buffer打交道，它并不处理数据，它一旦接收到请求之后，就会实例化一个socketChannel，之后在这个连接通道上传递的数据它就不管了，因为他要继续监听端口，接收下一个请求。</p><h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>DatagramChannel一个类处理了客户端和服务端。<br>监听端口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>));</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">channel.receive(buf);</span><br></pre></td></tr></table></figure><p>发送数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span></span><br><span class="line">                    + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesSent = channel.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>多路复用的主要实现方式，用于实现一个线程管理多个channel。<br>selector的接口基本操作 </p><ol><li>开启一个选择器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></li><li>将channel注册到Selector上。selector建立在非阻塞模式之上，所以注册到Selector的channel必须支持非阻塞模式，fileChannel不支持非阻塞模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configuraBlocking(<span class="keyword">false</span>);<span class="comment">// 设置channel为非阻塞模式。</span></span><br><span class="line">SelectorKey key = channel.register(selector, SelectorKey.OP_READ);</span><br></pre></td></tr></table></figure>register第二个参数是int型的(使用二进制表示),用于表示对监听哪些事件感兴趣。共下面四个事件</li></ol><ul><li>SelectionKey.OP_READ <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应 00000001，通道中有数据可以进行读取</span><br></pre></td></tr></table></figure></li><li>SelectionKey.OP_WRITE<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应 00000100，可以往通道中写入数据</span><br></pre></td></tr></table></figure></li><li>SelectionKey.OP_CONNECT<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应 00001000，成功建立 TCP 连接</span><br></pre></td></tr></table></figure></li><li>SelectionKey.OP_ACCEPT<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应 00010000，接受 TCP 连接</span><br></pre></td></tr></table></figure>我们可以监听一个channel中的多个事件，比如我们要监听 ACCEPT 和 READ 事件，那么指定参数为二进制的 00010001 即十进制数值 17 即可。<br>注册方法返回值是 SelectionKey 实例，它包含了 Channel 和 Selector 信息，也包括了一个叫做 Interest Set 的信息，即我们设置的我们感兴趣的正在监听的事件集合。</li></ul><ol start="3"><li>调用select()方法获取通道中的信息。用于判断我们感兴趣的事情是不是发生了。</li></ol><p>对于seletor中的几个方法，我们应该熟悉下面几个方法</p><ul><li>select()<br>调用这个方法，会将上次select之后准备好的channel对应的selectionKey复制到selected set中。如果通道中没有任何方法准备好，那么就会阻塞在这个方法里，直到监听到某个感兴趣的事件发生。</li><li>selectNow()<br>与select方法功能相同，但是区别的是如果没有监听到任何事件，这个方法会立即返回。</li><li>select(long timeout)<br>如果通道没有准备好，会等待一会儿，然后再返回。不会一直阻塞在这个方法中。</li><li>wakeup()<br>这个方法是用来唤醒等待在select() 和select(long timeout)方法上的线程。如果wakeup被提前调用，此时没有线程在select上阻塞。那么之后的select或者select(long timeout)就会立即返回，而不会阻塞，这个只生效一次。</li></ul><p><img src="https://brandonxcc.top/zwx.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NIO三大组件Buffer、Channel、Selector&quot;&gt;&lt;a href=&quot;#NIO三大组件Buffer、Channel、Selector&quot; class=&quot;headerlink&quot; title=&quot;NIO三大组件Buffer、Channel、Selector&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://1234zhang.github.io/categories/Java/"/>
    
      <category term="Java流操作" scheme="https://1234zhang.github.io/categories/Java/Java%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    
      <category term="nio" scheme="https://1234zhang.github.io/categories/Java/Java%E6%B5%81%E6%93%8D%E4%BD%9C/nio/"/>
    
    
      <category term="java提高" scheme="https://1234zhang.github.io/tags/java%E6%8F%90%E9%AB%98/"/>
    
  </entry>
  
  <entry>
    <title>21岁生日</title>
    <link href="https://1234zhang.github.io/2019/10/04/%E9%9A%8F%E7%AC%94/21%E5%B2%81%E7%94%9F%E6%97%A5/"/>
    <id>https://1234zhang.github.io/2019/10/04/随笔/21岁生日/</id>
    <published>2019-10-03T16:21:08.000Z</published>
    <updated>2020-06-06T10:25:07.201Z</updated>
    
    <content type="html"><![CDATA[<p>缝缝补补又是一年过去了，自己也到二十一岁了。说起来二十出头这几年真的是尴尬的几年。说年轻不年轻，老陈更说不上了。想轻轻松松无忧无虑，但冷不丁生活又会给你找一大堆压力；空闲的时候想沉淀一下自己，回想起来，发现都没经历过几件事情，或者说都是一些琐碎杂事。</p><p>说说最近比较焦虑的事情吧，其实就是一直在纠结考研和工作的事情。我感觉我内心深处还是想考研的，恐惧和担忧的就是“万一考不上怎么办”。端午的时候也跟老爸聊过，他们都很支持我考研。他们说的挺对的，“不试试怎么知道，不能在开始就否定自己”。但是真的考不上怎么办，秋招也错过了，春招找不到好工作。都说应届生的身份很重要，错过了真的很可惜。说来自己也惭愧，扭扭捏捏的一点也不男子汉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;缝缝补补又是一年过去了，自己也到二十一岁了。说起来二十出头这几年真的是尴尬的几年。说年轻不年轻，老陈更说不上了。想轻轻松松无忧无虑，但冷不丁生活又会给你找一大堆压力；空闲的时候想沉淀一下自己，回想起来，发现都没经历过几件事情，或者说都是一些琐碎杂事。&lt;/p&gt;
&lt;p&gt;说说最近
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://1234zhang.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法</title>
    <link href="https://1234zhang.github.io/2019/10/03/%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://1234zhang.github.io/2019/10/03/算法/常见排序算法/</id>
    <published>2019-10-03T07:36:09.000Z</published>
    <updated>2020-06-06T10:25:07.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>算法描述：</p><ul><li>比较相邻的两个元素。如果后一个元素比前一个元素大就交换这两个元素的位置。</li><li>对每个一个元素做相同的动作，每次都从第一个元素开始直到最后一个。每一轮都可以保证最后一个元素最大。这里我们可以定义一个指针，指向最后一个位置，每一轮结束之后指针前移一位(可以减少一点的循环次数)。<br>下面是代码排序代码:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="comment">// 下面代码省略main函数，只留下算法核心</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaopaoSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>])&#123;</span><br><span class="line">                    exchange(nums, j, j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2>插入排序算法步骤</li><li>从第一个元素开始，该元素可以被认为已经排序好的</li><li>取下一个元素，在已经排序好的前序序列中，从后向前扫描；</li><li>如果(已经排序好的元素)该元素大于新元素，则该元素移向下一个位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><p><img src="https://brandonxcc.top/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif"><br>插入排序核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = i;</span><br><span class="line">            <span class="keyword">while</span>(flag &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[flag] &lt; nums[flag - <span class="number">1</span>])&#123;</span><br><span class="line">                    exchange(nums, flag, flag - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                flag--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><img src="https://brandonxcc.top/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif"></p><p>下面是选择排序的核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChoiceSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> minPosition = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; nums.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[minPosition])&#123;</span><br><span class="line">                    minPosition = j;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            exchange(nums, i, minPosition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序就是升级版的插入排序，简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。</p><p>下面是希尔排序的动画演示：</p><p><img src="https://brandonxcc.top/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif"><br>下面是希尔排序的核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = nums.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">               <span class="keyword">int</span> j = i;</span><br><span class="line">               <span class="keyword">while</span>(j &gt;= k)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(nums[j] &lt; nums[j - k])&#123;</span><br><span class="line">                       exchange(nums, j, j - k);</span><br><span class="line">                   &#125;</span><br><span class="line">                   j--;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k = k / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序也使用了分治的思想，下面是算法步骤</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p><img src="https://brandonxcc.top/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif"></p><p>下面是快速排序的具体算法步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 最好从右边开始</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; flag &lt;= nums[right]) right--;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; flag &gt;= nums[left]) left++;</span><br><span class="line">            exchange(nums, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换基准数到中间</span></span><br><span class="line">        exchange(nums, <span class="number">0</span>, left);</span><br><span class="line">        <span class="comment">// 根据基准数的位置，将大数组分为左右两个数组</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, left - <span class="number">1</span>);</span><br><span class="line">        sort(nums, left + <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">int</span> flag = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; flag &lt;= nums[j]) j--;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; flag &gt;= nums[i]) i++;</span><br><span class="line">            exchange(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(nums, left, i );</span><br><span class="line">        sort(nums, left, i - <span class="number">1</span>);</span><br><span class="line">        sort(nums, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并归排序"><a href="#并归排序" class="headerlink" title="并归排序"></a>并归排序</h2><p>并归排序就是将一个数组分为多个小数组，进行递归排序。并归排序体现了分治算法的核心</p><ul><li>分： 将一个完整的数组，分为多个小数组</li><li>治： 每个小数组内部进行排序，最后还原成完整数组也是有序的</li></ul><p><img src="https://brandonxcc.top/%E5%B9%B6%E5%BD%92%E6%8E%92%E5%BA%8F.png"><br><img src="https://brandonxcc.top/%E5%B9%B6%E5%BD%92%E6%8E%92%E5%BA%8F2.png"></p><p>下面是并归排序的动画演示</p><p><img src="https://brandonxcc.top/%E5%B9%B6%E5%BD%92%E6%8E%92%E5%BA%8F%E5%8A%A8%E7%94%BB.gif"><br>并归排序的核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin + end)/<span class="number">2</span>;</span><br><span class="line">            sort(nums, begin, mid, temp); <span class="comment">//左边并归排序，使得左子序列有序</span></span><br><span class="line">            sort(nums, mid + <span class="number">1</span>, end, temp); <span class="comment">// 右边并归排序，使得右子序列有序</span></span><br><span class="line">            merge(nums, temp, begin, mid, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start;<span class="comment">// 左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 右序列指针</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 临时指针</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">                temp[t++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[t++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= mid)&#123; <span class="comment">// 左边剩余元素填充进temp</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">                temp[t++] = nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt;= end)&#123; <span class="comment">// 右边剩余元素填充进temp</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt;= end)&#123;</span><br><span class="line">                temp[t++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123; <span class="comment">// 将temp中的元素全部拷贝回原来数组</span></span><br><span class="line">            nums[start++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解堆排序</a></p><h2 id="排序算法的特性"><a href="#排序算法的特性" class="headerlink" title="排序算法的特性"></a>排序算法的特性</h2><p><img src="https://brandonxcc.top/%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7.png"></p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数</li></ul><p><img src="https://brandonxcc.top/%E5%8D%81%E6%9C%88%E4%B8%89%E5%8F%B7.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;p&gt;算法描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较相邻的两个元素。如果后一个元素比前一个元素大就交换这两个元素的位置。&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://1234zhang.github.io/categories/Java/"/>
    
      <category term="Java基础" scheme="https://1234zhang.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="算法" scheme="https://1234zhang.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
