---
layout: '[layout]'
title: Java类的一生
date: 2019-11-17 21:55:13
tags:
    - Java类
categories:
    - JVM
---
一直在想，Java类的一生是不是跟人的一生一样，要经过生老病死。所以我想用类比的方式总结一下JVM中，Java类加载到GC垃圾收集
## 生
Java代码编译和执行的整个过程包含了如下三个重要机制：
- Java源码的编译机制
- 类加载机制
- 类执行机制
### 从源代码到字节码
Java的编译过程如下：

![avatar](https://brandonxcc.top/Java编译过程.gif)
Java源码编译经过下面三个过程组成：
- 分析和输入到字符表
- 注解处理
- 语义分析和生成class文件

最后生成的class字节码文件包括内容：
- 结构信息，包括class文件格式和版本号以及各个部分的数量和大小
- 元数据。对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息。域与方法声明信息和常量池 (ps:  [常量池的相关简介与理解](https://www.jianshu.com/p/c7f47de2ee80))
- 方法信息。 对应 Java 源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息

### 类的加载
虚拟机把描述类的数据从Class文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

**加载**
- 通过一个类的全限定名来获取定义此类的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时的数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

**验证**
- 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机所处理。
- 元数据的验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。
- 字节码验证：通过数据流和控制流的分析，确定程序语义是合法的、符合逻辑的

**准备**
- 为static修饰的变量在方法区分配内存并设置初始值，这里的初始值是该数据类型下的零值

**解析**
- 虚拟机将常量池中的符号引用替换为直接引用的过程。

**初始化**

对类进行初始化的五个情况
- 使用new关键字实例化对象的时候，读取或者设置一个类的静态字段(被fina修饰、已在编译器把结果放在常量池的静态字段除外)的时候，调用一个类的静态方法的时候。
- 使用java.lang.reflect包的方法对类进行反射调用的时候。
- 初始化一个类，但他的父类还没有初始化， 则会先触发其父类的初始化
- 当虚拟机启动的时候，会先初始化用户指定的要执行的主类(包含main方法的哪个类)
- 使用jdk1.7动态语言支持的时候，实例化最后解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化过，则需要先触发其初始化。

**类加载器**

对于任何一个类，都需要由加载他的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。可以这样说，就算来源同一个Class文件，由不同的类加载器加载，那么这就是两个类。

- 双亲委派模型
    - 概念：双亲委派模型要求除了最顶层的启动类加载器除外，其余的类加载器都应该有自己的父类加载器。类加载器中的父子关系一般不会以继承的关系来实现。
    - 工作过程：如果一个类收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，只有当父类加载器无法完成加载任务时，子类加载器才会尝试加载。


### Java对象的内存分配
在一个对象出生之后，肯定需要一个内存去存放这个对象，在Java虚拟机中，对内存的分配有如下几种方式

**对象优先在eden区分配**

大多数情况下，对象在Eden区中分配。当eden区没有足够空间进行分配时，虚拟机将发起一起minor gc。

**大对象直接进入老年代**

需要大量连续存储空间的Java对象(例如:长的字符串以及大数组),在分配时就直接被分配到老年代，避免在eden和Survivor区中发生大量的内存复制。

**长期存活的对象将进入老年代**

对象在Survivor区中每熬过一次Minor GC 对象的年龄就增长一岁，到达阈值时(默认是15，可自定义阈值), 就会晋升到老年代。

**动态对象年龄判定**

并不是严格规定只有岁数超过阈值才能晋升老年代，如果Surivivor区中，相同年龄总和的大小大于Survivor空间的一半，年龄大于或者等于该年龄的对象可以直接晋升老年代。

**空间分配担保**

新生代使用复制算法，为了内存利用率，只使用一个Survivor空间作为轮换空间，如果一次minor GC之后，Survivor内存无法容纳存活对象，需要老年代进行分配担保，一些对象直接晋升老年代。担保都是需要风险的，老年代原先是由存活对象所占有，老年代无法预先知道在垃圾回收机制之后，会有多少对象存活下来。所以取每一次晋升老年代的对象的平均值大小作为经验值，来与老年代剩余对象做对比。但是这个平均值也是一个概率事件，如果存活对象的内存大小突增，那么还是会进行一次Full GC.
## 死
### 对象死亡的判断

**引用计数法**

判断一个对象是否存活，给对象中添加一个对象引用计数器，每当有一个地方引用它时，计数器值就加一个，引用失效的时候，计数值就减一，当计数器值到达0的时候，这个对象就会被回收。但是两个互相引用的对象，在没有其他引用的时候，这两个对象相互引用着对方，引用计数器都不会为0，那么就不会被回收。
```java
public class ReferenceCountingGC{
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    private byte[] bigSize = new Byte[2 * _1MB];
    public static void testGC(){
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();

        objA.instance = objB;
        objB.instance = objA;
        // 进行手动gc操作。
        System.gc();
    }
} 

可以发现上面的对象被回收了，
所以在实际的虚拟机中，
不是使用这个方法进行回收判断。
```

**可达性分析算法**

通过一系列的称为"GC root"的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链(ReFerence Chain), 当一个对象到GC Root没有任何引用链相连接时，则说明这个对象是不可用的。
```
可以作为GC Root的对象：
虚拟机栈(栈帧中的本地变量表)中引用的对象
方法区中类静态属性引用的对象。
方法区中常量引用的对象
本地方法栈中JNI(一般说的native方法)引用的对象。
```

**引用分析**

- 强引用。 类似`Object obj = new Object();`这类引用。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象.
- 软引用。用来描述一些还有用，但是非必须的对象。对于这类对象，在虚拟机发生内存溢出异常之前，将会把这些对象进行二次回收。
- 弱引用。 比软引用跟弱的引用，也是用来描述一些非必须对象。当发生垃圾回收时，无论当前内存是否足够，都会被回收。
- 虚引用。被称为幽灵引用或者幻影引用，他是最弱的引用关系。他存在的目的就是在这个对象被回收的时候会收到一个系统通知。

**被标记死亡对象的最后挣扎**

要将对象最终判死刑，要经过两此标记。第一次是可达性分析中，没有在引用链上的对象将被标记。这个时候会对这些对象进行一个判断，如果该对象`没有覆盖finalize()方法`或者`finalize()方法已经被调用过`了，这两种情况都会被最终认定为"没有必要执行",就会被垃圾回收机制所清除。反之，虚拟机执行finalize()方法，将对象放置在一个F-Queue队列中，如果在该队列中的对象，重新与引用链建立引用，那么这个对象就成功复活。
下列是一个对象的自我救赎过程
```java
public class FInalizeExample{
    public static FinalizeExample example = null;

    public void isAlive(){
        System.out.println("yes, i am still alive");
    }

    @Override
    protected void finalize() throws Throwable{
        super.finalize();
        System.out.println("finalize method executed");
        FinalizeExample.example = this;// 这里重新建立连接
    }
}
```

**回收方法区**

由于永久代的回收效率低，很多人都认为方法区没有垃圾回收机制，但是不是这样的。方法区的垃圾回收主要集中在两个部分：废弃常量和无用的类。回收常量和Java堆中对象的回收特别相似。但是无用的类的判断就比较严苛了。
无用类的判断要同时满足下列三个条件:
- 该类的所有实例都被回收，Java堆中不存在该类的实例对象。
- 加载该类的ClassLoader已经被回收。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该方法，

### GC回收算法

**标记-清理算法**

过程：
- 首先标记需要回收的对象
- 统一回收标记了的对象

缺点：
- 效率低，标记和清理的过程效率都低
- 清理了之后，会产生一些不连续的内存碎片

**复制算法**

过程：
- 将内存分为两个部分
- 在一个部分中用于对新对象的分配，另一个部分用于复制存活的对象。
- 清除用于对新对象分配内存的半区

对内存分配的比例问题
hotpot默认分区为，eden: Survivor = 8 : 1,也就是可以为新生对象分配内存的区域占整个新生代的90%(80% + 10%)。当Survivor区内存不够为存活对象分配内存时，会依赖其他内存(老年代),进行担保分配。

**标记 - 整理**

老年代的对象有可能是100%存活的，这种情况下使用复制算法效率就会降低。所以老年代采用标记-整理算法。
过程
- 标记需要回收的对象
- 将存活对象全部向一端移动。然后另外一端进行空间清理。


**分代清理**
### GC收集器
![avatar](https://brandonxcc.top/垃圾收集器.png)

**Serial收集器**

这个收集器是一个单线程收集器，"单线程"并不是仅仅指它只会使用一个CPU或者一个收集线程去完成垃圾收集工作，更重要的是，他会停止其他的工作线程，在他工作期间。这就是传说中的"stop the world"。

尽管现在的垃圾收集器越来越先进，可以将stw的时间大幅度的缩短，缩短到用户感受不到的程度，但是也是无法避免的一个过程。

Serial垃圾收集器也不是一无是处的，到目前为止，它依然是虚拟机运行在Client模式下的默认新生代收集器，在单个cpu环境下来说，Serial由于没有线程间的交互产生，专心做垃圾回收，自然也是单线程收集效率最高的垃圾收集器。

**ParNew收集器**

Serial的多线程版本，除了使用多线程进行垃圾收集器之外，其余特征都和Serial相同。虽然与Serial相差不大，但是ParNew是许多运行在Server模式下的虚拟机中首选的垃圾收集器。而且只有它能够跟CMS配合工作。

ParNew收集器在单CPU环境中绝对不会比Serial收集器有更好的收集效果，甚至还有线程交互的开销。但是随着CPU的核心数增加，它默认开启的收集线程数量和CPU的数量相同。

**Parallel Scavenge收集器**

Parallel Scavenge收集器是一个使用复制算法的新生代收集器，也是并行的多线程收集器。Parallel Scavenge收集器目标是达到一个可控制的吞吐量。(吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)),高吞吐量可以高效率地利用CPU时间，尽快完成程序运算任务。

Parallel Scavenge提供一个自适应调节策略，将内存管理的调优任务交给虚拟机去完成将是一个不错的选择。将调优参数交给虚拟机，为虚拟机设定一个优化目标，具体细节参数的调节工作就交给虚拟机自己完成。自适应调节策略也是Paralle Scavenge收集器与ParNew收集器的一个重要区别。

**Serial Old收集器**

Serial Old是Serial收集器的老年代的版本，它也是一个单线程的收集器，使用标记 - 整理算法，这个收集器主要意义也是给Client模式下的虚拟机使用。

如果Serial Old 用于Server模式下的虚拟机，主要有两个用处
- 在jdk1.5以及之前的虚拟机中与Parallel Scavenge收集器搭配使用
- 作为CMS收集器的后备方案。

**Parallel Old收集器**

是Parallel Scavenge老年代版本的收集器，由于Serial Old单线程收集器，无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这个组合还没有ParNew 加 CMS 的组合效率高。

**CMS 收集器**

CMS是一个以获取最短回收停顿时间为目标的收集器。CMS是基于标记 - 清除算法实现的，它运作过程相对更加复杂一些。其具体过程如下
- 初始标记：标记GC root能直接关联到的对象
- 并发标记：进行GC root tracing的过程
- 重新标记：修正在并发标记的时候因用户程序的运行而使标记产生变动的标记
- 并发清除

整个过程中，并发标记和并发清除都可以和用户线程一起进行。

但是这个收集器也不是完美的，有如下几个缺点：
- CMS收集器队CPU资源非常敏感。它虽然不会导致用户线程停顿，但是会因为占用一部分的线程而导致应用程序变慢，总吞吐量降低。
- CMS收集器无法处理浮动垃圾，可能出现"Concurrent Mode Failue"失败，而导致Full gc的产生。由于在垃圾清除过程中，用户程序也在运行，这个时候就难免的会产生新的垃圾，只能等到下一次GC时再清除。CMS会预留一部分空间提供并发收集过程中程序运行使用，如果预留内存无法满足程序需要，就会出现"Concurrent Mode Failure"失败，就会启动后备预案：启动Serial Old收集器来进行老年代的收集。
- 由于CMS使用的是标记-清除算法，会导致大量的空间碎片。

**G1收集器**

G1收集器是一款面向服务端应用的垃圾收集器。与其他的垃圾收集器相比，具有一下的特点：
- 并行与并发：通过多个核心使得Stop the World时间变短，G1收集器可以通过并发的方式让在其他收集器原本需要停顿的Java线程继续执行。
- 分代收集：虽然G1收集器可以不需要其他收集器配合就能独立管理整个GC堆，但是他能够采用不同的方式去处理新创建的对象和已经存活了一段时间的、熬过多次GC的旧对象以获得更好的收集效果
- 空间整合：G1从整体上来看是使用标记 - 整理算法进行垃圾收集，但在局部上是基于复制算法实现。所以G1在运行时间不会产生空间碎片。
- 可预测停顿：G1收集器建立可预测的停顿时间模型，能够让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。