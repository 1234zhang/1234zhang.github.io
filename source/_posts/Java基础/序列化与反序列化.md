---
layout: '[layout]'
title: 序列化与反序列化
date: 2019-09-26 20:02:38
tags:
    - java基础
categories:
    - Java
    - Java基础
---
## 序列化的调用场景
- 序列化：将对象写入IO流之中
- 反序列化：将对象从IO流中恢复
- 意义：序列化机制将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或者通过网络传输，以达到以后恢复成原来对象。序列化机制使得对象可以脱离程序独立存在。
- 使用场景：所有在网络上传输的对象都必须是可序列化的，比如RMI(Remote Method invoke 远程方法调用),传入的参数和方法都必须是可以序列化的，否则会出错；所有需要保存在磁盘上的Java对象都必须是可以序列化的。通常建议：程序创建的每个JavaBean类都实现Serializeable接口

## 如何对一个对象进行序列化
- 使用Serializeable接口，这个接口是一个标记接口，一旦实现了这个接口，对象就可以进行序列化。
- 通过ObjectInputStream和ObjectOutputStream对对象进行序列化或者反序列化。
- 虚拟机是否允许反序列化，不仅仅取决于类路径和功能是否一样，还有一个指标是两个类的序列化ID是否一致（private final static long serialVersionUID）
- 序列化并不保存静态变量
- 如果一个可序列化类的成员变量不是基本类型，也不是String类型，那这个引用类型也必须是可序列化的；否则这个类不能序列化
```java
public class Person{
    // 省略功能性代码
}
public class Teacher implements Serializaeable{
    private Person person;
    public Teacher(Person person){
        this.person = person;
    }
    public static void main(String[] args) throws IoException{
        try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.txt"))){
            Person person = new Person(name);
            Teacher teacher = new Teacher(person);
            oos.writeObject(teacher);
        }
    }
}

会报错，因为Person类的对象是不可以序列化的。这个导致Teacher不能序列化。
Exception in thread "main" java.io.SerializeableException: io.serializeable.Person
```
- 要想将父类也能够序列化，就必须让父类也实现Serializeable接口
- Transient关键字的作用就是控制变量的序列化，在声明变量前加上关键字，可以阻止该变量被序列化到文件中，在被反序列化之后，transient变量被设置为初始值，如int型置0，对象型为null;

## 序列化的实现方式
### 普通序列化
序列化步骤
- 创建一个ObjectOutputStream输出流
- 调用ObjectOutputStream中的writeObject输出可序列化对象
    public String toString(){
```java
public class Person implements Serializeable{
    // 省略属性方法
    @Ovrride
        return name + " " +  age;
    }
}

public class WriteObject{
    public static void main(String[] args){
        try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))){
        // 将序列化输出到文件
        Person person = new Person("username", 133);
        oss.writeObject(person);
        } 
    }
}
```
反序列化步骤
- 创建一个ObjectInputStream输入流
- 调用输入流中的readObject方法。
```java
public class Person implements Serializeable{
    private String name;
    private int age;
    public Person(String name, int age){
        System.out.println("我被反序列化了。。。。。");
        this.name = name;
        this.age = age;
    }
    @Override
    public String toString(){
        return this.name + "   " + this.age;
    }
}
public class ReadObject{
    public static void main(String[] args) throws IOException {
        try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filaname))){
            Person person = ois.readObject();
            System.out.println(person);
        }
    }
}
output:
username 133
```
上面反序列化代码告诉我们，反序列化并不会调用对象的构造方法。反序列化生成的类是jvm自己生成的对象。

### 同一个对象序列化多次的机制
通过序列化算法避免了同一个对象被多次序列化，
序列化算法如下：
- 所有保存在磁盘的对象都有一个序列化编码
- 当程序试图序列化一个对象的时候，会先检查该对象是否被序列化过了，只有此对象从未被序列化过，才会将这个对象序列化为字节序列输出。
- 如果该对象已经被序列化过来，则直接输出编号
### 序列化算法存在的问题
由于Java不会重复序列化同一个对象，只会记录已经序列化的对象，如果序列化一个可变对象(对象内容可以更改)后，更改了该对象，再次序列化，并不会再次将此对象序列化，而只是保存序列化编码。
### Java可选的自定义
通过Java可选自定义序列化，即是实现readObject、writeObject方法，可以进行控制序列化方式，或者对序列化进行编码加密
```java
private void readObject(java.io.ObjectInputStream in) throws IOException;
private void writeObject(java.io.ObjectOutputStream put) throws IOException;
private void readObjectNoData() throws ObjectStreamException;
```
## 使用Externalizable：强制序列化
实现Externalizable接口，必须实现writeExternal和readeExternal方法。
```java
public interface Externalizable extends java.io.Serializable {     
    void writeExternal(ObjectOutput out) throws IOException;
    void readExternal(ObjectInput in) throws IOException ClassNotFoundException;
}
```
注意：Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象
虽然Externalizable接口带来了一定的性能提升，但变成复杂度也提高了，所以一般通过实现Serializable接口进行序列化。
## 序列化版本号serialVersionUID
我们知道，反序列化必须拥有class文件，但随着项目的升级，class文件也会升级，序列化怎么保证升级前后的兼容性呢？
java序列化提供了一个private static final long serialVersionUID 的序列化版本号，只有版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来

序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。

什么情况下需要修改serialVersionUID呢？分三种情况。
- 如果只是修改了方法，反序列化不被影响，则无需修改版本号
- 如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；
- 如果修改了非瞬态变量，则可能导致反序列化失败。如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。


参考博客:
[Java序列化看这篇就够了](https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf)
[深入分析java序列化](https://www.hollischuang.com/archives/1140)


![](https://brandonxcc.top/嘿嘿.jpg)