---
layout: '[layout]'
title: 继承、多态、封装
date: 2019-09-21 13:48:24
tags:
    - java基础
categories:
    - Java
    - Java基础
---
Java面向对象编程的三大特性：继承、多态、封装

## 1、 封装
### 1.1、封装定义
隐藏对象属性和实现细节，仅仅对外公布访问方法，控制在程序中属性的读和写的访问级别
### 1.2、封装目的
增强安全性和简化编程，使用者只需要调用暴露在外的访问方法，而不需要知道内部是如何实现的。
### 1.3、封装的基本要求
- 把所有属性私有化
- 对每个属性都要提供getter和setter方法
- 如果有一个带参的构造方法，那么还要提供一个不带参数的构造方法
- 建议重写toString方法。

### 1.4、Java权限访问关键词
public、protected和private是Java访问权限修饰词，置于类中每个成员的定义之前。每个访问权限修饰词仅仅控制它所修饰的特定定义i的访问权限。
如果不提供任何修饰词，则意味着他是包访问权限的。因此无论如何，所有事物都具有某种形式的访问权限控制。

#### 1.4.1、 public关键字
使用public关键字修饰的方法或者属性，意味着所有对象都可以访问这个方法或者属性。

#### 1.4.2、private关键字
除了包含该成员的类之外，其他任何类都无法访问这个成员。

#### 1.4.3、 protected关键字
更多使用于继承的概念。一个基类中的某个方法被protected关键字修饰，那么这个方法，可以被同包下面的类访问，或者被自己的子类访问。
```java
package test;

public class Father{
    protected void fun(){
        System.out.println("father func");
    }
}
```
```java
package test;

public class Test{
    public void test(){
        Father father = new Father();
        father.func();  //  father func
    }
}
```
```java
import test.Father;
public class Son extends Father{
    public void son(){
        fun();   // father func
    }
}
```

| 类型 | private | 无修饰 | protected | public |
| :----: | :----: | :----: | :----: | :----: |
| 同一类 |可访问 | 可访问 | 可访问 | 可访问 |
| 同一包中的子类|不可访问 | 可访问 | 可访问| 可访问|
| 同一包中的非子类| 不可访问| 可访问|可访问|可访问|
| 不同包中的子类 |不可访问|不可访问|可访问|可访问|
| 不同包中的非子类 |不可访问|不可访问|不可访问|可访问|

#### 1.4.4 注意
设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。

如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。

字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。

## 2、多态
### 2.1 向上转型
向上转型是指子类转型为父类。通俗的说就是对象变量是父类类型，但是该对象变量引用的却是子类对象。
向上转型是对父类对象方法的扩充，即是父类可以访问子类重写的方法。
向上转型是实现多态的一种机制，我们可以通过多态性提供的动态分配机制执行相应的动作，使用多态编写的代码比使用对多种类型进行检测的代码更加易于扩展和维护
```java
public Class Dog{
    public void shout(){
        System.out.println("wow wow");
    }
    public static void play(Dog dog){
        dog.shout();
    }
}

public class Kash extends Dog{
    public static void main(){
        Kash kash = new Kash();
        Dog.play(kash); // wow wow
    }
}
```
#### 2.1.1 特性
向上转型的一个重要特性就是，向上转型中会遗失子类中父类没有的方法，而子类同名的方法会覆盖父类的方法。也就是说，只存在子类中的方法，父类是不能访问的。同时，如果子类重写了父类的某些方法，父类在调用这些方法时是调用在子类定义的方法。这就是动态链接，动态调用。

### 2.2 向下转型
向下转型是指父类类型的对象转型为子类类型，也就是说，变量对象声明为子类类型，但其引用的是父类类型的对象。值得注意的是，不同于向上转型可以由编译器自动实现，向下转型需要强制转换。

#### 2.2.1 特性
向下转型有两种情况
##### 2.2.1.1 父类引用的是子类对象。
这种情况下，向下转型是安全的。编译和运行都不会出错。

```java
父类
public class Fruit {        //水果

    public void name(){
        System.out.println("This is Fruit...");
    }

}

子类
public class Apple extends Fruit{

    public void name(){
        System.out.println("This is Apple...");
    }

    public void color(){    //注意父类没有该方法
        System.out.println("Red...");
    }

}

测试类
/* TestMain.java */

public class TestMain {

    public static void main(String[] args) {
        Fruit apple = new Apple();      //apple是父类类型，引用的是子类对象
        apple.name();

        Apple fruit = (Apple)apple;     //强制转换：父类类型Fruit的对象apple向下转型为子类类型Apple
        fruit.name();
        fruit.color();                  //fruit可以访问color方法
    }

}

```
这种情况下编译器不会报错。

##### 2.2.1.2 父类引用的是父类对象
这种情况下的向下转型是不安全的。虽然编译不会报错，但运行会出错。

看到这里你也许会发觉，向下转型其实只是子类引用对象（父类类型）转为子类引用对象（子类类型），也不能是父类引用对象（父类类型）转为子类引用对象（子类类型）。试想一下，如果将父类类型的对象（水果）转为子类类型的对象（苹果），那水果就可以访问苹果特有的方法了，也就是水果是苹果，这样显然是不成立的。因为我们知道继承链上，越靠上越抽象，越往下越具体。苹果是更具体的层次，自然有一些自身特有的，而水果没有的属性。

```java

public class TestMain {

    public static void main(String[] args) {
        Fruit fruit = new Fruit();      //fruit是父类类型，引用的是父类对象
        Apple apple = (Apple)fruit;     //强制转换：Fruit类型的fruit向下转型为Apple类型
        apple.name();
        apple.color();
    }

}
```

##### 2.2.1.3 注意：关于类加载时，子类方法是否加载进内存的问题
答案是肯定的。因为在加载类文件时，除了非静态成员变量（对象特有的属性）不会被加载外，其它的都会被加载。向上转型时，对象虽然遗失了与父类不同名的子类方法，但这些方法已经被加载进了内存，只不过向上转型的对象并不能调用这些子类方法。


### 2.3 重载和重写

#### 2.3.1 重写(Override)
存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。

为了满足里式替换原则，重写有以下三个限制：
- 子类方法的访问权限必须大于等于父类方法；
- 子类方法的返回类型必须是父类方法返回类型或为其子类型
- 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。

使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。

在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有查找到再到父类中查看，看是否有继承来的方法。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：

- this.func(this)
- super.func(this)
- this.func(super)
- super.func(super)

```java
/*
    A
    |
    B
    |
    C
    |
    D
 */


class A {

    public void show(A obj) {
        System.out.println("A.show(A)");
    }

    public void show(C obj) {
        System.out.println("A.show(C)");
    }
}

class B extends A {

    @Override
    public void show(A obj) {
        System.out.println("B.show(A)");
    }
}

class C extends B {
}

class D extends C {
}


public static void main(String[] args) {

    A a = new A();
    B b = new B();
    C c = new C();
    D d = new D();

    // 在 A 中存在 show(A obj)，直接调用
    a.show(a); // A.show(A)
    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
    a.show(b); // A.show(A)
    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
    b.show(c); // A.show(C)
    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
    b.show(d); // A.show(C)

    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样
    A ba = new B();
    ba.show(c); // A.show(C)
    ba.show(d); // A.show(C)
}
```
#### 2.3.2 重载(OverLoad)
存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。

应该注意的是，返回值不同，其它都相同不算是重载。

## 3、继承
### 3.1、接口和抽象类
#### 3.1.1 接口和抽象类的好处
在面向对象的概念中，我们知道所有的对象都是通过类来描绘的，但是反过来却不是这样。并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类往往用来表征我们在对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。比如：如果我们进行一个图形编辑软件的开发，就会发现问题领域存在着圆、三角形这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域是不存在的，它就是一个抽象概念。正是因为抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的。

在面向对象领域，抽象类主要用来进行类型隐藏。我们可以构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，因此它可以是不允许修改的；同时，通过从这个抽象体派生，也可扩展此模块的行为功能。熟悉OCP的读者一定知道，为了能够实现面向对象设计的一个最核心的原则OCP( Open-Closed Principle)，抽象类是其中的关键所在。

#### 3.1.2 接口和抽象类的区别
抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。

抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。

#### 3.1.3 抽象类的使用
```java
public abstract class AbstractClassExample {

    protected int x;
    private int y;

    public abstract void func1();

    public void func2() {
        System.out.println("func2");
    }
}

public class AbstractExtendClassExample extends AbstractClassExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}


// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated
AbstractClassExample ac2 = new AbstractExtendClassExample();
ac2.func1();

```

#### 3.2.1.4 接口的使用

接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。

从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。

接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。

接口的字段默认都是 static 和 final 的。

```java
public interface InterfaceExample {

    void func1();

    default void func2(){
        System.out.println("func2");
    }

    int x = 123;
    // int y;               // Variable 'y' might not have been initialized
    public int z = 0;       // Modifier 'public' is redundant for interface fields
    // private int k = 0;   // Modifier 'private' not allowed here
    // protected int l = 0; // Modifier 'protected' not allowed here
    // private void fun3(); // Modifier 'private' not allowed here
}

public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}

// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);
```

#### 3.2.1.5 使用选择
使用接口：
- 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；
- 需要多重继承

使用抽象类
- 需要在几个相关的类中共享代码。
- 需要能控制继承来的成员的访问权限，而不是都为 public。
- 需要继承非静态和非常量字段。

在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。

[深入理解 abstract class and interfac](https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/)

### 3.2、super关键字
- 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super 函数。
- 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现
```java

public class SuperExample {

    protected int x;
    protected int y;

    public SuperExample(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void func() {
        System.out.println("SuperExample.func()");
    }
}
```
```java
public class SuperExtendExample extends SuperExample {

    private int z;

    public SuperExtendExample(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

```
```java
    @Override
    public void func() {
        super.func();
        System.out.println("SuperExtendExample.func()");
    }
}
```
```java
SuperExample e = new SuperExtendExample(1, 2, 3);
e.func();
```
```java
SuperExample.func()
SuperExtendExample.func()
```

![](https://brandonxcc.top/master.jpg)