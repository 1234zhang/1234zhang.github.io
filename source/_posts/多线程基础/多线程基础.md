---
layout: '[layout]'
title: 多线程基础
date: 2019-08-06 22:51:32
categories:
    - Java
    - 《java并发编程艺术》读书笔记
tags:
    - Java并发编程
---
## 简介
现代操作系统在运行一个程序时，会为其创建一个进程。操作系统调度的最小单位是线程，也叫轻量级进程，在一个进程中可以创建多个线程，这些线程都有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。
### 为什么要使用多线程
- 更多的处理器核心
- 更快的响应时间
- 更好的编程模型
<!-- more -->

## 线程相关性质
### 优先级以及优先级的设置
Java多线程中，通过一个整型成员变量priority来控制优先级，在线程优先级构造的时候，可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级默认是5，优先级高的线程分配时间片要多些。
- 代码示例
```java
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class Priority{
    private static volatile boolean notStart = true;
    private static volatile boolean notEnd = true;
    public static void main(String[] args) throws Exception{
        List<Job> jobs = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            int priority = i > 5 ? Thread.MAX_PRIORITY : Thread.MIN_PRIORITY;
            Job job = new Job(priority);
            jobs.add(job);
            Thread thread = new Thread(job,"thread:" + i);
            thread.setPriority(priority);
            thread.start();
        }
        notStart = false;
        TimeUnit.SECONDS.sleep(10L);
        notEnd = false;
        for (Job job : jobs) {
            System.out.println("Job Prority : " + job.priority + " count : " + job.count);
        }
    }
    static class Job implements Runnable{
        private int priority;
        private long count;
        public Job(int priority){
            this.priority = priority;
        }
        public void run(){
            while(notStart){
                Thread.yield();
            }
            while(notEnd){
                Thread.yield();
                count++;
            }
        }
    }
}

代码运行结果：
Job Prority : 1 count : 834907
Job Prority : 1 count : 835678
Job Prority : 1 count : 835257
Job Prority : 1 count : 835564
Job Prority : 1 count : 835870
Job Prority : 1 count : 835306
Job Prority : 10 count : 3679216
Job Prority : 10 count : 3682019
Job Prority : 10 count : 3686979
Job Prority : 10 count : 3684414
```
可以观察到在window下线程优先级可以作为程序正确性的依赖。但是在unix系统下，操作系统不会理会Java线程对于优先级的设定。

### 线程的状态

| 状态名称 | 说明 |
| :----: | :----:|
| NEW | 初始状态，线程被构建，但是还没有调用start()方法|
| RUNNABLE | 运行状态，Java线程将操作系统中的就绪和运行两种状态笼统的称为“运行中” |
| BLOCKED | 阻塞状态，表示线程阻塞于锁 |
|  WAITING | 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定的动作(通知或者中断) |
| TIME_WAITING | 超时等待状态，该状态不同于WAITING状态，它是可以在指定的时间自行返回的 |
| TERMINATED | 终止状态，表示当前线程已经执行完毕 | 

可以使用jstack工具(在终端中，键入jstack或者到JDK安装目录的bin目录下执行命令)查看线程的状态。
#### Java线程状态变迁
![](https://brandon-blog.oss-cn-beijing.aliyuncs.com/JMM/Java%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81.png)

### Daemon线程
Daemon线程是支持型线程，主要被用作程序中后台调度以及支持性工作。Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中finally块不一定会执行。`使用Thread.setDaemon(true)将线程设置为Daemon线程`
```java
public class Daemon{
    public static void main(String[] args) {
        Thread thread = new Thread(new DaemonTest(),"bac");
        thread.setDaemon(true);
        thread.start();
        System.out.println("main 函数结束");
    }
    private static class DaemonTest implements Runnable{
        public void run(){
            try{
                Thread.sleep(1000);
            }catch (Exception e){
                e.printStackTrace();
            }finally{
                System.out.println("hello world");
            }
        }
    }
}
```
### 中断理解
中断可以视为线程的一个标识位属性，表示一个运行中的线程是否被其他线程进行了中断。线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断。也可以调用静态方法
- 要想线程接收到中断信号，才能将线程中断成功
```java
public class InterruptTest{
    public static void main(String[] args) throws Exception{
        Thread thread = new Thread(new TestThread1(), "abc");
        thread.start();
        System.out.println(thread.isInterrupted());
        thread.interrupt();
        System.out.println("main函数休眠之前：" + thread.isInterrupted()); // 此时线程为中断完全，但是中断状态已经被改变，之后会中中断该线程
        Thread.sleep(1000);  // 令main线程休眠之后，thread线程完成中断，thread就完全被停止
        System.out.println("main函数休眠之后：" + thread.isInterrupted());  // 可以认为thread线程未开始，如果thread线程未开始，isInterrupted返回的是false
    }
    private static class TestThread1 implements Runnable{
        public void run(){
            try{
                for (int i = 0; i < 100; i++) {
                    System.out.println(i);
                    if(Thread.currentThread().isInterrupted()){
                        System.out.println("线程被中断");
                        return;
                    }
                }
            }finally{
                System.out.println("线程被中断：" + Thread.currentThread().isInterrupted());
            }
        }
    }
}

运行结果：
false
0
线程被中断
线程被中断：true
main函数休眠之前：true
main函数休眠之后：false
```
- 中断标识符被清除
许多声明抛出InterruptedException的方法，这些方法抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识符位清除，此时isInterrupted()方法将会返回false。
### 线程等待/通知机制
| 方法名称 | 描述 |
| :----: | :----: |
| notify | 通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是该线程获取到了对象的锁|
| notifyAll | 通知所有等待在该对象上的线程 |
| wait | 调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象锁 | 
| wait(long) | 超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回 |
- 机制原理
是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。

### ThreadLocal的使用
THreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的值。