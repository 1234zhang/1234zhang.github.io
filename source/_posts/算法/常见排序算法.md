---
layout: '[layout]'
title: 常见排序算法
date: 2019-10-03 15:36:09
tags:
    - 算法
categories:
    - Java
    - Java基础
---
## 冒泡排序
算法描述：
- 比较相邻的两个元素。如果后一个元素比前一个元素大就交换这两个元素的位置。
- 对每个一个元素做相同的动作，每次都从第一个元素开始直到最后一个。每一轮都可以保证最后一个元素最大。这里我们可以定义一个指针，指向最后一个位置，每一轮结束之后指针前移一位(可以减少一点的循环次数)。
下面是代码排序代码:
```java
package sort;
// 下面代码省略main函数，只留下算法核心
import java.util.*;
public class MaopaoSort{
    public static void sort(int[] nums){
        int n = nums.length - 1;
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < n; j++) {
                if(nums[j] > nums[j + 1]){
                    exchange(nums, j, j+1);
                }
            }
            n -= 1;
        }
    }
    public static void exchange(int[] nums, int start, int end){
        int flag = nums[start];
        nums[start] = nums[end];
        nums[end] = flag;
    }
}
```
## 插入排序
插入排序算法步骤
- 从第一个元素开始，该元素可以被认为已经排序好的
- 取下一个元素，在已经排序好的前序序列中，从后向前扫描；
- 如果(已经排序好的元素)该元素大于新元素，则该元素移向下一个位置
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤2~5。

![](https://brandonxcc.top/插入排序.gif)
插入排序核心代码
```java
package sort;
import java.util.*;
public class InsertSort{

    public static void sort(int[] nums){
        for (int i = 1; i < nums.length; i++) {
            int flag = i;
            while(flag >= 1){
                if(nums[flag] < nums[flag - 1]){
                    exchange(nums, flag, flag - 1);
                }
                flag--;
            }
        }
    }
    public static void exchange(int[] nums, int start, int end){
        int flag = nums[start];
        nums[start] = nums[end];
        nums[end] = flag;
    }
}
```

## 选择排序
![](https://brandonxcc.top/选择排序.gif)

下面是选择排序的核心代码
```java

package sort;
import java.util.*;

public class ChoiceSort{
    public static void sort(int[] nums){
        for (int i = 0; i < nums.length; i++) {
            int j = i;
            int minPosition = i;
            while(j < nums.length){
                if(nums[j] < nums[minPosition]){
                    minPosition = j;
                }
                j++;
            }
            exchange(nums, i, minPosition);
        }
    }

    public static void exchange(int[] nums, int start, int end){
        int flag = nums[start];
        nums[start] = nums[end];
        nums[end] = flag;
    }
}
```

## 希尔排序
希尔排序就是升级版的插入排序，简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。

我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。

下面是希尔排序的动画演示：

![](https://brandonxcc.top/希尔排序.gif)
下面是希尔排序的核心代码
```java
package sort;
import java.util.*;

public class ShellSort{
    public static void sort(int[] nums){
        int k = nums.length / 2;
        while(k > 0){
            for (int i = k; i < nums.length; i++) {
               int j = i;
               while(j >= k){
                   if(nums[j] < nums[j - k]){
                       exchange(nums, j, j - k);
                   }
                   j--;
               }
            }
            k = k / 2;
        }
    }

    public static void exchange(int[] nums, int start, int end){
        int flag = nums[start];
        nums[start] = nums[end];
        nums[end] = flag;
    }
}
```

## 快速排序

快速排序也使用了分治的思想，下面是算法步骤
- 从数列中挑出一个元素，称为 “基准”（pivot）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

![](https://brandonxcc.top/快速排序.gif)

下面是快速排序的具体算法步骤：
```java

package sort;
import java.util.*;

public class QuickSort{
    public static void sort(int[] nums){
        int left = 0;
        int right = nums.length - 1;
        int flag = nums[0];
        while(left < right){
            // 最好从右边开始
            while(left < right && flag <= nums[right]) right--;
            while(left < right && flag >= nums[left]) left++;
            exchange(nums, left, right);
        }
        // 交换基准数到中间
        exchange(nums, 0, left);
        // 根据基准数的位置，将大数组分为左右两个数组
        sort(nums, 0, left - 1);
        sort(nums, left + 1, nums.length - 1);
    }

    public static void sort(int[] nums, int left, int right){
        if(left >= right){
            return;
        }
        int i = left;
        int j = right;
        int flag = nums[left];
        while(i < j){
            while(i < j && flag <= nums[j]) j--;
            while(i < j && flag >= nums[i]) i++;
            exchange(nums, i, j);
        }
        exchange(nums, left, i );
        sort(nums, left, i - 1);
        sort(nums, i + 1, right);
    }

    public static void exchange(int[] nums, int start, int end){
        int flag = nums[start];
        nums[start] = nums[end];
        nums[end] = flag;
    }
}
```


## 并归排序
并归排序就是将一个数组分为多个小数组，进行递归排序。并归排序体现了分治算法的核心
- 分： 将一个完整的数组，分为多个小数组
- 治： 每个小数组内部进行排序，最后还原成完整数组也是有序的

![](https://brandonxcc.top/并归排序.png)
![](https://brandonxcc.top/并归排序2.png)

下面是并归排序的动画演示

![](https://brandonxcc.top/并归排序动画.gif)
并归排序的核心代码
```java
package sort;
import java.util.*;
public class MergeSort{
    public static void sort(int[] nums){
        int[] temp = new int[nums.length];
        sort(nums, 0, nums.length - 1, temp);
    }
    public static void sort(int[] nums, int begin, int end, int[] temp){
        if(begin < end){
            int mid = (begin + end)/2;
            sort(nums, begin, mid, temp); //左边并归排序，使得左子序列有序
            sort(nums, mid + 1, end, temp); // 右边并归排序，使得右子序列有序
            merge(nums, temp, begin, mid, end);
        }
    }
    public static void merge(int[] nums, int[] temp, int start, int mid, int end){
        int i = start;// 左序列指针
        int j = mid + 1; // 右序列指针
        int t = 0; // 临时指针
        while(i <= mid && j <= end){
            if(nums[i] <= nums[j]){
                temp[t++] = nums[i++];
            }else{
                temp[t++] = nums[j++];
            }
        }
        if(i <= mid){ // 左边剩余元素填充进temp
            while(i <= mid){
                temp[t++] = nums[i++];
            }
        }
        if(j <= end){ // 右边剩余元素填充进temp
            while(j <= end){
                temp[t++] = nums[j++];
            }
        }
        t = 0;
        while(start <= end){ // 将temp中的元素全部拷贝回原来数组
            nums[start++] = temp[t++];
        }
    }
}
```

## 堆排序
[图解堆排序](https://www.cnblogs.com/chengxiao/p/6129630.html)

## 排序算法的特性
![](https://brandonxcc.top/算法特性.png)

### 相关概念
- 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面
- 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数

![](https://brandonxcc.top/十月三号.jpg)
