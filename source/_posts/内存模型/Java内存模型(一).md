---
title: Java内存模型(一)
date: 2019-08-04 16:06:15
categories:
    - Java
    - 《java并发编程艺术》读书笔记
tags:
    - Java并发编程
---
一直在看Java多线程，就没有系统的写过总结跟读书笔记，正好在暑假有多的时间，可以系统的学习一下Java多线程，找到一本《Java并发编程艺术》也是学长比较推荐的一本书吧。好好读一下， 打算是，学完这本书之后能够在实际项目中运用起来。自己一直有一个疑惑，如何在实战项目中运用并发的知识，感觉一直好像没怎么使用过，所以一直比较疑惑。这个是书的第三章，Java的内存模型。Java线程之间的通信对程序员完全透明，内存可见性问题很容易困扰Java程序员


## 摘要
- Java内存模型的基础，介绍内存模型相关概念
- Java内存模型的顺序一致性，主要介绍重排序与顺序一致性内存模型
- 同步原语，主要包括synchronized、volatile和final的内存语义以及重排序规则在处理器中的实现。
- Java内存模型的设计

<!-- more -->


## Java内存模型的基础
### 并发编程的两个问题
```
1.线程之间如何通信
2.线程之间如何同步
```
- 线程之间的通信是指以何种机制来交换信息(主要方法：共享内存和消息传递)
- 线程之间的同步是指：用于控制不同线程之间操作发生相对顺序的机制
- Java采用的是共享内存模型，Java线程之间通信总是隐式进行，整个通信过程对程序员完全透明。
### Java内存模型的抽象结构
- Java中所有实例域、静态域和数组元素都存储在一堆内存中，堆内存在线程之间共享。局部变量，方法定义参数和异常处理器参数不会在线程之间共享。
- Java线程之间的通信由Java内存模型(JMM)控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。
- 内存模型的抽象结构：JMM定义了线程与主内存之间的抽象关系，线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽线概念，并不是真实存在的。
    - ![](https://brandon-blog.oss-cn-beijing.aliyuncs.com/JMM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%8A%BD%E8%B1%A1%E7%BB%93%E6%9E%84.png)
- Java线程之间的通信过程：
    - 线程A把本地内存A中更新过的共享变量刷新到主内存中去
    - 线程B到主内存中去读取线程A之前更新过的共享变量
### 从源代码到指令序列的重排序
- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能在乱序执行。
- JMM属于语言级的内存模型，他确保在不同的编译器和不同的处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。
### 并发编程模型的分类
- 现代的处理器使用写缓冲区临时保存向内存写入的数据。但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写一致。
- 为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序
- 内存屏障类型：
    - LoadLoad：load1; LoadLoad; Load2, 确保Load1数据的装载先于Load2以所有后续装载指令的装载
    - StoreStore：Store1; StoreStore; Store2, 确保Store1数据对其他处理器可见(刷新到内存)先于Store2及所有后续存储指令的存储
    - LoadStore：Load1; LoadStore; Store2, 确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存
    - StoreLoad：Store1;StoreLoad;Load2，确保Store1数据对其他处理器变得可见(指刷新到内存)先于Load2及所有后续装载指令的装载。StoreLoad 会使该屏障之前的所有内存访问指令(存储和装载指令)完成之后，才执行该屏障之后的内存访问指令。
### happens-before简介
- happens-before规则：
    - 程序顺序规则：一个线程中的每个操作，hanppens-before于该线程中任意后续操作
    - 监视器规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
    - volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
    - 传递性：如果A happens-before B，而B happens-before C 那么A happens-before C
- happens-before 与JMM之间的关系
    - ![](https://brandon-blog.oss-cn-beijing.aliyuncs.com/JMM/JMM%E4%B8%8Ehappens-before%E7%9A%84%E5%85%B3%E7%B3%BB.png)  