---
layout: '[layout]'
title: Java内存模型(二)
date: 2019-08-04 19:39:46
categories:
    - Java
    - 《java并发编程艺术》读书笔记
tags:
    - Java并发编程
---

上一篇博客主要写了关于JMM的相关基础概念。这篇博客主要是写关于JMM重排序的相关概念。

## 简介：
- 重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。
<!-- more -->

## 数据依赖性
### 概念
如果两个操作访问同一个变量，而且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。下面三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会改变。

| 名称 | 代码示例 | 说明 |
| :----------: | :----------: | :-----------: |
| 写后读 | a = 1; b = a; | 写一个变量之后，再读这个变量|
| 写后写 | a = 1; a = 2; | 写一个变量之后，再写这个变量|
| 读后写 | a = b; b = 1; | 读一个变量之后，再写这个变量|

### 注意
- 编译器和处理器可能会对操作进行重排序。编译器和处理器再重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作执行顺序。
- 数据依赖性仅仅针对单个处理器中执行的指令序列和单个线程中执行的操作。

## as-if-serial语句

### 概念：
as-if-serial意思是：不论怎么重排序(编译器和处理器为了提高并行度),(单线程)程序的执行结果不能被改变。
### 注意
为了遵守as-if-serial编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。
```java
double pi = 3.14;  // A
double r = 2;   // B
double area = pi * r * r; // c
```
A,B之间没有数据依赖关系，编译器可以重排序A、B的执行顺序，而对最终结果们没有影响，但A、C和B、C之间都有数据依赖关系，编译器就不能重排序他们的执行顺序。
### 说明
as-if-serial给单线程程序员一个幻境：认为程序是按照顺序执行的。as-if-serial 使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。

## 程序顺序规则

### 说明
JMM要求前一个操作(执行结果)对后一个可见，而且前一个操作按照顺序排在第二个操作之前。重排序之后的执行结果，与操作A和B按照happens-before操作(即是按照代码顺序执行)执行结果一致，那么JMM就允许这个重排序的发生。
### 硬件和软件的目标
在保证执行结果不变的前提之下，尽可能提高并发度。

## 重排序对多线程的影响
``` java
class ReorderExample{
    int a = 0;
    boolean flag = false;
    public void writer(){
        a = 1; // 1
        flag = true; //2
    }
    public void reader(){
        if(flag){     // 3
            int i = a * a;   //4
        }
    }
} 
```
因为1、2和3、4两对关系之间都没有数据依赖性，编译器可以对这两对操作进行重排序，
- 1、2之间进行重排序
线程A首先对flag复制为true，但是还没有对a进行赋值。线程B读取flag变量为true，线程B继续读取变量a，此时变量a还没有被赋值，在这里多线程语义就被重排序破坏。
- 3、4之间重排序
操作3和操作4之间存在控制依赖关系。编译器和处理器为了克服因为控制依赖而造成的对并发度的影响采用一种猜测执行的方式。例如：处理器提前读取并计算a*a，将计算结果存放在名为重排序缓冲的硬件缓存中。当操作3的条件判断为真时候，就将计算结果写入i中，但这种猜测执行的方式，破坏了多线程程序的语义。