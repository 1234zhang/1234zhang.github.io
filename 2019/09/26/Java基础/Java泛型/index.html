<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content="" />
  
  <title>Java泛型</title>
  <meta name="author" content="brandon">
  <meta name="description" content="study hard">
  
  
  <meta property="og:title" content="Java泛型"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="brandon"/>
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="brandon" type="application/atom+xml">
  <link rel="stylesheet" href="/css/m.min.css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <a id="top"></a>
  <div id="main">
    <div class="main-ctnr">
      <div class="behind">
  <a href="/" class="back black-color">
    <svg class="i-close" viewBox="0 0 32 32" width="22" height="22" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
        <path d="M2 30 L30 2 M30 30 L2 2"></path>
    </svg>
  </a>
  <div class="description">
    &nbsp;
  </div>
</div>


  <article class="standard [layout]">
    <div class="title">
      
  
    <h1 class="page-title center">
        Java泛型
    </h1>
  


    </div>
    <div class="meta center">
      <time datetime="2019-09-26T00:37:10.000Z" itemprop="datePublished">
  <svg class="i-calendar" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
    <path d="M2 6 L2 30 30 30 30 6 Z M2 15 L30 15 M7 3 L7 9 M13 3 L13 9 M19 3 L19 9 M25 3 L25 9"></path>
  </svg>
  &nbsp;
  2019-09-26
</time>


    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/categories/Java/">Java</a>·<a href="/categories/Java/Java基础/">Java基础</a>




    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/tags/java基础/">java基础</a>


    </div>
    <hr>
    
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java泛型"><span class="toc-text">Java泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型的声明"><span class="toc-text">泛型的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型类"><span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型接口"><span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型方法"><span class="toc-text">泛型方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型标识"><span class="toc-text">泛型标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通配符"><span class="toc-text">通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#无界通配符"><span class="toc-text">无界通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#上界通配符"><span class="toc-text">上界通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#下届通配符"><span class="toc-text">下届通配符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型不是协变的"><span class="toc-text">泛型不是协变的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型的擦除"><span class="toc-text">泛型的擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#参数类型替换"><span class="toc-text">参数类型替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型转换"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#桥接方法"><span class="toc-text">桥接方法</span></a></li></ol></li></ol></li></ol>
    
    <div class="picture-container">
      
    </div>
    <p>Java泛型是Java5引入的重要特性之一，无论是语法还是还是运用的环境中，Java泛型都与C++模板类似。但是这种相似仅仅只是停留在表面，Java语言的泛型完全通过编译器实现，由编译器执行类型检查和类型推断，然后生成普通的非泛型字节码(class文件)。这种实现技术称之为类型擦除(编译器使用泛型信息保证类型安全，然后生成字节码将其擦除)</p>
<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h3 id="泛型的声明"><a href="#泛型的声明" class="headerlink" title="泛型的声明"></a>泛型的声明</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型类和普通类的声明一样，只是在类名后面加上了类型表示。泛型类可以有一个或者多个类型表示，不同的类型表示之间使用逗号隔开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.t = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br><span class="line">     Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">     integerBox.add(<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">     stringBox.add(<span class="keyword">new</span> String(<span class="string">"Hello World"</span>));</span><br><span class="line"></span><br><span class="line">     System.out.printf(<span class="string">"Integer Value :%d\n\n"</span>, integerBox.get());</span><br><span class="line">     System.out.printf(<span class="string">"String Value :%s\n"</span>, stringBox.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer Value :<span class="number">10</span></span><br><span class="line">String Value :Hello World</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>泛型接口在声明接口的时候指定，类在继承接口的时候要补充泛型类型<br>定义泛型接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个类实现这个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InfoImp implements Info&lt;String&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可在实现这个泛型接口到时候不补充泛型类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InfoImp&lt;T&gt; implements Info&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>在普通方法声明上加入泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">( E[] inputArray )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">        System.out.printf( <span class="string">"%s "</span>, element );</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实现</span><br><span class="line"><span class="comment">// Create arrays of Integer, Double and Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">Double[] doubleArray = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span> &#125;;</span><br><span class="line">Character[] charArray = &#123; <span class="string">'H'</span>, <span class="string">'E'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, <span class="string">'O'</span> &#125;;</span><br><span class="line"></span><br><span class="line">System.out.println( <span class="string">"Array integerArray contains:"</span> );</span><br><span class="line">printArray( intArray  ); <span class="comment">// pass an Integer array</span></span><br><span class="line"></span><br><span class="line">System.out.println( <span class="string">"\nArray doubleArray contains:"</span> );</span><br><span class="line">printArray( doubleArray ); <span class="comment">// pass a Double array</span></span><br><span class="line"></span><br><span class="line">System.out.println( <span class="string">"\nArray characterArray contains:"</span> );</span><br><span class="line">printArray( charArray ); <span class="comment">// pass a Character array</span></span><br></pre></td></tr></table></figure>

<p>泛型方法的声明格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[权限] [修饰符] [泛型] [返回值] [方法名]  (    [参数列表]   ) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  &lt; E &gt;   <span class="function"><span class="keyword">void</span>   <span class="title">printArray</span><span class="params">( E[] inputArray )</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>泛型的声明，必须在方法的修饰符（public,static,final,abstract等）之后，返回值声明之前。可以声明多个泛型，用逗号隔开。泛型的声明要用<code>&lt;&gt;</code>包裹。</p>
<h3 id="泛型标识"><a href="#泛型标识" class="headerlink" title="泛型标识"></a>泛型标识</h3><ul>
<li>E - Element (在集合中使用，因为集合中存放的是元素)</li>
<li>T - Type（Java 类）</li>
<li>K - Key（键）</li>
<li>V - Value（值）</li>
<li>N - Number（数值类型）</li>
<li>? - 表示不确定的java类型</li>
<li>S、U、V - 2nd、3rd、4th types</li>
</ul>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>泛型中<code>?</code>是通配符，表示未知类型。通配符可以用于参数、属性、局部变量或者返回值的类型，但是不能用于泛型方法调用或者创建泛型类实例的类型参数</p>
<h4 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h4><p>单独使用<code>?</code>表示无界通配符，例如List&lt;?&gt;,表示未知类型list，下面两个场景适合使用无界通配符：</p>
<ul>
<li>如果编写一个方法，只使用Object类中的功能，使用List&lt;?&gt; 代替List<object>;</object></li>
<li>当使用泛型类型的方法不依赖参数类型时，例如只使用到List.size或者List.clear方法。事实上Class<?> 方法也经常出现，这是因为Class<t>大多数方法不依赖T。
<?> 无界操作符只能用于接收，不能用作定义<br>正确例子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;?&gt; box = <span class="keyword">new</span> Box&lt;String&gt;();  <span class="comment">// 可以表示为将后面的类型转换到前面类型</span></span><br></pre></td></tr></table></figure>

</t></li>
</ul>
<p>错误例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;?&gt; </span>&#123;&#125; <span class="comment">//错误的泛型类定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;?&gt; <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(? helloString)</span> </span>&#123;&#125; <span class="comment">//错误的泛型方法定义</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Box</span>&lt;?&gt; </span>&#123;&#125; <span class="comment">//错误的泛型接口定义</span></span><br></pre></td></tr></table></figure>

<h4 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h4><p>上界通配符可以放宽对变量的限制。语法为<code>? extends superType</code>, superType可以是类或者接口。如果想写一个对List<integer>, List<double>, List<number>都适用的方法，就可以适用List&lt;? extends Number&gt;。</number></double></integer></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sumOfList</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> s = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Number n : list)</span><br><span class="line">        s += n.doubleValue();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="下届通配符"><a href="#下届通配符" class="headerlink" title="下届通配符"></a>下届通配符</h4><p>下届通配符可以限制为特定的类型或该类型的父类。语法为<code>? super superType</code>想写一个方法添加Integer到对象list中，可以是List<integer>, List<double>, List<object>。都可以使用List&lt;? super Integer&gt;。</object></double></integer></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNumbers</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型不是协变的"><a href="#泛型不是协变的" class="headerlink" title="泛型不是协变的"></a>泛型不是协变的</h3><p>虽然将泛型看作数组的抽象对泛型的理解有帮助，但是泛型还具备了数组所不具备的特殊性质。Java中数组是可以协变(covariant)。也就是说，当Integer扩展了Number，那么不仅Integer 扩展了Number，而且Integer[] 也拓展了 Number[ ]。正式的说，Number是Integer的基类，那么Number[] 也是Integer[] 的基类。但是这个并不适用与泛型，这就是因为泛型的类型安全机制。如果泛型是协变的能够将List<integer>赋值给List<number>,那么下列代码就允许将非Integer放入List<integer>中</integer></number></integer></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line">List&lt;Number&gt; ln = li; <span class="comment">// illegal </span></span><br><span class="line">ln.add(<span class="keyword">new</span> Float(<span class="number">3.1415</span>));</span><br></pre></td></tr></table></figure>

<p>因为ln是List<number>类型的，所以向里面添加float是完全合法的。但是如果 ln是 li的别名，那么这就破坏了蕴含在 li定义中的类型安全承诺 —— 它是一个整数列表，这就是泛型类型不能协变的原因</number></p>
<p>数组能够协变，而泛型不能协变的另一个后果是，不能实例化泛型类型的数组。例如<code>new List&lt;String&gt;[size].</code>, 这是不合法的，因为Java的泛型是用擦除实现的，在运行时就会把类型擦掉。那么运行时就会被看作List[]，这个违背了Java的<code>类型安全</code>的原则。<br>如果我们作死允许声明泛型数组，会发生什么事情么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// illegal </span></span><br><span class="line">Object[] oa = lsa;  <span class="comment">// OK because List&lt;String&gt; is a subtype of Object </span></span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>)); </span><br><span class="line">oa[<span class="number">0</span>] = li; </span><br><span class="line">String s = lsa[<span class="number">0</span>].get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在第一行定义的时候，编译器就会报错。最后一行将抛出 ClassCastException，因为这样将把 List<integer>填入本应是 List<string>的位置。因为数组协变会破坏泛型的类型安全，所以不允许实例化泛型类型的数组（除非类型参数是未绑定的通配符，比如 List&lt;?&gt;）。</string></integer></p>
<h3 id="泛型的擦除"><a href="#泛型的擦除" class="headerlink" title="泛型的擦除"></a>泛型的擦除</h3><p>如果没有了解过泛型擦除的人，会将List<string>和List<integer>的Class认作不一致。</integer></string></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(strList.getClass().getName());   <span class="comment">// java.util.ArrayList</span></span><br><span class="line">System.out.println(intList.getClass().getName());   <span class="comment">// java.util.ArrayList</span></span><br><span class="line">System.out.println(strList.getClass() == intList.getClass());   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在编译时期，List<string> 和List<integer> 是不一样的，但是在运行时期，两个又一样了。背后的原因就是类型擦除。</integer></string></p>
<p>Java泛型添加是为了提供编译时期的类型检查和支持泛型编程，并没有运行时期的支持。所以Java编译器会用类型擦除来删除所有泛型类型检查代码，并在必要时插入强制类型转换。类型擦除确保不为参数类型创建新类，所以<code>ArrayList&lt;E&gt;</code>的Class类型还是<code>java.uitl.ArrayList</code>，相应的不会增加运行时的开销。Java编译器在应用泛型类型擦除的时候有以下行为：</p>
<ul>
<li>将泛型中所有参数化类型替换为泛型边界，如果参数化类型是无界的，则替换为 Object 类型。字节码中没有任何泛型的相关信息。</li>
<li>为了类型安全，在必要时插入类型转换代码。</li>
<li>生成桥接方法来保持泛型类型的多态性。</li>
</ul>
<h4 id="参数类型替换"><a href="#参数类型替换" class="headerlink" title="参数类型替换"></a>参数类型替换</h4><p>对于无界参数类型，类型擦除时候会替换为Object。<br>下面单列表节点类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过类型擦除之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于有界参数类型来说，类型擦除之后会替换为第一个边界</p>
<p>如果节点类使用有界参数类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过类型擦除之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Comparable data, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>经过参数化类型替换后，在使用泛型相关内容时，通常需要添加类型转换代码，看下面代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;String&gt; node = <span class="keyword">new</span> Node&lt;&gt;(<span class="string">"Hello"</span>, <span class="keyword">null</span>);</span><br><span class="line">String data = node.getData();   <span class="comment">// 实际上 node.getData() 返回的是 Object 类型</span></span><br></pre></td></tr></table></figure>

<p>所以编译器还会插入类型转换代码，编译后如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Node node = <span class="keyword">new</span> Node(<span class="string">"Hello"</span>, <span class="keyword">null</span>);</span><br><span class="line">String data = (String) node.getData();</span><br></pre></td></tr></table></figure>

<h4 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h4><p>当编译一个类继承泛型类或泛型接口，在类型擦除的过程中编译器会生成一个合成方法，也称为桥接方法。</p>
<p>看下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span> &lt;<span class="title">A</span>&gt; </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">( A that)</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumericValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span> &lt;<span class="title">NumericValue</span>&gt; </span>&#123; </span><br><span class="line">    priva te <span class="keyword">byte</span> value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">NumericValue</span> <span class="params">(<span class="keyword">byte</span> value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">byte</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">( NumericValue t hat)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.value - that.value; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过参数类型化之后，Comparable接口的compareTo方法的参数类型为Object，而NumericValue也需要实现compareTo(Object) 方法，经过类型擦除之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object that)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumericVlaue</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumericVlaue</span><span class="params">(<span class="keyword">byte</span> vlaue)</span></span>&#123;<span class="keyword">this</span>.value = value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.value;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(NumericValue that)</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">byte</span> - that.<span class="keyword">byte</span>;&#125;</span><br><span class="line">    <span class="comment">// 新和成的桥接方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object that)</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.compareTo(NumericValue(that));&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型擦除之后<code>NumericValue.compareTo(NumericValue that)</code>不再是接口实现的方法，这是擦除类型的一个副作用：两个方法在接口的实现类中，在类型擦除之前具有相同的签名，而在类型擦除之后具有不同的签名。<br>为了让NumericValue依然正确地实现实现（Comparable）接口，编译器添加了一个桥接方法，和接口的方法签名相同，桥接方法委托给原始类中的原始方法。<br>虽然存在桥接方法，但在一般情况之下，编译器不允许我们调用桥接方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NumericValue value = <span class="keyword">new</span> NumericValue((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">value.compareTo(value); <span class="comment">// OK</span></span><br><span class="line">value.compareTo(<span class="string">"abc"</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>但是还有两个方法可以调用桥接方法，使用原始类型(Raw Type)或者反射，但是原始类型中的桥接方法有强制类型转换，所以传其他类型会有运行报错。下面是使用桥接方法的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparable comparable = <span class="keyword">new</span> NumericValue((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">comparable.compareTo(comparable); <span class="comment">// OK</span></span><br><span class="line">comparable.compareTo(<span class="string">"abc"</span>);    <span class="comment">// OK at compile time, throws ClassCastException at run time</span></span><br></pre></td></tr></table></figure>

<p>下面是参照的三篇博客：</p>
<ul>
<li><a href="https://sumygg.com/2015/12/15/java-generic-type-one-two-and-three/" target="_blank" rel="noopener">泛型声明</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-jtp01255.html" target="_blank" rel="noopener">泛型不是协变的</a></li>
<li><a href="https://johnnyshieh.me/posts/java-generics/" target="_blank" rel="noopener">泛型的类型擦除</a></li>
</ul>
<p><img src="https://brandonxcc.top/%E5%93%88%E5%93%88%E5%93%88%E5%93%88%E5%93%88%E5%93%88%E5%93%88.jpg" alt></p>


  </article>
  </script>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  <div class="busuanzi center">
    页阅读量:&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;・&nbsp;
    站访问量:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;・&nbsp;
    站访客数:&nbsp;<span id="busuanzi_value_site_uv"></span>
  </div>


    





    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot">
    <div class="firstrow">
        <a href="#top" target="_self">
        <svg class="i-caret-right" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M10 30 L26 16 10 2 Z"></path>
        </svg>
        </a>
        © XXX 2016-2020
    </div>
    <div class="secondrow">
        <a href="https://github.com/gaoryrt/hexo-theme-pln" target="_blank" rel="noopener">
        Theme Pln
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/js/search.min.js"></script>
<script type="text/javascript">

// disqus scripts


// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-z16"},"display":{"position":"left","width":150,"height":345},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
