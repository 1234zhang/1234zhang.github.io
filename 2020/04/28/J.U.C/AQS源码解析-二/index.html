<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="AQS源码解析(二)"/><meta name="keywords" content="java并发, brandon" /><link rel="alternate" href="/atom.xml" title="brandon">
<link rel="canonical" href="https://1234zhang.github.io/2020/04/28/J.U.C/AQS源码解析-二/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":"","toc":"","fancybox":"","pjax":"","latex":""};
</script>

    <title>AQS源码解析(二) - brandon</title>
  <meta name="generator" content="Hexo 4.2.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">brandon</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">brandon</a>
</div>

<nav class="site-navbar"></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">AQS源码解析(二)
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-04-28
        </span><span class="post-category">
            <a href="/categories/Java/">Java</a>
            <a href="/categories/Java/JUC/">JUC</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看了上篇的描述之后，我觉得我应该已经对AQS的大概运行过程有了一个初步的了解，当然这远远不够。快扶我起来，我还能继续学！<br>这篇将继续写有关AQS的相关知识，有关于公平与非公平锁，带条件的锁。还有关于中断的一些知识。废话不多说。咱们走着。</p>
<h1 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h1><p>首先咱们来谈谈关于Java的公平锁与非公平锁。公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体的吞吐效率相对非公平锁要低，等待队列中除了第一个以外的所有线程都要阻塞，cpu唤醒阻塞线程的开销比较大。</p>
<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到的时候才会到队尾等待。但如果此时锁正好可以用了，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁先获取到资源的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率比较高。缺点是有些处于等待队列的线程可能被饿死，获取等待很久才获取到锁。</p>
<p>下图是公平锁</p>
<p><img src="https://brandonxcc.top/Java%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="avatar"></p>
<p>下图是非公平锁</p>
<p><img src="https://brandonxcc.top/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="avatar"></p>
<h2 id="关于源码"><a href="#关于源码" class="headerlink" title="关于源码"></a>关于源码</h2><p>在ReentrantLock中，内部将两种锁都实现了。其中默认的是非公平锁，如果要使用公平锁，只需要在创建的时候带上true参数就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，我们再看看线程来的时候，公平锁与非公平锁是如何争夺资源的:</p>
<p>公平锁的lock方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里有一个判断阻塞队列中是否有元素</span></span><br><span class="line">            <span class="comment">// 如果有元素，则老老实实的去排队</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是非公平锁的lock方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>非公平锁与公平锁的区别：</p>
<ul>
<li>非公平锁在调用lock后，就会使用CAS进行一次枪锁，如果这个时候恰巧没有被占用，那么就直接获取锁然后返回了</li>
<li>公平锁在CAS失败之后，和公平锁一样会调用tryAcquire方法，在tryAcquire方法中，如果发现这个锁被释放了，那么再进行一次CAS枪锁，如果失败就要在阻塞队列的队尾进行等待。公平锁会判断等待队列是否有线程处于等待状态，如果有则不去获取锁，直接到队尾进行等待。</li>
</ul>
<p>公平锁与非公平锁就这两点区别，如果两次CAS都不成功，都要到队尾进行等待被唤醒。</p>
<h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><p>Condition的使用场景，Condition经常使用在生产者消费者的场景中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 依赖于lock来产生</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">                notFull.await();  <span class="comment">// 队列已经满了，直到not full 才能继续生产。</span></span><br><span class="line">            &#125;</span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();  <span class="comment">// 生产成功， 队列已经not Empty了。</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[getptr];</span><br><span class="line">            <span class="keyword">if</span> (++getptr == items.length) getptr = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal(); <span class="comment">// 被消费了一个，已经not full了，可以开始生产。</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到，在使用condition时候，必须先持有相应的锁。这个和Object类中的方法有相似的语义，需要先持有某个对象的监视器锁才可以执行wait()、notify()或者notifyAll()方法。</p>
<p>condition是依赖于ReentrantLock的，不管是调用await进入等待还是signal唤醒，都必须获取到锁才能进行操作。</p>
<p>每个ReentrantLock实例可以通过多次调用newCondition产生多个ConditionObject的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化一个ConditionObject</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要熟悉Condition，我们首先要关注一下Condition实现类AbstractQueueSynchronizer类中的ConditionObject。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">111111111111</span>;</span><br><span class="line">    <span class="comment">// 条件队列中的第一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// 条件队列中最后一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在学习reentrantLock的时候，我们知道了阻塞队列，在学习condition的时候，我们要引入一个条件队列</p>
<p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer-2/aqs2-2.png" alt="条件队列"></p>
<p>首先解释上面这张图</p>
<ol>
<li>条件队列和阻塞队列都是Node的实例，条件队列中的Node要转移到阻塞队列中去</li>
<li>ReentrantLock实例可以通过调用newCondition()来实现多个Condition实列，这里对应的是Condition1和Condition2表示生成的多个实例。ConditionObject只有两个属性firstWaiter和lastWaiter</li>
<li>每个condition都有一个关联的条件队列，比如线程1调用Condition1.await()方法，就会将线程1包装进Node实例中，然后加入到condition1这个条件队列中，并阻塞在这里，不再继续往下执行，条件队列是一个单向队列</li>
<li>调用condition1.signal()触发一次唤醒，此时唤醒的是队头，会将condition1对应条件队列的firstWaiter(队头)加入到阻塞队列队尾中，等待获取锁，获取锁之后，await方法才会返回，继续往下执行(这里要结合消费者和生产者的模型来看)。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里就要简单回顾一下Node的属性了</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus; <span class="comment">// 可取值0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱节点</span></span><br><span class="line"><span class="keyword">volatile</span> Node next; <span class="comment">// 后继节点</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread; <span class="comment">// 当前线程</span></span><br><span class="line">Node nextWaiter; <span class="comment">// 后继等待的节点</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prev和next实现双向链表，nextWaiter实现条件队列的单向链表</span><br></pre></td></tr></table></figure>

<h2 id="await方法分析"><a href="#await方法分析" class="headerlink" title="await方法分析"></a>await方法分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法是可以被中断的，不可被中断的是另外一个方法awaitUninterruptibly()</span></span><br><span class="line"><span class="comment">// 这个方法会被阻塞，直到调用signal或者被中断。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 方法要响应中断，就要在最开始判断中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 添加到Condition的条件队列中。</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放锁，释放的值是之前state的值</span></span><br><span class="line">    <span class="comment">// 要调用await方法，首先线程要获得锁，既然获得了锁，等待的之前肯定要释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里跳出循环的两种方式</span></span><br><span class="line">    <span class="comment">// 1. isOnSyncQueue(node)，返回true，说明已经转移到阻塞队列中了</span></span><br><span class="line">    <span class="comment">// 2. checkInterruptWhileWaiting(node) != 0会break，然后跳出循环，表示线程被中断。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被唤醒之后，进入阻塞队列，等待获取锁。</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将节点加入到条件队列"><a href="#将节点加入到条件队列" class="headerlink" title="将节点加入到条件队列"></a>将节点加入到条件队列</h2><p>addConditionWatier()是将当前节点加入到条件队列，这种条件队列内操作是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前线程对应的节点入队，插入队尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="comment">// 如果条件队列的队尾节点取消了排队，就把这个节点清除</span></span><br><span class="line">    <span class="comment">// 如果waitstatus 不为node.CONDITION,则说明取消了在条件队列中排队。</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 下面的方法会遍历这个队列，将取消等待的节点清除</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在节点初始化时，要将waitStatus设置为node.CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Node.CONDITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t 此时时lastWaiter队尾</span></span><br><span class="line">    <span class="comment">// 如果队列为空的话</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在addWaiter方法中，有一个unlinkCancelledWaiters()方法，该方法用于清除已经取消排队的节点。</p>
<p>如果在调用await方法的时候发生了取消操作，或者在节点入队的时候，发现最后一个节点是被取消的，会调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待队列是一个单向链表，遍历链表将已经取消的节点清除</span></span><br><span class="line"><span class="comment">// 这个方法在本来注释中有一句"Called only while holding lock."</span></span><br><span class="line"><span class="comment">// 说明只有在拥有锁的时候才能调用这个方法，则说明是线程安全的。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全释放独占锁"><a href="#完全释放独占锁" class="headerlink" title="完全释放独占锁"></a>完全释放独占锁</h2><p>回到wait方法，节点入队以后，会调用<code>int savedState = fullyRelease(node);</code>方法来释放锁，这里是完全释放独占锁(fully release),因为ReentrantLock是可重入的。</p>
<p>如果在执行condition1.await()之前，先执行了两次lock()操作，那么state为2，可以理解为该线程上了两把锁，这里await()方法必须将state设置为0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有两把锁，才能继续下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，要观察到返回值saveState代表release之前的state值</span></span><br><span class="line"><span class="comment">// 对于简单的操作：先lock.lock(),然后condition1.await().</span></span><br><span class="line"><span class="comment">// 那么state经过这个方法由1变成0，锁释放，此方法返回1</span></span><br><span class="line"><span class="comment">// 相应的，如果lock重入了n次，savedState == n</span></span><br><span class="line"><span class="comment">// 如果这个方法失败，会将节点设置为"取消"状态，并抛出异常IllegalMonitorStateException</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 使用当前的state作为操作，将锁完全释放掉。</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState))</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        node.waitStatus = Node.CANCELLED;</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个线程在不持有lock的基础上，就去调用condition1.await()方法，它能进入条件队列，但在上面的方法中，使用release方法会返回false。就会抛出IllegalMonitorStateException错误，然后进入catch代码块。将waitState状态设置为取消，那么在下一个节点入队的时候，就会把这个取消的节点清除。</p>
<h2 id="等待进入阻塞队列"><a href="#等待进入阻塞队列" class="headerlink" title="等待进入阻塞队列"></a>等待进入阻塞队列</h2><p>await方法中，在释放了锁之后会进入下面的代码块中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果节点不在阻塞队列中</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 那么这个节点将会被挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列中了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在节点入条件队列的时候，初始化时设置了waitStatus = Node.CONDITION</span></span><br><span class="line"><span class="comment">// 调用signal的时候，需要将节点从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="comment">// 这个方法用于判断node节点是否已经在阻塞队列中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在从条件队列移动到阻塞队列的时候，waitStatus会置0</span></span><br><span class="line">    <span class="comment">// 如果这个时候node.waitStatus还是-2的话，说明并没有转移到阻塞队列中</span></span><br><span class="line">    <span class="comment">// 如果node的前驱prev指向还是null，说明肯定没有在阻塞队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果node有了后置节点，说明一定在阻塞队列中了。</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 下面这个方法从阻塞队列的队尾开始从后往前遍历，如果找到相等的，说明在阻塞队列中，否则就不在</span></span><br><span class="line">    <span class="comment">// 不能通过判断node.prev != null 来推断出node在阻塞队列中</span></span><br><span class="line">    <span class="comment">// 在入阻塞队列的时候，是先将node.prev 指向tail</span></span><br><span class="line">    <span class="comment">// 然后是CAS将自己设置为新的tail，这次的CAS是可能失败的。</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>isOnSyncQueue(node)如果返回false，那么就会进入到LockSupport(this)，将当前线程挂起。</p>
<h2 id="signal-唤醒线程，转移到阻塞队列"><a href="#signal-唤醒线程，转移到阻塞队列" class="headerlink" title="signal 唤醒线程，转移到阻塞队列"></a>signal 唤醒线程，转移到阻塞队列</h2><p>唤醒操作通常由另外一个线程来操作，就像在消费者和生产者模型中，如果线程因为等待消费而被挂起，那么当生产者生产了一个东西之后，就会调用signal来唤醒消费线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒了等待最久的线程</span></span><br><span class="line"><span class="comment">// 这里的唤醒其实就是将条件队列中对应的node转移到阻塞队列中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用signal的线程必须持有独占锁。</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从条件队列从头往后遍历，找出第一个需要转移的node</span></span><br><span class="line"><span class="comment">// 因为线程有可能会取消排队，但可能还会在队列中。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// firstWaiter指向first节点的下一个节点，因为firstWaiter将要离开了</span></span><br><span class="line">        <span class="comment">// 如果将first移除之后，没有节点在等待了。那么就要将lastWaiter置为null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// first节点马上要去阻塞队列了，那么就要把条件队列的连接关系断了</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">            (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// while循环，如果first转移不成功，那么就找下一个节点，以此类推</span></span><br><span class="line">    <span class="comment">// 直到找到能够转移的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点从条件队列转移到阻塞队列中</span></span><br><span class="line"><span class="comment">// true表示成功</span></span><br><span class="line"><span class="comment">// false表示在signal之前，已经取消了排队。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里如果cas失败了，说明此node的waitStatus已经不是Node.CONDITION,已经取消了排队</span></span><br><span class="line">    <span class="comment">// 在条件队列里已经取消了排队，则也就不需要转移了。返回false，移向后一个节点</span></span><br><span class="line">    <span class="comment">// 如果cas成功，则将ws设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// enq(node):自旋进入阻塞队列的队尾</span></span><br><span class="line">    <span class="comment">// 这里的返回值p是node在阻塞队列的前驱节点。</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// ws &gt; 0 说明node在阻塞队列中的前驱节点取消了等待锁，直接唤醒node对应的线程</span></span><br><span class="line">    <span class="comment">// 如果ws &lt;= 0 那么compareAndSetWaitStatus将会被调用</span></span><br><span class="line">    <span class="comment">// 在上篇中说过当节点入队之后需要将前驱节点设置为Node.SIGNAL(-1)</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果前驱节点取消或者设置失败，就会唤醒node对应线程。</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说<code>ws &gt; 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL)</code>中，ws &lt;= 0,而且!p.compareAndSetWaitStatus(ws, Node.SIGNAL) 会返回true，所以一般也不会进入if语句块中唤醒node对应的线程。然后这个方法返回true，也就意味着signal这个方法结束了，节点进入阻塞队列。</p>
<p>假设发生了阻塞队列中的前驱节点取消等待，或者CAS失败，只要唤醒线程，让他进入到下一步即可。</p>
<h2 id="唤醒后检查中断状态"><a href="#唤醒后检查中断状态" class="headerlink" title="唤醒后检查中断状态"></a>唤醒后检查中断状态</h2><p>在signal之后，线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到了锁以后，继续往下执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interruptMode 可以取值为REINTERRUPT(1), THROW_IS(-1), 0</p>
<ul>
<li>REINTERRUPT: 代表await返回的时候，需要重新设置中断状态</li>
<li>THROW_IE: 代表await返回的时候，需要抛出InterruptException异常</li>
<li>0: 说明await期间，没有发生中断</li>
</ul>
<p>有三种情况会让LockSupport.park(this)这句话返回继续往下执行：</p>
<ul>
<li>常规路径：signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁(unpark)</li>
<li>线程中断。在park的时候，另外一个线程对这个线程进行了中断</li>
<li>signal的时候，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li>
<li>假唤醒。 和Object.wait()类似，都存在的问题。</li>
</ul>
<p>线程唤醒之后第一步是调用checkInterruptWhileWaiting(node)这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生中断，是signal调用之前中断的，还是signal之后发生</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如果是在signal之前已经中断，返回THROW_IE</span></span><br><span class="line"><span class="comment">// 2. 如果是signal之后中断，返回REINTERRUPT</span></span><br><span class="line"><span class="comment">// 3. 没有发生中断则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>Thread.interrupted() 方法返回true，则说明已经被中断，需要重新设置中断设置</p>
<p>如何判断中断发生在signal之前还是之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有线程处于中断状态，才会调用此方法</span></span><br><span class="line"><span class="comment">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列中</span></span><br><span class="line"><span class="comment">// 如果该线程在signal之前中断，则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用cas将节点设置为0</span></span><br><span class="line">    <span class="comment">// 如果这步成功了，说明节点是在signal被中断的</span></span><br><span class="line">    <span class="comment">// 因为如果在signal之后发生的话，signal方法中会将waitStatus设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (node.compareAndSetWaitStatus(Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 到这里说明cas成功，则将节点放入阻塞队列中</span></span><br><span class="line">        <span class="comment">// 运行这步说明即便是中断了，节点还是会被转移到阻塞队列中</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明cas失败了，因为signal方法将waitStatus设置为了0</span></span><br><span class="line">    <span class="comment">// signal方法会将节点转移到阻塞队列中，但是可能还没完成，这边自旋等待其完成</span></span><br><span class="line">    <span class="comment">// 发生signal调用之后，没完成转移之前发生了中断。这种情况还是比较少的。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里描绘了一个场景，本来有个线程在条件队列排队，但是因为被中断了，那么他会被唤醒。然后突然发现自己不是被signal(唤醒)的那个，但是他会自己主动加入到阻塞队列。</p>
<h2 id="获取独占锁"><a href="#获取独占锁" class="headerlink" title="获取独占锁"></a>获取独占锁</h2><p>while循环出来以后，是下面这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// await中的代码</span></span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != Throw_IE) &#123;</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从while循环出来之后，我们已经确定节点在阻塞队列中，准备获取锁</p>
<p>这里的acquireQueued(node, savedState)的第一个参数node之前经过enq(node)进入队列，参数savedState是之前释放锁前的state，则个方法返回的时候，代表线程已经获取了锁，而且state == savedState</p>
<p>注意，在前面说过不管是否发生中断，都会进入阻塞队列中，而acquireQueued(node, savedState)的返回值就是代表线程是否被中断。如果返回true，说明被中断了，而且interruptMode != THROW_IE，说明在signal之前就发生中断了，这里将interruptMode设置为REINTERRUPT，用于待会重新中断。</p>
<p>继续执行的话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure>

<p>这里的<code>node.nextWaiter != null</code> 是怎么满足的。在进行signal的时候，会将节点转移到阻塞队列中。有一步是node.nextWaiter = null，将断开节点和条件队列的联系</p>
<p>可是，在<code>判断中断发生的时机中，会判断是signal执行前还是执行后</code>，如果signal之前就发生中断了，虽然节点会转移到阻塞队列中，但是并不会切断条件队列中的连接。也就是没有将node.nextWaiter设置为null。</p>
<p>还有如果节点取消，也会调用unlinkCancelledWaiter这个方法。</p>
<h2 id="处理中断状态"><a href="#处理中断状态" class="headerlink" title="处理中断状态"></a>处理中断状态</h2><p>现在可以说说interruptMode是干啥用的了</p>
<ul>
<li>0：啥也不做，没有被中断过</li>
<li>THROW_IE: await方法抛出InterruptedException异常，因为他代表了在await期间发生过中断</li>
<li>REINTERRUPT: 重新中断当前线程，因为它代表了虽然await期间没有被中断过，但是在signal以后发生了中断。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AbstractQueuedSynchronizer独占锁的取消排队"><a href="#AbstractQueuedSynchronizer独占锁的取消排队" class="headerlink" title="AbstractQueuedSynchronizer独占锁的取消排队"></a>AbstractQueuedSynchronizer独占锁的取消排队</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这个方法的时候，节点一定是入队成功的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某个线程调用lock()一直不返回，我们需要中断它。一旦对其中断，此线程会从<code>LockSupport.park(this)</code>中被唤醒，然后Thread.interrupt()返回true。</p>
<p>即便是中断唤醒了这个线程，也就只是设置了<code>interrupted = true</code>然后继续下一次循环。而且，由于<code>Thread.interrupted();</code>会清除中断状态，第二次进parkAndCheckInterrupt的时候，返回会是false。</p>
<p>所以，在这个方法中，interrupt只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情。</p>
<p>外层方法处理acquireQueued返回false的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，可以知道lock()处理中断的方式是，中断归中断，锁还是要照样抢的，几乎没有关系(<code>interrupt = true 但是没有返回true状态，继续循环</code>)，只是在抢到锁之后，设置线程的中断状态而已，也不抛出任何异常。调用者获取锁之后，可以去检查是否发生了中断，也可以不理会(好流氓….)。</p>
<p>现在来看看ReentrantLock的另外一个lock方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法多了一个 <code>throws InterruptedException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span></span><br><span class="line">                <span class="comment">// 这里不再只是标记这个方法的返回值代表中断状态</span></span><br><span class="line">                <span class="comment">// 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 找一个合适的前驱。其实就是将它前面的队列中已经取消的节点都”请出去“</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java线程中断和InterruptedException异常"><a href="#Java线程中断和InterruptedException异常" class="headerlink" title="Java线程中断和InterruptedException异常"></a>Java线程中断和InterruptedException异常</h1><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>这里的中断不是类似于linux中的命令kill -9 pid，不是说我们要中断某个线程，这个线程就停止运行了。中断代表线程状态，每个线程都关联了一个中断状态，是一个true或者false的boolean值，初始值为false。与操作系统中的中断不同，这里更像一个状态。</p>
<p>关于中断状态，需要重点关注Thread类中的一下几个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 类中的实例方法，持有线程实例引用即可检测线程中的状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread中的静态方法， 检测调用这个方法是否已经被中断</span></span><br><span class="line"><span class="comment">// 注意：这个方法返回中断状态的同时，会将线程的中断状态重置为false</span></span><br><span class="line"><span class="comment">// 所以，如果我们调用两次这个方法的话，第二次的返回值就是false了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread类中的实例方法，用于设置一个线程的中断状态为true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们常说的中断一个线程，其实就是将这个线程的中断状态设置为true。如何使用这个状态则视情况而定。</p>
<p>如果线程处于下面三种情况，那么线程被中断的时候，就能自动被感知到：</p>
<ol>
<li><p>来自Object类的wait()、wait(long)、wait(long, int)，来自Thread类的join()、jon(long)、jon(long, int)</p>
<p> 这几个方法的相似之处就是，方法上都有：throws interruptedException<br> 如果线程阻塞在这些方法上，这个时候如果其他线程对这个线程进行了中断，那么这个线程就会从这些方法中立即返回，抛出InterruptedException异常，同时重置中断状态为true</p>
</li>
<li><p>实现了InterruptibleChannel接口的类中的一些I/O阻塞操作，入DatagramChannel中的connect方法和receive方法</p>
<p> 如果线程阻塞在这里，中断线程会导致这些方法抛出CloseByInterruptException并重置中断状态</p>
</li>
<li><p>Selector中的select方法，一旦中断，方法立即返回</p>
</li>
</ol>
<p>对于上面三种是特殊的，因为他们能自动感知到中断，并且在做出相应操作之后都会重置中断状态为false。</p>
<p>但是不只是上面三种状态能自动感知到中断，如果线程阻塞在LockSupport.park(Object obj)方法，也叫挂起，这个时候的中断也会导致线程唤醒，但是唤醒之后不会重置中断状态，所以唤醒之后去检测中断状态将是true。</p>
<h2 id="InterruptedException概述"><a href="#InterruptedException概述" class="headerlink" title="InterruptedException概述"></a>InterruptedException概述</h2><p>这是一个特殊的异常，不是jvm对其有特殊的处理，而是使用场景比较特殊。通常，可以看到，像Object中的wait()方法，ReentrantLock中的lockInterruptibly()方法，thread中的sleep()方法等等，这些方法都带有<code>throws InterruptedException</code>，我们通常称这些方法为阻塞方法(blocking methos)</p>
<p>阻塞方法有一个明显的特征就是，他们需要花费特别长的时间(非绝对，而是占用时间是不可预知的)，还有他们的方法结束返回往往依赖于外部条件，如wait方法依赖于其他线程notify，lock方法依赖于其他线程的unlock等等。</p>
<p>当我们看到方法上带有<code>throws InterruptedException</code>时，我们大概就能知道，这个方法应该是阻塞方法，如果我们希望它能提前返回的话，可以通过中断来实现</p>
<p>除了几个特殊的类（Object、Thread等）之外，感知中断并提前返回是通过轮询中断状态来实现的。我们自己需要写可中断的方法的时候，就是通过在合适的时机（通常在循环的开始处）去判断线程的中断状态，然后做出相应的操作。我们也要知道，如果我们一次循环花的时间比较长的话，那么就需要比较长的时间才能感知到线程中断了。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2" target="_blank" rel="noopener">一行一行源码分析清楚AQS</a></p>
<p><img src="https://brandonxcc.top/20200510.jpg" alt="avatar"></p>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/java%E5%B9%B6%E5%8F%91/">java并发</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2020/05/13/J.U.C/AQSAQS%E6%BA%90%E7%A0%81%E4%B8%89/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">AQS源码解析三</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2020/04/19/J.U.C/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80/">
        <span class="next-text nav-default">AQS源码解析(一)</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">brandon</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v="></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-z16"},"display":{"position":"left","width":150,"height":345},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
