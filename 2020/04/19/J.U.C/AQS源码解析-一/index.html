<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="AQS源码解析(一)"/><meta name="keywords" content="java并发, brandon" /><link rel="alternate" href="/atom.xml" title="brandon">
<link rel="canonical" href="https://1234zhang.github.io/2020/04/19/J.U.C/AQS源码解析-一/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":"","toc":"","fancybox":"","pjax":"","latex":""};
</script>

    <title>AQS源码解析(一) - brandon</title>
  <meta name="generator" content="Hexo 4.2.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">brandon</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">brandon</a>
</div>

<nav class="site-navbar"></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">AQS源码解析(一)
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-04-19
        </span><span class="post-category">
            <a href="/categories/Java/">Java</a>
            <a href="/categories/Java/JUC/">JUC</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开始拜读Doug Lea大神的并发源码了，作为一个小菜鸡，可能理解不了太多这里面的一些编程思想，只希望能了解一个大概过程，在平时使用或者解决问题的时候有一个清晰的思路去分析问题的原因然后去解决这个问题。</p>
<p>AbstractQueueSynchronizer(简称AQS)这个抽象类，是实现ReentrantLock、CountDownlatch、Semaphore、FutureTask等类的基础。</p>
<p>站在使用者的角度，AQS的功能主要分为两大类：独占锁和共享锁。在他的所有子类中，要么实现并使用了它独占锁的API，要么使用了共享锁的API，而不会同时使用两种API。即便是ReentrantReadWriteLock，也是通过两个内部类，读锁和写锁，分别实现了两套API来实现这两个功能。</p>
<h1 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h1><p>AQS的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点，当前持有锁的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞尾节点，每个新的节点进来，都插入到最后，就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前锁的状态，0表示没有被占用，大于0代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于1，因为锁可以重入，每次重入都要加上1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，使用例子(因为锁是可以重入的)</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有的锁</span></span><br><span class="line"><span class="comment">// if(currentThreed == getExclusiveOwnerThread()) &#123;state++;&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">// 继承自AbstractOwnableSynchronizer</span></span><br><span class="line"><span class="comment">// 同时这个变量没有被volatile关键字修饰，因为这个变量只要自己能看到就可以了。</span></span><br></pre></td></tr></table></figure>

<h2 id="Node结构-双向链表"><a href="#Node结构-双向链表" class="headerlink" title="Node结构(双向链表)"></a>Node结构(双向链表)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="comment">// 表示当前节点是在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 表示当前节点是在独占模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下的常量是给waitState使用状态</span></span><br><span class="line">    <span class="comment">// 表示线程取消了等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示下一个节点是通过park阻塞的，需要通过unpark唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示线程在等待条件变量(先获取锁，加入到条件等待队列，然后释放锁，等待条件变量满足条件；只有重新获得锁之后才能返回)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示后续节点会传播唤醒操作，共享模式下起作用。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态，对于condition节点，初始化为CONDITION；其他默认为0，通过cas设置</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有了node结构的概念之后，我们再回头看看AQS的等待队列示意图<br><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-3.png" alt="aqs"></p>
<h2 id="AQS的模板方法以及介绍"><a href="#AQS的模板方法以及介绍" class="headerlink" title="AQS的模板方法以及介绍"></a>AQS的模板方法以及介绍</h2><ol>
<li>isHeldExclusively(): 判断该线程是否正在独占线程。只有用到condition才需要去实现他</li>
<li>tryAcquire(int): 独占的方式。尝试获取资源，成功则返回true，失败则放回false</li>
<li>tryRelease(int): 独占方式。尝试释放资源，成功返回true，失败返回false</li>
<li>tryAcquireShared(int): 共享方式。尝试获取资源，负数表示失败。0 表示成功，但是没有资源可以被申请；正数表示成功，而且有资源能够被获取。</li>
<li>tryReleaseShared(int): 共享的方式。尝试释放资源，成功返回true，失败返回false。</li>
</ol>
<p>以上就是AQS给子类提供的模板方法，给子类实现自定义的同步器。</p>
<h2 id="争锁操作"><a href="#争锁操作" class="headerlink" title="争锁操作"></a>争锁操作</h2><p>通过ReentrantLock来看看AQS是如何实现的。ReentrantLock内部使用了一个内部类Sync来管理锁，所以真正的获取锁和释放锁是由Sync来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 同时还有两个继承类，用来分别实现了公平锁与非公平锁、</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ReentrantLock</span>(<span class="title">boolean</span> <span class="title">fair</span>) </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; <span class="comment">// 争锁</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面是父类AQS中的Acquire实现</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果tryAcquire(arg) 返回true，则获取资源成功，便使用锁资源进行下一步操作</span></span><br><span class="line"><span class="comment">            如果返回false，acquireQueue方法将线程压到队列中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// 此时的arg == 1</span></span><br><span class="line">             <span class="comment">// 首先使用tryAcquire(1)，可能直接成功，就不需要进入阻塞队列</span></span><br><span class="line">             </span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果获取失败，就会将当前线程挂起，然后进入阻塞队列。</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@ReservedStackAccess</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">// 获取当前资源锁的状态，如果为0 此时此刻没有线程持有该锁</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">// 如果没有上锁，则尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 此时该锁是可以用的，但是公平锁就是讲究一个公平，他要查看阻塞队列中没有老哥一直等着的，如果有，他也会老老实实去排队</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    <span class="comment">// 如果没有人排队，就使用cas试一下，如果能成功</span></span><br><span class="line">                    <span class="comment">// 就直接获取该锁资源</span></span><br><span class="line">                    <span class="comment">// 如果不成功，说明有锁在跟我同时在获取这个资源。</span></span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    <span class="comment">// 获取到锁资源之后，要进行标记，告诉大家我获得这个锁了</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断已经加锁的线程是本线程，则重入锁。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到这里，说明没有获取到锁，则要进入到阻塞队列中排队。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>加入到阻塞队列中addWaiter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发现jdk9与jdk8有一些改变，但思想是没变的。</span></span><br><span class="line"><span class="comment">// jdk9改成使用VarHandle来新建节点，以及修改tail节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取老的尾节点</span></span><br><span class="line">            Node oldTail = tail;</span><br><span class="line">            <span class="comment">// 如果tail不是空的话，新建node节点的前驱指针指向oldTail，反之初始化阻塞队列</span></span><br><span class="line">            <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置 新建节点的前驱指针指向tail</span></span><br><span class="line">                node.setPrevRelaxed(oldTail);</span><br><span class="line">                <span class="comment">// 使用cas把自己设置为队尾，如果成功，tail == node，这个新建节点成为新尾巴</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                    <span class="comment">// 上面已经有了node.setPrevRelaxed(oldTail);，</span></span><br><span class="line">                    <span class="comment">// 加上下面这句，就实现了和之前的尾节点的挂钩的双向连接了。</span></span><br><span class="line">                    oldTail.next = node;</span><br><span class="line">                    <span class="comment">// 新建节点入队列，然后返回这个节点。</span></span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果原来队列没有元素，就要初始化这个队列。</span></span><br><span class="line">                initializeSyncQueue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面进入初始化队列</span></span><br><span class="line">    <span class="comment">// 只有队列为空的时候，才会运行这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node h;</span><br><span class="line">        <span class="keyword">if</span> (HEAD.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</span><br><span class="line">            tail = h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在再来回顾一下，当线程没有抢到锁资源的时候发生了什么<br>    // if (!tryAcquire(arg)<br>    //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>    //     selfInterrupt();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接下来就要接着谈谈acqireQueue 这个方法</span></span><br><span class="line"><span class="comment">// 下面这个方法很重要，在经过addWaiter(Node.EXCLUSIVE)，此时线程已经进入阻塞队列中</span></span><br><span class="line"><span class="comment">// 如果acquireQueued返回true的话，意味着将要执行selfInterrupt()这个方法。</span></span><br><span class="line"><span class="comment">// 所以acquireQueued这个方法很重要，线程的挂起以及被唤醒之后去获取锁，都在这个方法中。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                p == head 说明当前节点虽然进到了阻塞队列中，但是是阻塞队列中的第一个，因为他的前驱节点是head。</span></span><br><span class="line"><span class="comment">                注意， 阻塞队列不包含head节点，head一般是指的占有锁的进程，head后面的才是阻塞队列</span></span><br><span class="line"><span class="comment">                首先 head是队列头，其次head有可能是刚刚初始化的node。</span></span><br><span class="line"><span class="comment">                head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class="line"><span class="comment">                也就是说，当前的head可能不属于任何线程，所以作为阻塞队列的队头，可以尝试去获取锁资源</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果到这里，说明if分支没有成功，有两个原因</span></span><br><span class="line">            <span class="comment">// 1. 可能node本来就不是队头</span></span><br><span class="line">            <span class="comment">// 2. tryAcquire没有抢赢别人。</span></span><br><span class="line">            <span class="comment">// 下面两个判断如果都为true了，该线程就要被挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 在tryAcquire抛出异常的时候，这个线程就会放弃争夺锁资源。</span></span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正如前文，会运行这个方法。</span></span><br><span class="line"><span class="comment">// 该方法表达的是"当前线程没有抢到锁，是否要挂起当前线程"</span></span><br><span class="line"><span class="comment">// 第一个参数是前驱节点，第二个参数才是当前节点。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">// 获取前驱节点的等待状态</span></span><br><span class="line">    <span class="comment">// 如果前驱节点是-1，则说明节点正常，可以挂起当前线程，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 前驱节点waitStatus大于0，说明前驱节点取消了排队</span></span><br><span class="line">    <span class="comment">// 在这里要注意的是，进入阻塞队列的线程都会被挂起，只能依靠前驱节点唤醒。</span></span><br><span class="line">    <span class="comment">// 所以下面的循环就是将当前节点的prev指向一个waitStatus&lt;=0的节点</span></span><br><span class="line">    <span class="comment">// 这里要找到前面的waitStatus&lt;=0的节点。才能保证能够唤醒当前节点。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 走到这里说明前驱节点不为-1和1，只能是0或者-2，-3</span></span><br><span class="line"><span class="comment">         * 一路走来都没有看到设置waitStatus的地方。</span></span><br><span class="line"><span class="comment">         * 原本的tail的waitStatus是0，突然新来了一个节点之后，还没改变</span></span><br><span class="line"><span class="comment">         * 自己的waitStatus。在下面使用cas将prev的waitStatus设置为-1</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个方法返回false，就会再走一遍上面的for循环，</span></span><br><span class="line">    <span class="comment">// 再进来该方法，然后返回true。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node);</p>
<p>这个方法的返回值进行分析：<br>如果这个方法返回的是true，那么就说明当前线程会被挂起，等待前驱节点获取到锁之后来唤醒你。</p>
<p>再来看看调用方法的这个地方<code>if(shouldParkAfterAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interupted = true;</code></p>
<ol>
<li><p>如果shouldParkAfterAcquire返回了true，那么就会进入下一个方法parkAndCheckInterrupt()，这个方法会挂起线程。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里使用了LockSupport.park(this);</span></span><br><span class="line">    <span class="comment">// 用来挂起线程，等待被唤醒。</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果返回了false，会进行一次for循环。其实在第一次进入shouldParkAfterAcquire这个方法的时候，一定会返回false，具体原因如上。这里还有提供了一个获取锁的机会，万一第二次循环的时候获取到锁了，那么就不用被挂起了。直接进行下一步的处理。</p>
</li>
</ol>
<h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>正常情况下，如果线程没有获取到锁，就会被<code>LockSupport.park(this);</code>挂起，等待被唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前线程开始请求释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否可以释放锁了</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// head是当前持有锁的节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果head为空了，说明队列里面没有阻塞节点，也不用去唤醒了。</span></span><br><span class="line">        <span class="comment">// waitState == 0，根据加锁的代码可以知道，这个是后续节点设置的。</span></span><br><span class="line">        <span class="comment">// 如果waitSate == 0，则后面也没有需要唤醒的节点。</span></span><br><span class="line">        <span class="comment">// 如果都不满足，说明队列中还有节点需要被唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后续节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="comment">// 锁释放成功。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 判断当前线程是否是锁的拥有线程</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 是否完全释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 这里其实是一个重入锁的概念，判断还有没有嵌套锁，如果没有了，就释放完全了</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒后续节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 记住，这里的node 是head</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 首先设置head的waitState为0</span></span><br><span class="line">        node.compareAndSetWaitStatus(ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 然后找到head的后继节点 B</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果B节点为空，或者取消了等待</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 下面就要从该队列的尾巴部分，开始往前面找，</span></span><br><span class="line">        <span class="comment">// 直到找到最前面的符合条件的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">            <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 在循环里面没有break，说明循环要一直执行下去。</span></span><br><span class="line">                s = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒这个节点，开始争夺锁</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于为什么要从尾部往前面找符合条件的节点,要关注一下下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//1. 维护 node 前驱节点</span></span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="comment">//2. 使用 CAS 将节点设置为队列尾节点</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               <span class="comment">//3. 维护 pred 的后继节点</span></span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如上面代码所说的，首先设置了前驱节点<code>node.pre = pred</code>,然后使用CAS入队，注意这里可能还没有入队，则就没有办法执行<code>pred.next = node</code>，这个时候如果是前面往后面开始找的话，就有可能发生找不到节点的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒线程之后，被唤醒的线程将从下面的代码继续往前走</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 刚刚线程被挂起在这里了</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在并发的条件下，需要以下三个部件的协调</p>
<ol>
<li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li>
<li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li>
<li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS采用了CLH锁的变体来实现。</li>
</ol>
<p><img src="https://brandonxcc.top/20200422.jpg" alt="avatar"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/pfnie/article/details/53191892" target="_blank" rel="noopener">AQS功能分析</a></p>
<p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">ReentrantLock公平锁的角度去分析AQS</a></p>
<p><a href="https://www.jianshu.com/p/c244abd588a8" target="_blank" rel="noopener">AQS源码分析</a></p>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/java%E5%B9%B6%E5%8F%91/">java并发</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2020/04/28/J.U.C/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">AQS源码解析(二)</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2020/04/18/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E4%B9%8BHashMap/">
        <span class="next-text nav-default">集合源码之HashMap</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">brandon</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v="></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-z16"},"display":{"position":"left","width":150,"height":345},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
